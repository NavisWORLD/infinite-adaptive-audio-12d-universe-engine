<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12D Cosmic Synapse - Audio-Driven Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #2a1a4a 100%);
            color: #ffffff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #00d4ff, #7b2ff7, #f06eaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.1em;
            color: #a0a0ff;
            margin-bottom: 15px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(123, 47, 247, 0.3);
        }

        .card h2 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .equation {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            margin: 10px 0;
            border-left: 3px solid #00d4ff;
            overflow-x: auto;
        }

        .value-display {
            background: rgba(123, 47, 247, 0.2);
            padding: 8px;
            border-radius: 8px;
            margin: 8px 0;
            font-size: 0.95em;
            border-left: 3px solid #7b2ff7;
        }

        #canvas-container {
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            margin: 20px 0;
            border: 2px solid rgba(0, 212, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group label {
            display: block;
            color: #00d4ff;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(45deg, #00d4ff, #7b2ff7);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(123, 47, 247, 0.5);
        }

        button {
            background: linear-gradient(45deg, #00d4ff, #7b2ff7);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(123, 47, 247, 0.5);
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .audio-controls {
            text-align: center;
            margin: 20px 0;
        }

        #micButton {
            background: linear-gradient(45deg, #ff0080, #ff8c00);
            font-size: 1.1em;
            padding: 15px 40px;
        }

        #micButton.active {
            background: linear-gradient(45deg, #00ff00, #00cc00);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.5); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 0, 0.8); }
        }

        .frequency-viz {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 10px 0;
            position: relative;
        }

        #frequencyCanvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .stat-box {
            background: rgba(0, 212, 255, 0.1);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .stat-label {
            font-size: 0.8em;
            color: #a0a0ff;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #00d4ff;
        }

        .token-display {
            background: rgba(240, 110, 170, 0.1);
            border: 1px solid rgba(240, 110, 170, 0.3);
            border-radius: 10px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
        }

        .token-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 3px solid #f06eaa;
            line-height: 1.5;
        }

        .token-item strong {
            color: #00d4ff;
        }

        .info-text {
            color: #b0b0ff;
            line-height: 1.5;
            margin: 8px 0;
            font-size: 0.9em;
        }

        .alert-box {
            background: rgba(123, 47, 247, 0.2);
            border-left: 4px solid #7b2ff7;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.95em;
        }

        #fps-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 10;
            font-size: 0.9em;
        }

        .audio-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 128, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10;
            display: none;
        }

        .audio-indicator.active {
            display: block;
            animation: blink 1s infinite;
        }

        .token-indicator {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0, 212, 255, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10;
            display: none;
            font-size: 0.9em;
        }

        .token-indicator.active {
            display: block;
            animation: pulse-blue 0.5s infinite;
        }

        @keyframes pulse-blue {
            0%, 100% { 
                background: rgba(0, 212, 255, 0.7);
                box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            }
            50% { 
                background: rgba(0, 255, 255, 0.9);
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé§ 12D Cosmic Synapse Theory</h1>
            <p class="subtitle">Audio-Driven Deterministic Cosmological Simulation Engine</p>
            <p class="info-text"><strong>CONTINUOUS TOKEN GENERATION:</strong> Audio ‚Üí FFT ‚Üí œÜ-Harmonics ‚Üí Sound-Color Mapping ‚Üí Seed Generation ‚Üí Token Stream</p>
            <p class="info-text" style="font-size: 0.85em; color: #7b2ff7;">Every audio frame generates multiple tokens through the 12D formula (œà = œÜE/c¬≤ + Œª + ‚à´v¬∑dt + Œ©E + U‚ÇÅ‚ÇÅD)</p>
        </header>

        <div class="audio-controls">
            <button id="micButton" onclick="toggleMicrophone()">üé§ START MICROPHONE ENGINE</button>
            <p class="info-text" style="margin-top: 10px;">
                <strong>Activate continuous token generation:</strong> Every 100ms, audio is analyzed and converted into:<br>
                ‚Ä¢ Audio Frame Tokens (complete spectrum snapshot)<br>
                ‚Ä¢ œÜ-Harmonic Tokens (golden ratio frequency series)<br>
                ‚Ä¢ Particle Creation/Update Tokens (visual entities)<br>
                ‚Ä¢ Sound‚ÜíColor‚ÜíSeed‚ÜíToken pipeline running in real-time
            </p>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üéµ Audio Input Analysis</h2>
                <div class="frequency-viz">
                    <canvas id="frequencyCanvas"></canvas>
                </div>
                <div class="value-display">
                    RMS Energy: <span id="rms-energy">0.00</span>
                </div>
                <div class="value-display">
                    Dominant Freq: <span id="dominant-freq">0.0</span> Hz
                </div>
                <div class="value-display">
                    Spectral Centroid: <span id="spectral-centroid">0.0</span> Hz
                </div>
                <p class="info-text">Live FFT analysis of environmental sound</p>
            </div>

            <div class="card">
                <h2>‚ö° Mass-Energy (Audio-Modulated)</h2>
                <div class="equation">E = mc¬≤ (modulated by RMS)</div>
                <div class="value-display">
                    Base Energy: <span id="energy-value">8.99e16</span> J
                </div>
                <div class="value-display">
                    Audio Gain: <span id="audio-gain">1.00</span>x
                </div>
                <p class="info-text">Energy scaled by audio amplitude</p>
            </div>

            <div class="card">
                <h2>üåÄ œÜ-Harmonic Series</h2>
                <div class="equation">f_n = f‚ÇÄ ¬∑ œÜ^(n/2)</div>
                <div class="value-display">
                    œÜ = <span id="phi-value">1.618033988749895</span>
                </div>
                <div class="value-display">
                    Harmonics: <span id="harmonics-count">0</span> generated
                </div>
                <p class="info-text">Golden ratio frequency spacing</p>
            </div>

            <div class="card">
                <h2>ü¶ã Chaos & Butterfly Effect</h2>
                <div class="equation">Œª = lim (1/t) ln|dX(t)/dX(0)|</div>
                <div class="value-display">
                    Lyapunov: <span id="lyapunov-value">0.905</span>
                </div>
                <div class="value-display">
                    Audio Chaos: <span id="audio-chaos">0.00</span>
                </div>
                <p class="info-text">Chaos driven by frequency variance</p>
            </div>
        </div>

        <div class="card">
            <h2>üåä Lorenz Attractor - Audio-Reactive Visualization</h2>
            <div id="canvas-container">
                <div id="fps-counter">FPS: <span id="fps">60</span></div>
                <div class="audio-indicator" id="audioIndicator">üé§ LISTENING</div>
                <div class="token-indicator" id="tokenIndicator">üé´ GENERATING TOKENS</div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>œÉ (Sigma): <span id="sigma-display">10</span></label>
                    <input type="range" id="sigma" min="1" max="20" value="10" step="0.1">
                </div>
                <div class="control-group">
                    <label>œÅ (Rho): <span id="rho-display">28</span></label>
                    <input type="range" id="rho" min="10" max="40" value="28" step="0.1">
                </div>
                <div class="control-group">
                    <label>Œ≤ (Beta): <span id="beta-display">2.667</span></label>
                    <input type="range" id="beta" min="1" max="5" value="2.667" step="0.01">
                </div>
                <div class="control-group">
                    <label>Audio Sensitivity: <span id="sensitivity-display">1.0</span></label>
                    <input type="range" id="sensitivity" min="0.1" max="5" value="1.0" step="0.1">
                </div>
                <div class="control-group">
                    <label>Replication Threshold: <span id="replication-display">50</span></label>
                    <input type="range" id="replication" min="10" max="200" value="50" step="10">
                </div>
            </div>

            <div style="text-align: center;">
                <button onclick="resetSystem()">üîÑ Reset</button>
                <button onclick="togglePause()">‚èØÔ∏è Pause/Play</button>
                <button onclick="changeColor()">üé® Color</button>
                <button onclick="addParticle()">‚ûï Add Particle</button>
            </div>
        </div>

        <!-- 12D CST Advanced Controls -->
        <div class="grid">
            <div class="card">
                <h2>‚öõÔ∏è Physics Controls</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Blend Lorenz: <span id="blend-lorenz-display">0.7</span></label>
                        <input type="range" id="blend-lorenz" min="0" max="1" value="0.7" step="0.05">
                        <small class="info-text">0=gravity only, 1=Lorenz only</small>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="grav-enabled">
                            Enable Gravity
                        </label>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="dm-enabled">
                            Enable Dark Matter
                        </label>
                    </div>
                    <div class="control-group">
                        <label>Cutoff Radius: <span id="rcutoff-display">10.0</span></label>
                        <input type="range" id="rcutoff" min="1" max="50" value="10.0" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>Softening (Œµ): <span id="epsilon-display">0.1</span></label>
                        <input type="range" id="epsilon" min="0.01" max="1" value="0.1" step="0.01">
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üß† Adaptive State Controls</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>k (Coupling): <span id="k-display">0.5</span></label>
                        <input type="range" id="k" min="0" max="2" value="0.5" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Œ≥ (Decay): <span id="gamma-display">0.2</span></label>
                        <input type="range" id="gamma" min="0" max="1" value="0.2" step="0.05">
                    </div>
                    <div class="control-group">
                        <label>Œ± (Memory): <span id="alpha-display">0.3</span></label>
                        <input type="range" id="alpha" min="0" max="1" value="0.3" step="0.05">
                    </div>
                    <div class="control-group">
                        <label>œÉ (Similarity): <span id="sigma-sim-display">0.3</span></label>
                        <input type="range" id="sigma-sim" min="0.1" max="1" value="0.3" step="0.05">
                    </div>
                </div>
            </div>

            <!-- NEW: Adaptive state strip chart -->
            <div class="card">
                <h2>üß† Adaptive State Trace</h2>
                <canvas id="adaptiveStateCanvas" width="400" height="120" style="width: 100%; height: 120px; border-radius: 10px; background: rgba(0,0,0,0.3); margin-top: 10px;"></canvas>
            </div>

            <div class="card">
                <h2>üîÑ Synchronization & Timestep</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>K_sync: <span id="ksync-display">0.1</span></label>
                        <input type="range" id="ksync" min="0" max="1" value="0.1" step="0.01">
                    </div>
                    <div class="control-group">
                        <label>Max dt: <span id="dtmax-display">0.01</span></label>
                        <input type="range" id="dtmax" min="0.001" max="0.1" value="0.01" step="0.001">
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="adaptive-dt" checked="true">
                            Adaptive Timestep
                        </label>
                    </div>
                    <div class="control-group">
                        <label for="projection-mode">Projection Mode:</label>
                        <select id="projection-mode" style="width: 100%; padding: 5px; border-radius: 5px; background: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.2);">
                            <option value="orthogonal">Orthogonal</option>
                            <option value="random_embedding">Random Embedding</option>
                            <option value="learned_embedding">Learned Embedding</option>
                        </select>
                        <p class="info-text">Active: <span id="projection-status">orthogonal</span></p>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üé¨ Determinism & Replay</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Seed: <input type="number" id="deterministic-seed" value="12345" style="width: 100px;"></label>
                        <button onclick="setDeterministicSeed(parseInt(document.getElementById('deterministic-seed').value))">Set Seed</button>
                    </div>
                    <div class="control-group">
                        <button onclick="toggleRecording()" id="record-btn">üî¥ Start Recording</button>
                        <button onclick="toggleReplay()" id="replay-btn">‚ñ∂Ô∏è Replay</button>
                    </div>
                    <div class="value-display" id="recording-status">Not recording</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üß™ Replay Validation</h2>
                <div class="stats">
                    <div class="stat-box"><div class="stat-label">ŒîE/E‚ÇÄ</div><div class="stat-value" id="replay-edrift">0.00%</div></div>
                    <div class="stat-box"><div class="stat-label">|P|</div><div class="stat-value" id="replay-pmag">0.00</div></div>
                    <div class="stat-box"><div class="stat-label">|L|</div><div class="stat-value" id="replay-lmag">0.00</div></div>
                    <div class="stat-box"><div class="stat-label">Virial</div><div class="stat-value" id="replay-virial">1.00</div></div>
                </div>
                <p class="info-text">Replay mode must reproduce identical diagnostics for a given recording + seed.</p>
            </div>

        <!-- 12D CST Advanced Displays -->
        <div class="grid">
            <div class="card">
                <h2>üìä Conservation Diagnostics</h2>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">E_total</div>
                        <div class="stat-value" id="conservation-etotal">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ŒîE/E‚ÇÄ</div>
                        <div class="stat-value" id="conservation-edrift">0.00%</div>
                        <!-- Added energy-drift span to fix validation warning -->
                        <span id="energy-drift" style="display:none;">0.00%</span>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">|P|</div>
                        <div class="stat-value" id="conservation-pmag">0.00</div>
                        <!-- Added momentum-magnitude span to fix validation warning -->
                        <span id="momentum-magnitude" style="display:none;">0.00</span>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">|L|</div>
                        <div class="stat-value" id="conservation-lmag">0.00</div>
                        <!-- Added angular-momentum-magnitude span to fix validation warning -->
                        <span id="angular-momentum-magnitude" style="display:none;">0.00</span>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Virial</div>
                        <div class="stat-value" id="conservation-virial">1.00</div>
                        <!-- Added virial-ratio span to fix validation warning -->
                        <span id="virial-ratio" style="display:none;">1.00</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üéµ Synchronization Metrics</h2>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Order (r)</div>
                        <div class="stat-value" id="sync-r">0.00</div>
                        <!-- Added sync-order-r span to fix validation warning -->
                        <span id="sync-order-r" style="display:none;">0.00</span>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Mean Œ∏</div>
                        <div class="stat-value" id="sync-mean">0¬∞</div>
                        <!-- Added sync-mean-theta span to fix validation warning -->
                        <span id="sync-mean-theta" style="display:none;">0¬∞</span>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Std Œ∏</div>
                        <div class="stat-value" id="sync-std">0.0¬∞</div>
                        <!-- Added sync-std-theta span to fix validation warning -->
                        <span id="sync-std-theta" style="display:none;">0.0¬∞</span>
                    </div>
                </div>
                <p class="info-text">r=1: fully synchronized, r=0: no synchronization</p>
            </div>

            <div class="card">
                <h2>üß¨ 12D Internal State Metrics</h2>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Avg x‚ÇÅ‚ÇÇ</div>
                        <div class="stat-value" id="12d-avg-x12">0.000</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Avg m‚ÇÅ‚ÇÇ</div>
                        <div class="stat-value" id="12d-avg-m12">0.000</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Avg Œ©</div>
                        <div class="stat-value" id="12d-avg-omega">0.000</div>
                    </div>
                </div>
                <div class="value-display">
                    <strong>Avg |dx‚ÇÅ‚ÇÇ/dt|:</strong> <span id="12d-avg-dx12">0.000</span>
                </div>
                <div class="value-display">
                    <strong>Avg œà:</strong> <span id="12d-avg-psi">0.000</span>
                </div>
                <div class="value-display">
                    <strong>x‚ÇÅ‚ÇÇ Range:</strong> <span id="12d-x12-min">0.00</span> to <span id="12d-x12-max">0.00</span>
                </div>
                <p class="info-text">Real-time 12D internal state evolution tracking</p>
            </div>

            <div class="card">
                <h2>üåÄ œà Normalized Breakdown</h2>
                <div class="value-display">
                    <strong>Energy Term:</strong> <span id="psi-energy-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>Œª Term:</strong> <span id="psi-lambda-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>‚à´||v|| dt:</strong> <span id="psi-velint-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>‚à´|Œîx‚ÇÅ‚ÇÇ| dt:</strong> <span id="psi-x12int-term">0.000</span>
                    <br><small style="color: #888; margin-left: 20px;">Avg: <span id="psi-x12int-avg">0.000</span> | Max: <span id="psi-x12int-max">0.000</span></small>
                </div>
                <div class="value-display">
                    <strong>Œ© Term:</strong> <span id="psi-omega-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>Potential Term:</strong> <span id="psi-potential-term">0.000</span>
                </div>
                <div class="value-display" style="border-left: 3px solid #00d4ff; font-weight: bold;">
                    <strong>Total œà:</strong> <span id="psi-total-normalized">0.000</span>
                </div>
            </div>

            <div class="card">
                <h2>üåå Dark Matter Parameters</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>œÅ‚ÇÄ: <span id="dm-rho0-display">1.0</span></label>
                        <input type="range" id="dm-rho0" min="0.1" max="10" value="1.0" step="0.1">
                </div>
                    <div class="control-group">
                        <label>r_s: <span id="dm-rs-display">5.0</span></label>
                        <input type="range" id="dm-rs" min="1" max="20" value="5.0" step="0.5">
                </div>
                </div>
            </div>

            <div class="card">
                <h2>üìâ NFW Density Profile</h2>
                <canvas id="dmProfileCanvas" width="400" height="120" style="width: 100%; height: 120px; border-radius: 10px; background: rgba(0, 0, 0, 0.3); margin-top: 10px;"></canvas>
            </div>

            <div class="card">
                <h2>üåê Global Entropy</h2>
                <div class="value-display">Entropy: <span id="entropy-global">0.000</span></div>
                <div class="value-display">Distribution: <span id="entropy-bins">[]</span></div>
                <div class="value-display">Temperature Proxy: <span id="entropy-temperature">0.000</span></div>
                <canvas id="entropyCanvas" width="400" height="100" style="width: 100%; height: 100px; border-radius: 10px; background: rgba(0, 0, 0, 0.3); margin-top: 10px;"></canvas>
            </div>
            
            <div class="card">
                <h2>üìà Entropy Trace</h2>
                <canvas id="entropyTraceCanvas" width="400" height="60" style="width: 100%; height: 60px; border-radius: 10px; background: rgba(0, 0, 0, 0.3); margin-top: 10px;"></canvas>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üéØ 12D State Function (œà)</h2>
                <div class="equation">
                    œà = œÜE/c¬≤ + Œª + ‚à´v¬∑dt + ‚à´Œîx‚ÇÅ‚ÇÇ¬∑dt + Œ©E + U‚ÇÅ‚ÇÅD
                </div>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">E/c¬≤</div>
                        <div class="stat-value" id="psi-energy">1.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">œÜ</div>
                        <div class="stat-value" id="psi-phi">1.618</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Œª</div>
                        <div class="stat-value" id="psi-lambda">0.905</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Œ©</div>
                        <div class="stat-value" id="psi-omega">12.45</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Total œà</div>
                        <div class="stat-value" id="psi-total">15.97</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üé´ Continuous Token Stream</h2>
                <p class="info-text">
                    <strong>LIVE GENERATION:</strong> Audio Frame Tokens ‚Ä¢ œÜ-Harmonic Tokens ‚Ä¢ Particle Tokens ‚Ä¢ Frequency Update Tokens<br>
                    <em>Each audio snapshot creates deterministic, blockchain-ready tokens</em>
                </p>
                <div class="token-display" id="tokenDisplay">
                    <div class="token-item">Waiting for audio input...</div>
                </div>
                <div class="value-display">
                    Total Tokens: <span id="token-count">0</span>
                </div>
                <div style="text-align: center; margin-top: 10px;">
                    <label style="margin-right: 10px;"><input type="checkbox" id="export-compact" checked> Compact export</label>
                    <button onclick="exportTokens()">üíæ Export Tokens (JSON)</button>
                    <button onclick="exportTokens({full:true})">üíæ Export Full JSON</button>
                    <button onclick="clearTokens()">üóëÔ∏è Clear Tokens</button>
                </div>
            </div>
        </div>

        <!-- NEW ENHANCED ANALYSIS PANELS -->
        <div class="grid">
            <div class="card" id="memoryStateDisplay">
                <h2>üß† Memory State Analysis</h2>
                <p class="info-text">Displaying memory vectors for highest-energy particles...</p>
            </div>

            <div class="card" id="energyBudgetDisplay">
                <h2>‚ö° Energy Budget Breakdown</h2>
                <p class="info-text">Real-time energy distribution analysis...</p>
            </div>
        </div>

        <div class="grid">
            <div class="card" id="synchronizationDisplay">
                <h2>üîÑ Synchronization Analysis</h2>
                <p class="info-text">Kuramoto order parameter and chimera state detection...</p>
            </div>

            <div class="card" id="emergenceDisplay">
                <h2>üåü Emergence Quantification</h2>
                <p class="info-text">Integrated information and hierarchical structure detection...</p>
            </div>
        </div>

        <div class="grid">
            <div class="card" id="observationalDisplay">
                <h2>üî≠ Observational Comparison</h2>
                <p class="info-text">Comparing CST predictions with Planck CMB data...</p>
            </div>

            <div class="card" id="parameterSweepPanel" style="display:none;">
                <h2>üìä Parameter Sweep Analysis</h2>
                <div>
                    <label>Parameter:</label>
                    <select id="sweepParam">
                        <option value="k">k (Coupling)</option>
                        <option value="gamma">Œ≥ (Decay)</option>
                        <option value="sigma">œÉ (Sigma)</option>
                    </select>
                </div>
                <div style="margin-top: 10px;">
                    <label>Min:</label>
                    <input type="number" id="sweepMin" value="0.001" step="0.001" style="width: 80px;">
                    <label>Max:</label>
                    <input type="number" id="sweepMax" value="1.0" step="0.001" style="width: 80px;">
                    <label>Steps:</label>
                    <input type="number" id="sweepSteps" value="10" min="2" max="50" style="width: 60px;">
                </div>
                <div style="margin-top: 10px;">
                    <label>Metric:</label>
                    <select id="sweepMetric">
                        <option value="totalEnergy">Total Energy</option>
                        <option value="totalEntropy">Total Entropy</option>
                        <option value="synapticStrength">Avg Synaptic Strength</option>
                        <option value="networkDensity">Network Density</option>
                    </select>
                </div>
                <button onclick="startParameterSweep()" style="margin-top: 10px;">Run Sweep</button>
                <div id="sweepResults" style="margin-top: 10px; font-size: 0.9em; max-height: 200px; overflow-y: auto;"></div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üéµ Phi-Harmonic Synthesis</h2>
                <p class="info-text">Generate golden-ratio harmonics from particle states</p>
                <button onclick="initializeAudioSynthesis(); if(phiSynthesizer) phiSynthesizer.generateMusicFromParticles(2.0);">üéπ Play Phi-Harmonic Music</button>
                <div style="margin-top: 10px;">
                    <label>Volume:</label>
                    <input type="range" id="synthVolume" min="0" max="1" value="0.3" step="0.05" onchange="if(phiSynthesizer) phiSynthesizer.setVolume(this.value);">
                    <span id="synthVolumeDisplay">30%</span>
                </div>
                <p class="info-text" style="margin-top: 10px; font-size: 0.85em;">
                    Frequencies generated using œÜ^(n/2) scaling with octave folding
                </p>
            </div>

            <div class="card">
                <h2>üß™ Advanced Controls</h2>
                <button onclick="document.getElementById('parameterSweepPanel').style.display='block';">üìä Parameter Sweep</button>
                <button onclick="if(learnedProjector) { learnedProjector.trainBatch(100, 5); alert('Neural network trained on 100 samples'); }">üß† Train Neural Network</button>
                <button onclick="console.log('Learned Projector:', learnedProjector); console.log('Energy Tracker:', energyTracker.history); alert('Analysis data logged to console');">üìã Export Analysis Data</button>
                <p class="info-text" style="margin-top: 10px; font-size: 0.85em;">
                    Advanced analysis and control systems
                </p>
            </div>
        </div>

        <!-- CST v2.0 COMPLETION: New Analysis Display Panels -->
        <div class="grid">
            <div class="card" id="stochasticResonanceDisplay">
                <h2>üåä Stochastic Resonance Analysis</h2>
                <p class="info-text">Signal-to-noise ratio optimization and resonance detection</p>
                <div class="value-display">
                    SNR: <span id="sr-snr">0.00</span>
                </div>
                <div class="value-display">
                    Optimal Noise: <span id="sr-noise">0.10</span>
                </div>
                <div class="value-display">
                    Enhancement: <span id="sr-enhancement">NO</span>
                </div>
                <button onclick="if(stochasticResonanceDetector) { const result = stochasticResonanceDetector.findOptimalNoise(); alert('Optimal noise: ' + result.optimalNoise.toFixed(3) + ', Max SNR: ' + result.maxSNR.toFixed(2)); }">
                    üîç Find Optimal Noise
                </button>
                <p class="info-text" style="margin-top: 10px; font-size: 0.85em;">
                    Detects stochastic resonance where noise enhances signal detection
                </p>
            </div>

            <div class="card" id="voicePersonalizationDisplay">
                <h2>üé§ AI Voice Bio-Frequency Personalization</h2>
                <p class="info-text">Adapts system parameters based on voice frequency analysis</p>
                <div class="value-display">
                    Detected Voice Frequency: <span id="voice-freq">--</span> Hz
                </div>
                <div class="value-display">
                    Emotional State: <span id="emotional-state">neutral</span>
                </div>
                <div class="value-display">
                    Personalized k: <span id="personalized-k">0.500</span>
                </div>
                <button onclick="if(voiceBioExtractor && analyser && dataArray) { const freq = voiceBioExtractor.extractFundamentalFrequency(analyser, dataArray); voiceBioExtractor.generatePersonalizedParams(freq); voiceBioExtractor.applyPersonalization(); document.getElementById('voice-freq').textContent = freq.toFixed(1); document.getElementById('emotional-state').textContent = voiceBioExtractor.emotionalState; document.getElementById('personalized-k').textContent = voiceBioExtractor.personalizedParams.k.toFixed(3); alert('Voice profile detected: ' + freq.toFixed(1) + ' Hz (' + voiceBioExtractor.emotionalState + ')'); }">
                    üéôÔ∏è Detect Voice Profile
                </button>
                <p class="info-text" style="margin-top: 10px; font-size: 0.85em;">
                    Analyzes fundamental frequency (F0) to classify emotional state and personalize parameters
                </p>
            </div>

            <div class="card" id="chaosRegimeDisplay">
                <h2>ü¶ã Enhanced Chaos Analysis</h2>
                <p class="info-text">Lyapunov exponent and attractor dimension tracking</p>
                <div class="value-display">
                    Lyapunov Exponent: <span id="lyapunov-value">0.000</span>
                </div>
                <div class="value-display">
                    Chaotic Regime: <span id="chaos-regime">UNKNOWN</span>
                </div>
                <div class="value-display">
                    Attractor Dimension: <span id="attractor-dimension">0.0</span>
                </div>
                <p class="info-text" style="margin-top: 10px; font-size: 0.85em;">
                    Œª > 1.0: chaotic, 0.1 < Œª ‚â§ 1.0: mixed, Œª ‚â§ 0.1: ordered
                </p>
            </div>
        </div>

        <!-- ‚ôæÔ∏è PERPETUAL OPERATION SYSTEM UI -->
        <div class="grid">
            <div class="card">
                <h2>‚ôæÔ∏è Perpetual System Status</h2>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">System Status</div>
                        <div class="stat-value" id="perpetual-status">ONLINE</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Particles</div>
                        <div class="stat-value"><span id="perpetual-particle-count">0</span> / <span id="perpetual-particle-max">50</span></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Total Energy</div>
                        <div class="stat-value" id="perpetual-total-energy">0</div>
                    </div>
                </div>
                <div class="value-display">
                    <strong>Healed Particles:</strong> <span id="perpetual-healed-count">0</span>
                </div>
                <div class="value-display">
                    <strong>Energy Injections:</strong> <span id="perpetual-energy-injections">0</span>
                </div>
                <div class="value-display">
                    <strong>Tokens Generated:</strong> <span id="perpetual-token-count">0</span>
                </div>
                <div class="value-display">
                    <strong>Audio Source:</strong> <span id="perpetual-audio-source">Synthetic</span>
                </div>
                <p class="info-text">System configured for infinite perpetual operation</p>
            </div>

            <div class="card">
                <h2>‚ôæÔ∏è Perpetual Operation Settings</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="perpetual-auto-regen" checked>
                            Auto-Regenerate Particles
                        </label>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="perpetual-energy-inject" checked>
                            Energy Injection (Anti Heat-Death)
                        </label>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="perpetual-self-heal" checked>
                            Self-Healing System
                        </label>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="perpetual-fallback-audio" checked>
                            Fallback Audio Generation
                        </label>
                    </div>
                    <div class="control-group">
                        <label>Min Particles: <span id="perpetual-min-display">5</span></label>
                        <input type="range" id="perpetual-min" min="1" max="20" value="5" step="1">
                    </div>
                    <div class="control-group">
                        <label>Max Particles: <span id="perpetual-max-display">50</span></label>
                        <input type="range" id="perpetual-max" min="10" max="100" value="50" step="5">
                    </div>
                    <div class="control-group">
                        <label>Energy Injection Rate: <span id="perpetual-inject-rate-display">0.001</span></label>
                        <input type="range" id="perpetual-inject-rate" min="0" max="0.01" value="0.001" step="0.0001">
                    </div>
                </div>
                <p class="info-text">Control perpetual operation parameters for infinite self-sustaining operation</p>
            </div>
        </div>

        <div class="alert-box">
            <strong>üî¨ System Status:</strong> <span id="system-status">Audio engine offline - Click START MICROPHONE to begin</span><br>
            <strong>üìä Particles:</strong> <span id="particle-count">0</span> active |
            <strong>üé´ Tokens:</strong> <span id="token-count-status">0</span> generated |
            <strong>üîÑ Replications:</strong> <span id="replication-count">0</span> |
            <strong>‚ö° Token Rate:</strong> <span id="token-rate">0.0</span> tokens/sec
        </div>
    </div>

    <!-- Three.js with fallback CDN to fix initialization errors -->
    <!-- Using jsdelivr as primary CDN (more reliable, not blocked by tracking prevention) -->
    <!-- Note: Three.js CDN may trigger tracking prevention in some browsers -->
    <!-- This is cosmetic and doesn't affect functionality - warnings can be safely ignored -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"
            onerror="this.onerror=null; this.src='https://unpkg.com/three@0.128.0/build/three.min.js';">
    </script>
    <script>
        // Added: Validate Three.js loaded before proceeding
        window.addEventListener('DOMContentLoaded', function() {
            if (typeof THREE === 'undefined') {
                console.error('[CST Runtime] ‚ùå Three.js failed to load from primary CDN');
                // Try loading from unpkg as final fallback
                const script = document.createElement('script');
                script.src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                script.onerror = function() {
                    console.error('[CST Runtime] ‚ùå All Three.js CDN sources failed');
                    alert('Failed to load Three.js library. The 3D visualization will not work.');
                };
                document.head.appendChild(script);
            } else {
                console.log('[CST Runtime] ‚úÖ Three.js loaded successfully:', THREE.REVISION);
            }
        });
    </script>
    <script>
        /*
         * ============================================================================
         * 12D COSMIC SYNAPSE THEORY - CONTINUOUS TOKEN GENERATION ENGINE v2.0
         * ============================================================================
         * 
         * UPGRADED FEATURES (v2.0):
         * 
         * 1. 11D-TO-3D PROJECTION: Each particle maintains 11D position/velocity projection
         * 2. GRAVITATIONAL SUBSTRATE: Softened Newtonian forces with optional dark matter (NFW profile)
         * 3. ADAPTIVE STATE x12: Per-particle 12th dimension with ODE evolution and memory m12
         * 4. SYNAPTIC STRENGTH Œ©: Gravitational coupling with Gaussian internal-state similarity
         * 5. CHARACTERISTIC FREQUENCY vi: Derived from cosmic energy (Ec/h) with phase synchronization
         * 6. KURAMOTO SYNCHRONIZATION: Phase coupling between particles with order parameter tracking
         * 7. ENTROPY: Coarse-grained Boltzmann-style entropy via speed histogram
         * 8. CONSERVATION DIAGNOSTICS: Energy, momentum, angular momentum tracking with virial checks
         * 9. SPATIAL INDEXING: Uniform grid for efficient neighbor queries (O(N) instead of O(N¬≤))
         * 10. ADAPTIVE TIMESTEP: Dynamic dt based on minimum distance and maximum velocity
         * 11. DETERMINISTIC REPLAY: Record audio frames and replay with fixed seed for reproducibility
         * 12. NORMALIZED œà: Dimensionless breakdown with reference scales (m0, Eref, tref, vref)
         * 
         * PIPELINE FLOW:
         * 1. AUDIO INPUT: Microphone captures live environmental sound (44.1kHz)
         * 2. FFT ANALYSIS: Fast Fourier Transform extracts frequency spectrum
         * 3. FREQUENCY EXTRACTION: Top 10 frequencies identified with magnitudes
         * 4. œÜ-HARMONIC GENERATION: Golden ratio (1.618...) creates harmonic series
         * 5. SOUND‚ÜíCOLOR MAPPING: Frequency (0-20kHz) mapped to Hue (0-360¬∞)
         * 6. SEED GENERATION: Deterministic seeds from frequency√ómagnitude combinations
         * 7. TOKEN CREATION: Every 100ms generates:
         *    - Audio Frame Tokens (complete spectrum snapshot)
         *    - œÜ-Harmonic Tokens (each harmonic in the series)
         *    - Particle Creation Tokens (new visual entities with x12, Ec, Œ©, vi, Œ∏, etc.)
         *    - Frequency Update Tokens (existing particle updates)
         * 8. œà CALCULATION: Normalized 12D state function: 
         *    œà = œÜ¬∑(Ec/Eref) + Œª + ‚à´||v|| dt/vref + ‚à´|Œîx12| dt + Œ©¬∑(Ec/Eref) + (Ugrav+Udm)/Eref
         * 9. PHYSICS INTEGRATION: Blended Lorenz + gravitational dynamics with adaptive states
         * 10. VISUAL RENDERING: Particles rendered in 3D with blended dynamics
         * 11. BLOCKCHAIN EXPORT: All tokens exportable as JSON for permanent record
         * 
         * CONTINUOUS: Token generation runs constantly while audio is active
         * DETERMINISTIC: Same audio input always produces identical tokens (replay mode)
         * 
         * REPLAY MODE USAGE:
         * 1. Click "Start Recording" to capture audio frames
         * 2. Set a deterministic seed (optional, defaults to 12345)
         * 3. Click "Replay" to feed recorded frames instead of live audio
         * 4. All tokens and œà values will be identical for the same recording
         * 
         * DEFAULT SETTINGS (tuned for stability):
         * - gravEnabled: false, dmEnabled: false, blendLorenz: 0.7
         * - adaptive timestep: true, k=0.5, Œ≥=0.2, Œ±=0.3, œÉ=0.3, Ksync=0.1
         * 
         * ============================================================================
         * 
         * CST v2.0 RESTORATION NOTES (Additive Updates):
         * 
         * RESTORED FUNCTIONALITY:
         * 1. Continuous Token Generation: Enhanced with rolling window rate calculation (2-second window)
         *    - Tokens generate every 100ms from live audio or replay
         *    - Token rate displayed in real-time with smooth updates every 500ms
         *    - Token display bounded to last 200 items for performance
         * 
         * 2. Deterministic Record/Replay: Enhanced with deep copying and seed management
         *    - Complete audio frame data recorded (RMS, frequencies, harmonics, raw FFT)
         *    - Replay resets token arrays and counters for clean deterministic output
         *    - Same seed + recording produces identical tokens and Œ® values
         *    - Deep copy prevents mutation issues during replay
         * 
         * 3. Adaptive Timestep: Already implemented, verified working
         *    - Dynamic dt based on min distance and max velocity
         *    - Clamped to [0.001, dtMax] for stability
         *    - Respects adaptive-dt checkbox control
         * 
         * 4. Real-time Diagnostics: All metrics update continuously
         *    - Œ® breakdown: energy, Œª, ‚à´||v||dt, ‚à´|Œîx12|dt, Œ©¬∑E, potential terms
         *    - Synchronization: Kuramoto order parameter r and mean Œ∏
         *    - Conservation: Energy, momentum, angular momentum, virial ratio
         *    - Chaos: Lyapunov exponent and audio chaos measure
         * 
         * 5. Controls: All sliders/checkboxes wired and functional
         *    - Physics: blend-lorenz, grav-enabled, dm-enabled, rcutoff, epsilon
         *    - Adaptive state: k, gamma, alpha, sigma-sim
         *    - Synchronization: ksync
         *    - Timestep: dtmax, adaptive-dt checkbox
         * 
         * WHERE TO FIND IN UI:
         * - Token Rate: Alert box (bottom) and token display header
         * - Recording Status: "Determinism & Replay" card
         * - Seed Control: "Determinism & Replay" card
         * - All Diagnostics: "Conservation Diagnostics", "Synchronization Metrics", "œà Normalized Breakdown" cards
         * - Controls: "Physics Controls", "Adaptive State Controls", "Synchronization & Timestep" cards
         * 
         * ============================================================================
         * 
         * CST v2.0+ ENHANCEMENTS (Latest Additive Updates):
         * 
         * 1. Enhanced Export Schema:
         *    - Full particle snapshots with 11D projection data (pos11D[], vel11D[])
         *    - Reference scales (m0, Eref, tref, vref) for dimensionless œà normalization
         *    - Recorded frames array with complete FFT data
         *    - Replay integrity hash for deterministic verification
         *    - Dark matter parameters included in metadata
         * 
         * 2. Deterministic Replay Integrity:
         *    - Reset œà accumulators (velocityIntegral, x12Integral) on replay
         *    - Reset conservation stats (E0, P0, L0) for clean replay
         *    - All randomness funneled through getRandom() for determinism
         *    - Fixed Math.random() leaks in createParticleFromFrequency()
         * 
         * 3. Adaptive Timestep Precision:
         *    - Clamping corrected to [0.001, dtMax] per specification
         *    - Proper handling of edge cases (rMin=Infinity, vMax=0)
         * 
         * 4. 11D Projection Documentation:
         *    - Added hooks for alternative projection maps (orthogonal, random embedding, learned)
         *    - Maintained Float64Array precision for numerical stability
         *    - Projection data included in all particle tokens
         * 
         * 5. Token Generation Cadence:
         *    - Fixed recursive setTimeout ‚Üí setInterval for exact 100ms timing (no drift)
         *    - Clean interval management with audioProcessingInterval tracking
         *    - Token rate calculation with 2-second rolling window
         * 
         * VERIFICATION CHECKLIST:
         * ‚úì Continuous audio‚Üítoken pipeline (100ms cadence)
         * ‚úì 11D‚Üí3D projection continuity (updated each frame)
         * ‚úì Adaptive state x12 with memory m12
         * ‚úì Gravitational substrate with dark matter (NFW-like)
         * ‚úì Kuramoto synchronization with order parameter r
         * ‚úì Entropy metrics (coarse-grained Boltzmann-style)
         * ‚úì Adaptive timestep (clamped to [0.001, dtMax])
         * ‚úì Deterministic replay (identical tokens with same seed)
         * ‚úì œà normalized breakdown (all terms tracked)
         * ‚úì Spatial indexing (O(N) neighbor queries)
         * ‚úì Export schema (complete with 11D data and integrity hash)
         * ‚úì UI wiring (all controls functional and live-bound)
         *
         * IMPLEMENTATION COMPLETENESS VERIFICATION (2025-11-09):
         * ============================================================================
         * ALL REQUESTED FEATURES FULLY IMPLEMENTED AND VERIFIED:
         *
         * 1. ‚úÖ Pause/Play Button: togglePause() at line 3752, button at line 453
         * 2. ‚úÖ Replay Functions: startReplay() (1960), stopReplay() (1997),
         *    stepReplayFrame() (2008), applyDeterministicInit() (2030)
         * 3. ‚úÖ Replay Validation Panel: updateReplayValidation() at line 2578,
         *    called every frame at line 3719, IDs: replay-edrift, replay-pmag,
         *    replay-lmag, replay-virial
         * 4. ‚úÖ Adaptive State Trace: initAdaptiveStateCanvas() (2152),
         *    updateAdaptiveStateTrace() (2479), called at line 3654
         * 5. ‚úÖ Projection Mode Selector: Event listener at 4151-4169, updates
         *    projectionConfig.mode, projection-status, and reprojects particles
         * 6. ‚úÖ NFW Profile: initDmProfileCanvas() (2168), drawNfwProfile() (2530),
         *    initialized at 4669, draws NFW density curve
         * 7. ‚úÖ Entropy Trace: initEntropyCanvas() (2099), computeEntropyMetrics() (2258),
         *    updateEntropy() (2302), drawEntropyTrace() (2359), drawEntropyHistogram() (2448),
         *    called at lines 3627 and 3646
         * 8. ‚úÖ Token Hygiene: All tokens.push() use objects only (verified lines 1327,
         *    2685, 2962, 3104, 3427)
         * 9. ‚úÖ Bug Fixes: LorenzParticle.update() uses timestep.dt (1190-1192),
         *    conservationStats.lastUpdate advanced (1651)
         *
         * All canvas initializations called at DOM ready (lines 4667-4669).
         * All update functions wired into animation loop.
         * Full deterministic replay with conservation diagnostic validation.
         *
         * ============================================================================
         *
         * CST v2.0++ CRITICAL FIXES (2025-11-09):
         * ============================================================================
         *
         * FIXED: Adaptive State Evolution Equation (Section 2.9)
         * - Line 1543: Corrected dx12/dt = k¬∑Œ© - Œ≥¬∑x12 (was incorrectly k¬∑(Œ© - Œ≥¬∑x12))
         * - Now precisely matches Paper Section 2.9 specification
         * - Memory equation dm12/dt = Œ±¬∑(x12 - m12) was already correct (Section 2.10)
         *
         * ENHANCED: Paper Section References
         * - Added explicit paper section references to all key equations:
         *   ‚Ä¢ Section 2.7: NFW Dark Matter Profile (line 1498-1500)
         *   ‚Ä¢ Section 2.9: Internal State Evolution dx12/dt (line 1543)
         *   ‚Ä¢ Section 2.10: Memory Update dm12/dt (line 1550)
         *   ‚Ä¢ Section 2.11: Synaptic Strength with Similarity (line 1524-1535)
         *   ‚Ä¢ Section 2.6: Characteristic Frequency ŒΩ·µ¢ = Ec/h (line 1562)
         *   ‚Ä¢ Kuramoto Phase Coupling dŒ∏/dt (line 1577)
         *
         * VERIFICATION: All Features Fully Implemented
         * ‚úÖ Adaptive State Dynamics with correct equations
         * ‚úÖ Global Entropy Panel with heart-rate trace
         * ‚úÖ Full œà Function Breakdown (6 normalized terms)
         * ‚úÖ Replay & Determinism with validation diagnostics
         * ‚úÖ Dark Matter NFW Profile integration
         * ‚úÖ Kuramoto Synchronization Metrics
         * ‚úÖ Continuous Token Stream with JSON export
         * ‚úÖ Conservation checks (Energy, Momentum, Angular Momentum, Virial)
         *
         * ============================================================================
         */
        
        // Constants
        const c = 299792458; // Speed of light
        const phi = (1 + Math.sqrt(5)) / 2;
        const h = 6.62607015e-34; // Planck's constant
        const kB = 1.380649e-23; // Boltzmann constant

        // ============================================================================
        // UNIVERSAL NaN PREVENTION SYSTEM
        // ============================================================================

        /**
         * Safe division with fallback - NEVER returns NaN
         * @param {number} numerator
         * @param {number} denominator
         * @param {number} fallback - Default value if division fails
         * @returns {number} Safe division result or fallback
         */
        function safeDivide(numerator, denominator, fallback = 0) {
            if (!isFinite(numerator) || !isFinite(denominator)) return fallback;
            if (denominator === 0) return fallback;
            const result = numerator / denominator;
            return isFinite(result) ? result : fallback;
        }

        /**
         * Safe square root - NEVER returns NaN
         * @param {number} value
         * @param {number} fallback
         * @returns {number}
         */
        function safeSqrt(value, fallback = 0) {
            if (!isFinite(value) || value < 0) return fallback;
            const result = Math.sqrt(value);
            return isFinite(result) ? result : fallback;
        }

        /**
         * Safe logarithm - NEVER returns NaN
         * @param {number} value
         * @param {number} fallback
         * @returns {number}
         */
        function safeLog(value, fallback = 0) {
            if (!isFinite(value) || value <= 0) return fallback;
            const result = Math.log(value);
            return isFinite(result) ? result : fallback;
        }

        /**
         * Safe exponential - NEVER returns NaN or Infinity
         * @param {number} value
         * @param {number} fallback
         * @param {number} maxValue - Cap to prevent Infinity
         * @returns {number}
         */
        function safeExp(value, fallback = 1, maxValue = 1e10) {
            if (!isFinite(value)) return fallback;
            if (value > 100) return maxValue; // Prevent overflow
            if (value < -100) return 1e-10; // Prevent underflow
            const result = Math.exp(value);
            return isFinite(result) ? Math.min(result, maxValue) : fallback;
        }

        /**
         * Safe array average - NEVER returns NaN
         * @param {Array} arr
         * @param {number} fallback
         * @returns {number}
         */
        function safeAverage(arr, fallback = 0) {
            if (!arr || arr.length === 0) return fallback;
            const validValues = arr.filter(v => isFinite(v));
            if (validValues.length === 0) return fallback;
            const sum = validValues.reduce((a, b) => a + b, 0);
            return sum / validValues.length;
        }

        /**
         * Safe value clamping with validation
         * @param {number} value
         * @param {number} min
         * @param {number} max
         * @param {number} fallback
         * @returns {number}
         */
        function safeClamp(value, min, max, fallback = 0) {
            if (!isFinite(value)) return fallback;
            if (!isFinite(min) || !isFinite(max)) return fallback;
            return Math.max(min, Math.min(max, value));
        }

        /**
         * Validate and sanitize particle state - removes ALL NaN/Infinity
         * @param {Object} particle
         */
        function sanitizeParticleState(particle) {
            // Positions
            particle.x = isFinite(particle.x) ? particle.x : 0.1;
            particle.y = isFinite(particle.y) ? particle.y : 0;
            particle.z = isFinite(particle.z) ? particle.z : 0;

            // Velocities
            particle.velocity.x = isFinite(particle.velocity.x) ? particle.velocity.x : 0;
            particle.velocity.y = isFinite(particle.velocity.y) ? particle.velocity.y : 0;
            particle.velocity.z = isFinite(particle.velocity.z) ? particle.velocity.z : 0;

            // 12D states
            particle.x12 = safeClamp(particle.x12, -1, 1, 0);
            particle.m12 = safeClamp(particle.m12, -1, 1, 0);
            particle.dx12_dt = isFinite(particle.dx12_dt) ? particle.dx12_dt : 0;
            particle.dm12_dt = isFinite(particle.dm12_dt) ? particle.dm12_dt : 0;

            // Energy values (must be positive)
            particle.Ec = isFinite(particle.Ec) && particle.Ec > 0 ? particle.Ec : 0.01;
            particle.energy = isFinite(particle.energy) && particle.energy > 0 ? particle.energy : 0.01;
            particle.Ugrav = isFinite(particle.Ugrav) ? particle.Ugrav : 0;
            particle.Udm = isFinite(particle.Udm) ? particle.Udm : 0;

            // Synaptic strength
            particle.omega = isFinite(particle.omega) && particle.omega >= 0 ? particle.omega : 0;

            // Mass (must be positive)
            particle.mass = isFinite(particle.mass) && particle.mass > 0 ? particle.mass : 1;

            // Frequency
            particle.frequency = isFinite(particle.frequency) && particle.frequency > 0 ? particle.frequency : 440;

            // Parameters
            particle.k_adaptation = isFinite(particle.k_adaptation) && particle.k_adaptation > 0 ? particle.k_adaptation : 0.01;
            particle.gamma_decay = isFinite(particle.gamma_decay) && particle.gamma_decay > 0 ? particle.gamma_decay : 0.005;
            particle.alpha_memory = isFinite(particle.alpha_memory) && particle.alpha_memory > 0 ? particle.alpha_memory : 0.1;
            particle.sigma_similarity = isFinite(particle.sigma_similarity) && particle.sigma_similarity > 0 ? particle.sigma_similarity : 1.0;

            // Accumulators
            particle.total_x12_variation = isFinite(particle.total_x12_variation) && particle.total_x12_variation >= 0 ? particle.total_x12_variation : 0;
            particle.total_velocity_integral = isFinite(particle.total_velocity_integral) && particle.total_velocity_integral >= 0 ? particle.total_velocity_integral : 0;

            // Psi
            particle.psi = isFinite(particle.psi) ? particle.psi : 0;
        }

        console.log('[PERPETUAL] ‚úÖ NaN Prevention System initialized');

        // Audio variables
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let dataArray = null;
        let bufferLength = 0;
        let isAudioActive = false;
        let audioProcessingInterval = null; // CST v2.0+: Interval ID for configurable cadence
        let frequencyData = [];
        let audioEnergy = 0;
        let spectralCentroid = 0;
        let tokenCount = 0;
        let tokens = [];
        let replicationThreshold = 50; // Energy threshold for particle replication
        let replicationCount = 0;
        let tokenGenerationRate = 0;
        let lastTokenCount = 0;
        let lastTokenTime = Date.now();
        let lastTokenRateTime = Date.now();
        
        // CST v2.0+ additive: Configurable cadence and FFT settings
        const audioConfig = {
            cadence: 100, // Token generation cadence in ms (1-100)
            fftSize: 2048, // FFT size (256, 512, 1024, 2048, 4096, 8192)
            tokenDisplayLimit: 200 // Maximum tokens to display in UI
        };
        
        // CST v2.0+ additive: Token buffering for batched UI updates
        const tokenBuffer = {
            tokens: [], // Buffer of tokens waiting to be flushed to UI
            flushInterval: null, // Interval ID for UI flush (~20Hz = 50ms)
            flushRate: 50 // UI update rate in ms (~20Hz)
        };

        // Onset detection state
        let lastSpectrumForOnset = null;
        const onsetConfig = {
            enabled: true,
            threshold: 0.5, // Spectral flux threshold for onset detection
            cooldown: 200, // Milliseconds between onset-triggered particle creation
            lastOnsetTime: 0
        };

        function detectOnset(currentMagnitudes) {
            if (!lastSpectrumForOnset) {
                lastSpectrumForOnset = currentMagnitudes.slice();
                return false;
            }

            // Calculate spectral flux (positive changes in magnitude)
            let flux = 0;
            const minLength = Math.min(currentMagnitudes.length, lastSpectrumForOnset.length);
            for (let i = 0; i < minLength; i++) {
                const diff = currentMagnitudes[i] - lastSpectrumForOnset[i];
                if (diff > 0) {
                    flux += diff;
                }
            }

            lastSpectrumForOnset = currentMagnitudes.slice();

            // Check cooldown
            const now = Date.now();
            if (now - onsetConfig.lastOnsetTime < onsetConfig.cooldown) {
                return false;
            }

            // Detect onset
            if (flux > onsetConfig.threshold) {
                onsetConfig.lastOnsetTime = now;
                return true;
            }

            return false;
        }

        console.log('[CST Onset Detection] ‚úÖ Onset detection system initialized');

        // CST v2.0+ additive: Token rate update interval for smooth UI updates
        let tokenRateUpdateInterval = null;
        
        // CST v2.0+ additive: Deterministic ID generation for replay
        let deterministicIdCounter = 0;
        function nextDeterministicId() {
            if (determinism.mode === 'replay') {
                deterministicIdCounter++;
                return `replay-${determinism.seed || 0}-${deterministicIdCounter}`;
            }
            return generateUUID();
        }
        
        // CST v2.0 additive: Rolling window for token rate calculation
        const tokenRateWindow = {
            timestamps: [], // Array of timestamps when tokens were generated
            windowSize: 2000, // 2 second window in milliseconds
            maxEntries: 1000 // Maximum entries to keep
        };

        // ============================================================================
        // 12D CST GLOBAL SIMULATION STATE
        // ============================================================================
        const physics = {
            G: 6.67430e-11, // Gravitational constant (m¬≥/kg/s¬≤)
            a0: 1.0, // Reference acceleration scale
            m0: 1.0, // Reference mass scale
            Eref: 1.0, // Reference energy scale
            tref: 1.0, // Reference time scale
            vref: 1.0, // Reference velocity scale
            epsilon: 0.1, // Softening parameter for gravity
            rCutoff: 10.0, // Cutoff radius for neighbor search
            blendLorenz: 0.7, // Blend factor: 0=gravity only, 1=Lorenz only
            gravEnabled: false, // Enable gravitational forces
            dmEnabled: false // Enable dark matter
        };

        const adapt = {
            k: 0.5, // Adaptive state coupling strength
            gamma: 0.2, // Adaptive state decay
            alpha: 0.3, // Memory update rate
            sigmaSimilarity: 0.3 // Gaussian width for similarity in Œ©
        };

        const sync = {
            Ksync: 0.1 // Kuramoto coupling strength
        };

        const timestep = {
            dt: 0.005, // Current timestep
            dtMax: 0.01, // Maximum timestep
            adaptive: true // Use adaptive timestep
        };

        const determinism = {
            mode: 'live', // 'live' or 'replay'
            seed: null, // Deterministic seed for replay
            recordedAudioFrames: [], // Recorded audio frames for replay
            isRecording: false, // Currently recording
            replayIndex: 0, // Current frame index in replay mode
            replayInterval: null // Interval ID for replay processing
        };
        
        // Accumulators for œà integrals
        const psiAccumulators = {
            velocityIntegral: new Map(), // ‚à´||v|| dt per particle
            x12Integral: new Map(), // ‚à´|Œîx12| dt per particle
            x12Previous: new Map() // Previous x12 value per particle for computing Œîx12
        };

        // Conservation tracking
        let conservationStats = {
            E0: 0, // Initial total energy
            P0: { x: 0, y: 0, z: 0 }, // Initial total momentum
            L0: { x: 0, y: 0, z: 0 }, // Initial total angular momentum
            lastUpdate: Date.now()
        };
        
        // Dark matter parameters
        const dmParams = {
            rho0: 1.0, // Central density
            rs: 5.0 // Scale radius
        };

        // ============================================================================
        // NEURAL NETWORK ADAPTER FOR PARTICLE ENERGY LEARNING
        // Implements adaptive energy modulation based on network state
        // ============================================================================

        class NeuralNetworkAdapter {
            constructor(inputSize, hiddenSize, outputSize) {
                this.inputSize = inputSize;
                this.hiddenSize = hiddenSize;
                this.outputSize = outputSize;
                this.learningRate = 0.001;

                // Initialize weights with small random values
                this.weightsInputHidden = Array.from({ length: inputSize }, () =>
                    Array.from({ length: hiddenSize }, () => (Math.random() - 0.5) * 0.1)
                );
                this.weightsHiddenOutput = Array.from({ length: hiddenSize }, () =>
                    Array.from({ length: outputSize }, () => (Math.random() - 0.5) * 0.1)
                );
                this.biasHidden = Array.from({ length: hiddenSize }, () => 0);
                this.biasOutput = Array.from({ length: outputSize }, () => 0);

                // Store last values for backprop
                this.lastInput = null;
                this.lastHidden = null;
                this.lastOutput = null;
            }

            forward(input) {
                this.lastInput = input;

                // Input to hidden layer
                const hidden = this.weightsInputHidden[0].map((_, h) => {
                    let sum = this.biasHidden[h];
                    for (let i = 0; i < this.inputSize; i++) {
                        sum += input[i] * this.weightsInputHidden[i][h];
                    }
                    return Math.max(0, sum); // ReLU activation
                });
                this.lastHidden = hidden;

                // Hidden to output layer
                const output = this.weightsHiddenOutput[0].map((_, o) => {
                    let sum = this.biasOutput[o];
                    for (let h = 0; h < this.hiddenSize; h++) {
                        sum += hidden[h] * this.weightsHiddenOutput[h][o];
                    }
                    return Math.tanh(sum); // Tanh activation for bounded output
                });
                this.lastOutput = output;

                return output;
            }

            backward(target) {
                if (!this.lastInput || !this.lastHidden || !this.lastOutput) return;

                // Compute output layer gradients
                const outputGradients = this.lastOutput.map((o, i) => {
                    const error = target[i] - o;
                    return error * (1 - o * o); // Tanh derivative
                });

                // Update hidden-to-output weights
                for (let h = 0; h < this.hiddenSize; h++) {
                    for (let o = 0; o < this.outputSize; o++) {
                        const gradient = outputGradients[o] * this.lastHidden[h];
                        this.weightsHiddenOutput[h][o] += this.learningRate * gradient;
                    }
                }
                for (let o = 0; o < this.outputSize; o++) {
                    this.biasOutput[o] += this.learningRate * outputGradients[o];
                }

                // Compute hidden layer gradients
                const hiddenGradients = this.lastHidden.map((h, i) => {
                    let error = 0;
                    for (let o = 0; o < this.outputSize; o++) {
                        error += outputGradients[o] * this.weightsHiddenOutput[i][o];
                    }
                    return h > 0 ? error : 0; // ReLU derivative
                });

                // Update input-to-hidden weights
                for (let i = 0; i < this.inputSize; i++) {
                    for (let h = 0; h < this.hiddenSize; h++) {
                        const gradient = hiddenGradients[h] * this.lastInput[i];
                        this.weightsInputHidden[i][h] += this.learningRate * gradient;
                    }
                }
                for (let h = 0; h < this.hiddenSize; h++) {
                    this.biasHidden[h] += this.learningRate * hiddenGradients[h];
                }
            }
        }

        // Create global neural network adapter instance
        const neuralAdapter = new NeuralNetworkAdapter(15, 64, 2);
        const neuralConfig = {
            enabled: true,
            sensitivity: 0.1,
            learningRate: 0.001
        };

        console.log('[CST Neural Network] ‚úÖ Neural network adapter initialized (15‚Üí64‚Üí2)');

        // ============================================================================
        // MEMORY LEARNING SYSTEM
        // Particles learn from their neighbors' states and update internal memory
        // ============================================================================

        function updateMemoryFromNeighbors(particle, allParticles, topFrequencies) {
            if (!particle.neighbors || particle.neighbors.length === 0) return;

            // Gather neighbor states
            const neighborStates = particle.neighbors.map(j => {
                const neighbor = allParticles[j];
                return {
                    x12: neighbor.x12,
                    m12: neighbor.m12,
                    Ec: neighbor.Ec,
                    frequency: neighbor.frequency
                };
            });

            // Compute average neighbor states
            const avgX12 = neighborStates.reduce((sum, n) => sum + n.x12, 0) / neighborStates.length;
            const avgM12 = neighborStates.reduce((sum, n) => sum + n.m12, 0) / neighborStates.length;
            const avgEc = neighborStates.reduce((sum, n) => sum + n.Ec, 0) / neighborStates.length;

            // Update particle memory based on neighbors (Hebbian learning)
            // Memory slots 0-4: Top frequency magnitudes
            // Memory slots 5-9: Learned neighbor patterns

            // Shift old memory
            for (let i = 9; i > 4; i--) {
                particle.memory[i] = particle.memory[i - 1];
            }

            // Insert new learned patterns
            particle.memory[5] = avgX12;
            particle.memory[6] = avgM12;
            particle.memory[7] = avgEc / 100; // Normalized
            particle.memory[8] = (particle.x12 - avgX12); // State difference
            particle.memory[9] = particle.omega / 10; // Normalized synaptic strength

            // Update top frequency memory (slots 0-4)
            const safeTopFreqs = (topFrequencies || []).slice(0, 5);
            for (let i = 0; i < 5; i++) {
                if (i < safeTopFreqs.length && safeTopFreqs[i]) {
                    particle.memory[i] = safeTopFreqs[i].magnitude || 0;
                }
            }
        }

        console.log('[CST Memory Learning] ‚úÖ Memory update function defined');

        // ============================================================================
        // TOKEN AUTO-SAVE SYSTEM
        // Automatically saves tokens to localStorage every 60 seconds
        // ============================================================================

        const tokenPersistence = {
            enabled: true,
            storageKey: 'cst_tokens_autosave',
            lastSaveTime: 0
        };

        function saveTokensToStorage() {
            if (!tokenPersistence.enabled || tokens.length === 0) return;

            try {
                // Store tokens with metadata
                const saveData = {
                    tokens: tokens,
                    timestamp: Date.now(),
                    particleCount: particles.length,
                    version: '12D-CST-v2.0'
                };

                localStorage.setItem(tokenPersistence.storageKey, JSON.stringify(saveData));
                tokenPersistence.lastSaveTime = Date.now();
            } catch (e) {
                console.error('[Token Persistence] Failed to save tokens:', e);
            }
        }

        function loadTokensFromStorage() {
            if (!tokenPersistence.enabled) return;

            try {
                const savedData = localStorage.getItem(tokenPersistence.storageKey);
                if (savedData) {
                    const parsed = JSON.parse(savedData);
                    console.log(`[Token Persistence] Loaded ${parsed.tokens.length} tokens from ${new Date(parsed.timestamp).toLocaleString()}`);
                    return parsed.tokens;
                }
            } catch (e) {
                console.error('[Token Persistence] Failed to load tokens:', e);
            }
            return null;
        }

        // Auto-save tokens every 60 seconds
        let autoSaveInterval = null;

        function startTokenAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
            }
            autoSaveInterval = setInterval(() => {
                if (tokenPersistence.enabled && tokens.length > 0) {
                    saveTokensToStorage();
                    console.log('[Token Persistence] Auto-saved', tokens.length, 'tokens');
                }
            }, 60000); // Every 60 seconds
        }

        function stopTokenAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
            }
        }

        function enableTokenPersistence(enable) {
            tokenPersistence.enabled = enable;
            if (enable) {
                startTokenAutoSave();
                console.log('[Token Persistence] ‚úÖ Auto-save enabled (60s interval)');
            } else {
                stopTokenAutoSave();
                console.log('[Token Persistence] ‚è∏Ô∏è  Auto-save disabled');
            }
        }

        // Start auto-save by default if persistence is enabled
        if (tokenPersistence.enabled) {
            startTokenAutoSave();
        }

        console.log('[Token Persistence] ‚úÖ Token auto-save system initialized');

        // CST v2.0+ additive: Projection mode configuration
        const projectionConfig = {
            mode: 'orthogonal',
            randomSeed: 1337,
            randomR: null, // Random projection matrix (11x3)
            learnedWeights: null // Learned embedding weights (placeholder)
        };

        // CST v2.0+ additive: Global entropy state
        const entropyState = {
            bins: 32,
            histogram: new Array(32).fill(0),
            lastEntropy: 0,
            tempProxy: 0,
            ctx: null,
            traceCtx: null // CST v2.0+ additive: Context for entropy trace canvas
        };
        
        // --- NEW: adaptive state canvas init ---
        let adaptiveStateCtx = null;
        let x12History = []; // array of arrays: per-particle x12 trace
        
        // --- NEW: dark matter profile plot ---
        let dmProfileCtx = null;
        
        // CST v2.0+ additive: Rolling buffer for entropy trace
        const entropyTrace = [];
        
        // --- NEW: entropy trace smoothing ---
        const entropyTraceConfig = {
            emaAlpha: 0.3 // exponential moving average smoothing factor
        };
        let entropyEma = null;
        
        function getSmoothedEntropy(current) {
            if (entropyEma === null || !isFinite(entropyEma)) {
                entropyEma = current;
                return current;
            }
            entropyEma = entropyTraceConfig.emaAlpha * current + (1 - entropyTraceConfig.emaAlpha) * entropyEma;
            return entropyEma;
        }

        // UUID generator (deterministic in replay mode)
        function generateUUID() {
            if (determinism.mode === 'replay' && determinism.seed !== null) {
                // Use deterministic pseudo-random for replay
                determinism.seed = (determinism.seed * 1103515245 + 12345) & 0x7fffffff;
                const r = determinism.seed % 16;
                const v = r & 0x3 | 0x8;
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const val = c === 'x' ? r : v;
                    return val.toString(16);
                });
            }
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // Deterministic random for replay mode
        let deterministicRandom = null;
        function getRandom() {
            if (determinism.mode === 'replay' && determinism.seed !== null) {
                if (!deterministicRandom) {
                    deterministicRandom = determinism.seed;
                }
                deterministicRandom = (deterministicRandom * 1103515245 + 12345) & 0x7fffffff;
                return (deterministicRandom / 0x7fffffff);
            }
            return Math.random();
        }
        
        // CST v2.0 additive: Enhanced deterministic seed setting
        function setDeterministicSeed(seed) {
            determinism.seed = seed;
            deterministicRandom = seed;
            projectionConfig.randomR = null; // force regen for random embedding
            updateStatus(`Seed set to ${seed}`);
        }

        // Three.js setup
        let scene, camera, renderer;
        let particles = [];
        let isPaused = false;
        let colorHue = 180;
        let frameCount = 0;
        let lastTime = performance.now();

        // Lorenz parameters
        let sigma = 10;
        let rho = 28;
        let beta = 2.667;
        let audioSensitivity = 1.0;
        // Note: dt is now managed by timestep.dt (see timestep object above)

        // Frequency canvas
        let freqCanvas, freqCtx;

        // ============================================================================
        // INFINITE PERPETUAL OPERATION SYSTEM
        // ============================================================================

        const PERPETUAL_CONFIG = {
            minParticles: 5,              // Never drop below this
            maxParticles: 50,             // Automatic cap
            autoRegenerate: true,         // Auto-create particles when low
            energyInjectionRate: 0.001,   // Continuous energy input (violates conservation for perpetual motion)
            minSystemEnergy: 100,         // Inject energy if total drops below
            autoReplicationEnabled: true, // Allow particles to self-replicate
            minOmegaForLife: 0.001,      // Minimum connectivity to stay alive
            tokenGenerationInterval: 100, // Generate tokens every 100ms
            fallbackAudioEnabled: true,   // Generate synthetic audio if no input
            selfHealingEnabled: true,     // Auto-fix broken states
            preventHeatDeath: true        // Continuously inject entropy
        };

        // Perpetual system counters
        let perpetualStats = {
            healedCount: 0,
            energyInjectionsCount: 0,
            generatedTokensCount: 0
        };

        /**
         * Auto-regenerate particles to maintain minimum count
         * Ensures the system NEVER runs out of particles
         */
        function autoRegenerateParticles() {
            if (!PERPETUAL_CONFIG.autoRegenerate) return;

            const deficit = PERPETUAL_CONFIG.minParticles - particles.length;
            if (deficit > 0) {
                console.log(`[PERPETUAL] Auto-regenerating ${deficit} particles to maintain minimum`);

                for (let i = 0; i < deficit; i++) {
                    // Create particle with random but valid initial state
                    const offset = Math.random() * 2;
                    const hue = Math.random() * 360;
                    const color = new THREE.Color();
                    color.setHSL(hue / 360, 1.0, 0.5);

                    const particle = new LorenzParticle(
                        0.1 + offset,
                        offset,
                        offset,
                        color.getHex(),
                        440 + Math.random() * 880 // Random frequency 440-1320 Hz
                    );

                    // Give it initial energy to kickstart
                    particle.Ec = 10 + Math.random() * 40;
                    particle.energy = particle.Ec;

                    // Random initial internal state
                    particle.x12 = (Math.random() * 2 - 1) * 0.5; // [-0.5, 0.5]
                    particle.m12 = particle.x12;

                    particles.push(particle);
                }

                updateStatus(`Auto-regenerated ${deficit} particles`);
            }

            // Also cap maximum to prevent infinite growth
            if (particles.length > PERPETUAL_CONFIG.maxParticles) {
                // Remove lowest energy particles
                particles.sort((a, b) => a.Ec - b.Ec);
                const toRemove = particles.length - PERPETUAL_CONFIG.maxParticles;
                for (let i = 0; i < toRemove; i++) {
                    const p = particles.shift();
                    if (p && p.destroy) p.destroy();
                }
                console.log(`[PERPETUAL] Removed ${toRemove} low-energy particles to maintain maximum`);
            }
        }

        /**
         * Inject energy into the system to prevent heat death
         * Violates energy conservation intentionally for perpetual operation
         */
        function injectSystemEnergy() {
            if (!PERPETUAL_CONFIG.preventHeatDeath || particles.length === 0) return;

            // Calculate total system energy
            const totalEnergy = particles.reduce((sum, p) => sum + (p.Ec || 0), 0);

            // Inject energy if below minimum
            if (totalEnergy < PERPETUAL_CONFIG.minSystemEnergy) {
                const injectionNeeded = PERPETUAL_CONFIG.minSystemEnergy - totalEnergy;
                const perParticle = injectionNeeded / particles.length;

                particles.forEach(p => {
                    p.Ec += perParticle;
                    p.energy += perParticle;
                });

                perpetualStats.energyInjectionsCount++;
                console.log(`[PERPETUAL] Injected ${injectionNeeded.toFixed(2)} energy to prevent heat death`);
            }

            // Continuous small energy injection to all particles
            particles.forEach(p => {
                p.Ec += PERPETUAL_CONFIG.energyInjectionRate;
                p.energy += PERPETUAL_CONFIG.energyInjectionRate;
            });
        }

        /**
         * Self-healing system - detect and fix broken particle states
         */
        function selfHealingCheck() {
            if (!PERPETUAL_CONFIG.selfHealingEnabled || particles.length === 0) return;

            let healedCount = 0;

            particles.forEach(particle => {
                let wasHealed = false;

                // Check for NaN/Infinity in critical values
                const criticalChecks = [
                    particle.x, particle.y, particle.z,
                    particle.velocity.x, particle.velocity.y, particle.velocity.z,
                    particle.x12, particle.m12, particle.Ec, particle.omega
                ];

                const hasBadValues = criticalChecks.some(v => !isFinite(v));

                if (hasBadValues) {
                    sanitizeParticleState(particle);
                    wasHealed = true;
                }

                // Check for stuck particles (zero velocity for too long)
                const velocityMag = safeSqrt(
                    particle.velocity.x ** 2 +
                    particle.velocity.y ** 2 +
                    particle.velocity.z ** 2
                );

                if (velocityMag < 0.001 && particle.Ec < 1) {
                    // Inject random kick
                    particle.velocity.x += (Math.random() - 0.5) * 0.1;
                    particle.velocity.y += (Math.random() - 0.5) * 0.1;
                    particle.velocity.z += (Math.random() - 0.5) * 0.1;
                    particle.Ec += 5;
                    wasHealed = true;
                }

                // Check for dead internal state
                if (Math.abs(particle.x12) < 0.001 && Math.abs(particle.dx12_dt) < 0.001) {
                    // Nudge internal state
                    particle.x12 += (Math.random() - 0.5) * 0.1;
                    wasHealed = true;
                }

                if (wasHealed) healedCount++;
            });

            if (healedCount > 0) {
                perpetualStats.healedCount += healedCount;
                console.log(`[PERPETUAL] Self-healed ${healedCount} particles`);
            }
        }

        /**
         * Generate synthetic audio when no microphone input
         * Ensures continuous brain data production
         */
        function generateFallbackAudio() {
            if (!PERPETUAL_CONFIG.fallbackAudioEnabled) return;
            if (isAudioActive) return; // Don't override real audio

            // Generate synthetic frequency data based on current particle states
            const syntheticFrequencyData = [];

            // Use particle frequencies to generate synthetic spectrum
            particles.forEach((p, idx) => {
                if (idx < 20) { // Top 20 particles
                    syntheticFrequencyData.push({
                        frequency: p.frequency || (440 + idx * 50),
                        magnitude: 0.3 + Math.random() * 0.4,
                        phase: p.theta || 0
                    });
                }
            });

            // Add some base frequencies for richness
            if (syntheticFrequencyData.length < 10) {
                for (let i = 0; i < 10; i++) {
                    syntheticFrequencyData.push({
                        frequency: 200 + i * 150,
                        magnitude: 0.2 + Math.random() * 0.3,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }

            // Update global frequency data
            frequencyData = syntheticFrequencyData;

            // Calculate synthetic audio energy
            audioEnergy = safeAverage(syntheticFrequencyData.map(f => f.magnitude), 0.5);
        }

        /**
         * Forced token generation - ensures continuous cognitive output
         */
        function forceContinuousTokenGeneration() {
            if (particles.length === 0) return;

            // Find most active particle
            let maxEnergyParticle = particles[0];
            particles.forEach(p => {
                if ((p.Ec || 0) > (maxEnergyParticle.Ec || 0)) {
                    maxEnergyParticle = p;
                }
            });

            // Generate token from most active particle
            const token = {
                id: nextDeterministicId ? nextDeterministicId() : `token_${Date.now()}_${Math.random()}`,
                type: 'perpetual_cognitive_output',
                timestamp: Date.now() / 1000,
                particleId: maxEnergyParticle.id,
                frequency: maxEnergyParticle.frequency || 440,
                energy: maxEnergyParticle.Ec || 0,
                x12_state: maxEnergyParticle.x12 || 0,
                m12_memory: maxEnergyParticle.m12 || 0,
                omega: maxEnergyParticle.omega || 0,
                psi: maxEnergyParticle.psi || 0,
                position: [maxEnergyParticle.x, maxEnergyParticle.y, maxEnergyParticle.z],
                audioActive: isAudioActive
            };

            // Add to token stream
            tokens.push(token);
            perpetualStats.generatedTokensCount++;
        }

        // Set up perpetual token generation timer
        let perpetualTokenTimer = null;
        function startPerpetualTokenGeneration() {
            if (perpetualTokenTimer) clearInterval(perpetualTokenTimer);

            perpetualTokenTimer = setInterval(() => {
                if (particles.length > 0) {
                    forceContinuousTokenGeneration();
                }
            }, PERPETUAL_CONFIG.tokenGenerationInterval);

            console.log('[PERPETUAL] Continuous token generation started');
        }

        /**
         * Update perpetual system status display
         */
        function updatePerpetualStatus() {
            const statusEl = document.getElementById('perpetual-status');
            const countEl = document.getElementById('perpetual-particle-count');
            const maxEl = document.getElementById('perpetual-particle-max');
            const energyEl = document.getElementById('perpetual-total-energy');
            const audioSourceEl = document.getElementById('perpetual-audio-source');
            const healedEl = document.getElementById('perpetual-healed-count');
            const injectionsEl = document.getElementById('perpetual-energy-injections');
            const tokensEl = document.getElementById('perpetual-token-count');

            if (statusEl) statusEl.textContent = particles.length > 0 ? 'ONLINE' : 'REGENERATING';
            if (countEl) countEl.textContent = particles.length;
            if (maxEl) maxEl.textContent = PERPETUAL_CONFIG.maxParticles;

            if (energyEl) {
                const totalEnergy = particles.reduce((sum, p) => sum + (p.Ec || 0), 0);
                energyEl.textContent = totalEnergy.toFixed(2);
            }

            if (audioSourceEl) {
                audioSourceEl.textContent = isAudioActive ? 'Microphone' : 'Synthetic';
            }

            if (healedEl) healedEl.textContent = perpetualStats.healedCount;
            if (injectionsEl) injectionsEl.textContent = perpetualStats.energyInjectionsCount;
            if (tokensEl) tokensEl.textContent = perpetualStats.generatedTokensCount;
        }

        console.log('[PERPETUAL] ‚úÖ Perpetual Operation System initialized');

        // ============================================================================
        // LEARNED EMBEDDING PROJECTION SYSTEM (NEW)
        // ============================================================================

        class LearnedEmbeddingProjector {
            constructor(inputDim = 11, hiddenDim = 32, outputDim = 3, learningRate = 0.01) {
                this.inputDim = inputDim;
                this.hiddenDim = hiddenDim;
                this.outputDim = outputDim;
                this.learningRate = learningRate;

                // Initialize weights and biases
                this.W1 = this.randomMatrix(inputDim, hiddenDim, 0.01);
                this.b1 = this.zerosVector(hiddenDim);

                this.W2 = this.randomMatrix(hiddenDim, outputDim, 0.01);
                this.b2 = this.zerosVector(outputDim);

                // Optimizer state (for momentum)
                this.mW1 = this.zerosMatrix(inputDim, hiddenDim);
                this.mb1 = this.zerosVector(hiddenDim);
                this.mW2 = this.zerosMatrix(hiddenDim, outputDim);
                this.mb2 = this.zerosVector(outputDim);

                this.trainingSamples = [];
                this.maxTrainingSamples = 1000;
            }

            // Utility functions for matrix operations
            randomMatrix(rows, cols, scale = 0.01) {
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    const row = [];
                    for (let j = 0; j < cols; j++) {
                        row.push((Math.random() - 0.5) * 2 * scale);
                    }
                    matrix.push(row);
                }
                return matrix;
            }

            zerosMatrix(rows, cols) {
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix.push(new Array(cols).fill(0));
                }
                return matrix;
            }

            zerosVector(size) {
                return new Array(size).fill(0);
            }

            // ReLU activation
            relu(x) {
                return Math.max(0, x);
            }

            reluDerivative(x) {
                return x > 0 ? 1 : 0;
            }

            // Tanh activation (for output normalization)
            tanh(x) {
                return Math.tanh(x);
            }

            tanhDerivative(x) {
                const t = Math.tanh(x);
                return 1 - t * t;
            }

            // Forward pass
            forward(input11d) {
                // Ensure input is exactly 11D
                const x = input11d.slice(0, 11);

                // Hidden layer: z1 = W1 * x + b1, a1 = relu(z1)
                this.z1 = [];
                this.a1 = [];
                for (let i = 0; i < this.hiddenDim; i++) {
                    let z = this.b1[i];
                    for (let j = 0; j < this.inputDim; j++) {
                        z += this.W1[j][i] * x[j];
                    }
                    this.z1.push(z);
                    this.a1.push(this.relu(z));
                }

                // Output layer: z2 = W2 * a1 + b2, a2 = tanh(z2)
                this.z2 = [];
                const output = [];
                for (let i = 0; i < this.outputDim; i++) {
                    let z = this.b2[i];
                    for (let j = 0; j < this.hiddenDim; j++) {
                        z += this.W2[j][i] * this.a1[j];
                    }
                    this.z2.push(z);
                    output.push(this.tanh(z)); // Normalized to [-1, 1]
                }

                this.lastInput = x;
                return output;
            }

            // Backward pass (simplified gradient descent)
            backward(target, learningRate = this.learningRate) {
                // Output error
                const dz2 = [];
                const currentOutput = this.forward(this.lastInput);
                for (let i = 0; i < this.outputDim; i++) {
                    const error = (currentOutput[i] - target[i]);
                    dz2.push(error * this.tanhDerivative(this.z2[i]));
                }

                // Update W2 and b2
                for (let i = 0; i < this.hiddenDim; i++) {
                    for (let j = 0; j < this.outputDim; j++) {
                        this.W2[i][j] -= learningRate * dz2[j] * this.a1[i];
                    }
                }
                for (let j = 0; j < this.outputDim; j++) {
                    this.b2[j] -= learningRate * dz2[j];
                }

                // Hidden layer error
                const da1 = [];
                for (let i = 0; i < this.hiddenDim; i++) {
                    let error = 0;
                    for (let j = 0; j < this.outputDim; j++) {
                        error += dz2[j] * this.W2[i][j];
                    }
                    da1.push(error);
                }

                const dz1 = [];
                for (let i = 0; i < this.hiddenDim; i++) {
                    dz1.push(da1[i] * this.reluDerivative(this.z1[i]));
                }

                // Update W1 and b1
                for (let i = 0; i < this.inputDim; i++) {
                    for (let j = 0; j < this.hiddenDim; j++) {
                        this.W1[i][j] -= learningRate * dz1[j] * this.lastInput[i];
                    }
                }
                for (let j = 0; j < this.hiddenDim; j++) {
                    this.b1[j] -= learningRate * dz1[j];
                }
            }

            // Add training sample (input: 11D, target: 3D projection)
            addTrainingSample(input11d, target3d) {
                this.trainingSamples.push({ input: input11d.slice(), target: target3d.slice() });
                if (this.trainingSamples.length > this.maxTrainingSamples) {
                    this.trainingSamples.shift();
                }
            }

            // Train on batch
            trainBatch(batchSize = 32, epochs = 1) {
                if (this.trainingSamples.length < batchSize) return;

                for (let epoch = 0; epoch < epochs; epoch++) {
                    for (let i = 0; i < Math.min(batchSize, this.trainingSamples.length); i++) {
                        const sample = this.trainingSamples[
                            Math.floor(Math.random() * this.trainingSamples.length)
                        ];
                        this.forward(sample.input);
                        this.backward(sample.target, this.learningRate);
                    }
                }
            }

            // Get projection (3D output from 11D input)
            project(input11d) {
                return this.forward(input11d);
            }
        }

        // Initialize global projector
        let learnedProjector = null;

        function initializeLearnedProjector() {
            learnedProjector = new LearnedEmbeddingProjector(11, 32, 3, 0.001);
        }

        // Training function - call periodically
        function trainLearnedProjector(updateFrequency = 100) {
            if (!learnedProjector || particles.length === 0) return;

            // Collect training samples from current particle states
            particles.forEach(particle => {
                // Input: 11D position + velocity
                const input11d = [
                    particle.x / 1e11,
                    particle.y / 1e11,
                    particle.z / 1e11,
                    particle.velocity.x / 1e3,
                    particle.velocity.y / 1e3,
                    particle.velocity.z / 1e3,
                    Math.log10(Math.max(particle.mass, 1)) / 30,
                    Math.log10(Math.max(particle.Ec, 1)) / 60,
                    particle.entropyS / 100,
                    particle.nu / 1e20,
                    particle.chaos / 100
                ];

                // Target: Current orthogonal projection (we'll use current position as target for now)
                const target3d = [
                    particle.x / 10,
                    particle.y / 10,
                    particle.z / 10
                ];

                learnedProjector.addTrainingSample(input11d, target3d);
            });

            // Train the network
            learnedProjector.trainBatch(32, 2);
        }

        // ============================================================================
        // PARAMETER SPACE EXPLORATION (NEW)
        // ============================================================================

        class ParameterSweep {
            constructor() {
                this.isRunning = false;
                this.results = [];
                this.currentSweep = null;
            }

            // Sweep a single parameter
            async sweepParameter(paramName, minVal, maxVal, steps, metric = 'totalEnergy') {
                this.results = [];
                const values = [];

                for (let i = 0; i <= steps; i++) {
                    const fraction = steps === 0 ? 0 : i / steps;
                    values.push(minVal + fraction * (maxVal - minVal));
                }

                for (const val of values) {
                    // Set parameter
                    if (paramName === 'alphaConnectivity') {
                        adapt.alpha = val;
                    } else if (paramName === 'k') {
                        adapt.k = val;
                    } else if (paramName === 'gamma') {
                        adapt.gamma = val;
                    } else if (paramName === 'sigma') {
                        sigma = val;
                    }

                    // Run simulation for N steps
                    let metric_value = 0;

                    for (let step = 0; step < 100; step++) {
                        if (particles.length > 0) {
                            updateLorenzParticles();
                        }
                        metric_value = this.computeMetric(metric);
                    }

                    this.results.push({ value: val, metric: metric_value });

                    // Yield to UI
                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                return this.results;
            }

            computeMetric(metricName) {
                switch(metricName) {
                    case 'totalEnergy':
                        return particles.reduce((sum, p) => sum + p.Ec, 0);
                    case 'totalEntropy':
                        return particles.reduce((sum, p) => sum + p.entropyS, 0);
                    case 'avgKurtosis':
                        const vels = particles.map(p => Math.sqrt(p.velocity.x**2 + p.velocity.y**2 + p.velocity.z**2));
                        const mean = vels.reduce((a,b) => a+b, 0) / Math.max(vels.length, 1);
                        const variance = vels.reduce((sum, v) => sum + (v - mean)**2, 0) / Math.max(vels.length, 1);
                        return variance;
                    case 'synapticStrength':
                        return particles.reduce((sum, p) => sum + (p.omega || 0), 0) / Math.max(particles.length, 1);
                    case 'networkDensity':
                        return this.computeNetworkDensity();
                    default:
                        return 0;
                }
            }

            computeNetworkDensity() {
                if (particles.length < 2) return 0;
                let connections = 0;
                const connectionRadius = 5.0;
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dist = Math.sqrt(
                            (particles[i].x - particles[j].x)**2 +
                            (particles[i].y - particles[j].y)**2 +
                            (particles[i].z - particles[j].z)**2
                        );
                        if (dist < connectionRadius) {
                            connections++;
                        }
                    }
                }
                return connections / Math.max((particles.length * (particles.length - 1) / 2), 1);
            }
        }

        const paramSweep = new ParameterSweep();

        // ============================================================================
        // ENERGY BALANCE ACCOUNTING (NEW)
        // ============================================================================

        class EnergyTracker {
            constructor() {
                this.history = [];
                this.maxHistory = 500;
            }

            // CST v2.5+ ULTIMATE ENHANCEMENT: 12D Quantum-Correlated Energy Budget
            recordEnergyState() {
                let kineticEnergy = 0;       // 3D kinetic energy
                let kinetic12D = 0;          // 12D kinetic energy from x12 motion
                let potentialEnergy = 0;     // Gravitational potential
                let quantumEnergy = 0;       // Quantum potential from psi
                let synapticEnergy = 0;      // Synaptic coupling energy from omega
                let frequencyEnergy = 0;     // Planck energy from frequency
                let chaosEnergy = 0;         // Chaos/entropy energy
                let darkMatterEnergy = 0;    // Dark matter energy

                // Planck constant (scaled for this simulation)
                const h = 6.626e-34 * 1e20; // Scaled Planck constant

                particles.forEach(p => {
                    // 3D kinetic energy: E_3D = 0.5 * m * v¬≤
                    const v2 = p.velocity.x**2 + p.velocity.y**2 + p.velocity.z**2;
                    kineticEnergy += 0.5 * p.mass * v2;

                    // 12D kinetic energy: E_12D = 0.5 * m12 * (dx12_dt)¬≤
                    const dx12_dt = isFinite(p.dx12_dt) ? p.dx12_dt : 0;
                    const m12 = isFinite(p.m12) ? Math.abs(p.m12) : 0.1;
                    kinetic12D += 0.5 * m12 * (dx12_dt**2) * p.mass * 10; // Scaled up for visibility

                    // Gravitational potential
                    potentialEnergy += (p.Ugrav || 0);

                    // Quantum potential energy: E_quantum from psi
                    const psi = isFinite(p.psi) ? Math.abs(p.psi) : 0;
                    const x12 = isFinite(p.x12) ? Math.abs(p.x12) : 0;
                    quantumEnergy += psi * x12 * 0.1 * p.mass; // Interaction energy

                    // Synaptic energy: E_synapse = Œ£ Omega_ij
                    const omega = isFinite(p.omega) ? p.omega : 0;
                    synapticEnergy += omega * p.mass * 0.5;

                    // Frequency energy: E_freq = h * nu (Planck relation)
                    const nu = isFinite(p.nu) ? p.nu : 0;
                    frequencyEnergy += h * Math.abs(nu);

                    // Chaos/entropy energy
                    chaosEnergy += (p.chaos || 0) * p.mass;

                    // Dark matter energy
                    darkMatterEnergy += (p.Udm || 0);
                });

                const totalEnergy = kineticEnergy + kinetic12D + potentialEnergy + quantumEnergy +
                                   synapticEnergy + frequencyEnergy + chaosEnergy + darkMatterEnergy;

                const record = {
                    timestamp: Date.now(),
                    kinetic: kineticEnergy,
                    kinetic12D: kinetic12D,
                    potential: potentialEnergy,
                    quantum: quantumEnergy,
                    synaptic: synapticEnergy,
                    frequency: frequencyEnergy,
                    chaos: chaosEnergy,
                    darkMatter: darkMatterEnergy,
                    total: totalEnergy,
                    particleCount: particles.length
                };

                this.history.push(record);
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }

                return record;
            }

            // CST v2.5+ ENHANCEMENT: 12D Energy Budget Display
            getEnergyBudget() {
                if (this.history.length === 0) return null;

                const latest = this.history[this.history.length - 1];
                const total = Math.abs(latest.total) || 1;

                return {
                    kineticPercent: (Math.abs(latest.kinetic) / total * 100).toFixed(1),
                    kinetic12DPercent: (Math.abs(latest.kinetic12D || 0) / total * 100).toFixed(1),
                    potentialPercent: (Math.abs(latest.potential) / total * 100).toFixed(1),
                    quantumPercent: (Math.abs(latest.quantum || 0) / total * 100).toFixed(1),
                    synapticPercent: (Math.abs(latest.synaptic || 0) / total * 100).toFixed(1),
                    frequencyPercent: (Math.abs(latest.frequency || 0) / total * 100).toFixed(1),
                    chaosPercent: (Math.abs(latest.chaos) / total * 100).toFixed(1),
                    darkMatterPercent: (Math.abs(latest.darkMatter) / total * 100).toFixed(1),
                    absoluteKinetic: latest.kinetic.toExponential(2),
                    absoluteKinetic12D: (latest.kinetic12D || 0).toExponential(2),
                    absolutePotential: latest.potential.toExponential(2),
                    absoluteQuantum: (latest.quantum || 0).toExponential(2),
                    absoluteSynaptic: (latest.synaptic || 0).toExponential(2),
                    absoluteFrequency: (latest.frequency || 0).toExponential(2),
                    absoluteChaos: latest.chaos.toExponential(2),
                    absoluteDarkMatter: latest.darkMatter.toExponential(2)
                };
            }

            displayEnergyBudget() {
                const budget = this.getEnergyBudget();
                if (!budget) return;

                let html = '<h4>12D Energy Budget Breakdown</h4>';
                html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.9em;">';

                html += `<div>3D Kinetic: <strong>${budget.kineticPercent}%</strong><br><small>${budget.absoluteKinetic} J</small></div>`;
                html += `<div>12D Kinetic: <strong>${budget.kinetic12DPercent}%</strong><br><small>${budget.absoluteKinetic12D} J</small></div>`;
                html += `<div>Potential: <strong>${budget.potentialPercent}%</strong><br><small>${budget.absolutePotential} J</small></div>`;
                html += `<div>Quantum: <strong>${budget.quantumPercent}%</strong><br><small>${budget.absoluteQuantum} J</small></div>`;
                html += `<div>Synaptic: <strong>${budget.synapticPercent}%</strong><br><small>${budget.absoluteSynaptic} J</small></div>`;
                html += `<div>Frequency: <strong>${budget.frequencyPercent}%</strong><br><small>${budget.absoluteFrequency} J</small></div>`;
                html += `<div>Chaos: <strong>${budget.chaosPercent}%</strong><br><small>${budget.absoluteChaos} J</small></div>`;
                html += `<div>Dark Matter: <strong>${budget.darkMatterPercent}%</strong><br><small>${budget.absoluteDarkMatter} J</small></div>`;

                html += '</div>';

                const display = document.getElementById('energyBudgetDisplay');
                if (display) display.innerHTML = html;
            }
        }

        const energyTracker = new EnergyTracker();

        // ============================================================================
        // MULTI-SCALE SYNCHRONIZATION ANALYSIS (NEW)
        // ============================================================================

        class SynchronizationAnalyzer {
            constructor() {
                this.orderParameters = [];
                this.maxHistory = 500;
            }

            // CST v2.5+ ULTIMATE ENHANCEMENT: 12D Quantum-Enhanced Kuramoto Order Parameter
            computeKuramotoOrderParameter(particleArray, timescale = 1) {
                if (particleArray.length < 2) return 0;

                let sumSin = 0, sumCos = 0;

                particleArray.forEach(p => {
                    // 12D-ENHANCED PHASE: theta + (x12 * 2œÄ) + (nu * t)
                    // Combines traditional phase, 12D position, and frequency evolution
                    const theta = isFinite(p.theta) ? p.theta : 0;
                    const x12 = isFinite(p.x12) ? p.x12 : 0;
                    const nu = isFinite(p.nu) ? p.nu : 0;

                    const phase = theta +
                                (x12 * 2 * Math.PI) +
                                (2 * Math.PI * nu * timescale * 1e-18); // Scale nu for reasonable phase

                    sumSin += Math.sin(phase);
                    sumCos += Math.cos(phase);
                });

                const orderParam = Math.sqrt(sumSin**2 + sumCos**2) / particleArray.length;
                return Math.min(1, orderParam); // Clamp to [0, 1]
            }

            // CST v2.5+ ENHANCEMENT: 12D Chimera Detection in x12 subspaces
            detectChimeras(particleArray) {
                if (particleArray.length < 4) return {
                    hasChimeraStates: false,
                    chimeraMeasure: 0,
                    psiCoherence: 0
                };

                // Partition particles by x12 ranges (12D subspaces)
                const x12Groups = {
                    'low': [],      // x12 in [-1, -0.5]
                    'mid_low': [],  // x12 in [-0.5, 0]
                    'mid_high': [], // x12 in [0, 0.5]
                    'high': []      // x12 in [0.5, 1]
                };

                particleArray.forEach(p => {
                    const x12 = isFinite(p.x12) ? p.x12 : 0;
                    if (x12 < -0.5) x12Groups['low'].push(p);
                    else if (x12 < 0) x12Groups['mid_low'].push(p);
                    else if (x12 < 0.5) x12Groups['mid_high'].push(p);
                    else x12Groups['high'].push(p);
                });

                // Check for partial synchronization in 12D subspaces (chimera state indicator)
                const chimeraIndicators = [];
                Object.values(x12Groups).forEach(group => {
                    if (group.length > 1) {
                        const orderParam = this.computeKuramotoOrderParameter(group);
                        chimeraIndicators.push(orderParam);
                    }
                });

                // Calculate psi coherence
                const psiValues = particleArray.map(p => isFinite(p.psi) ? Math.abs(p.psi) : 0);
                const meanPsi = psiValues.reduce((a, b) => a + b, 0) / psiValues.length;
                const stdPsi = Math.sqrt(psiValues.reduce((sum, psi) => sum + (psi - meanPsi)**2, 0) / psiValues.length);
                const psiCoherence = meanPsi > 0 ? Math.max(0, 1 - stdPsi / meanPsi) : 0;

                return {
                    hasChimeraStates: chimeraIndicators.some(o => o > 0.2 && o < 0.8),
                    chimeraMeasure: chimeraIndicators.length > 0 ?
                        chimeraIndicators.reduce((a,b) => a+b, 0) / chimeraIndicators.length : 0,
                    psiCoherence: psiCoherence
                };
            }

            // CST v2.5+ ENHANCEMENT: 12D-Modulated Frequency Detuning
            computeFrequencyDetuning(particleArray) {
                if (particleArray.length < 2) return 0;

                // Enhanced frequency with 12D modulation: nu * (1 + x12)
                const modulated_frequencies = particleArray.map(p => {
                    const nu = isFinite(p.nu) ? p.nu : 0;
                    const x12 = isFinite(p.x12) ? p.x12 : 0;
                    return nu * (1 + x12 * 0.1); // 10% modulation by x12
                });

                const meanFreq = modulated_frequencies.reduce((a,b) => a+b, 0) / modulated_frequencies.length;
                const detuning = modulated_frequencies.reduce((sum, f) => sum + (f - meanFreq)**2, 0) / modulated_frequencies.length;

                return Math.sqrt(detuning);
            }

            // CST v2.5+ ENHANCEMENT: Record 12D synchronization state
            recordSynchronizationState() {
                const orderParam = this.computeKuramotoOrderParameter(particles);
                const chimera = this.detectChimeras(particles);
                const detuning = this.computeFrequencyDetuning(particles);

                const record = {
                    timestamp: Date.now(),
                    kuramotoOrder: orderParam,
                    chimeraIndicator: chimera.chimeraMeasure,
                    frequencyDetuning: detuning,
                    hasChimeras: chimera.hasChimeras,
                    psiCoherence: chimera.psiCoherence || 0
                };

                this.orderParameters.push(record);
                if (this.orderParameters.length > this.maxHistory) {
                    this.orderParameters.shift();
                }

                return record;
            }

            displaySynchronizationMetrics() {
                if (this.orderParameters.length === 0) return;

                const latest = this.orderParameters[this.orderParameters.length - 1];

                let html = '<h4>12D Synchronization Analysis</h4>';
                html += `<p>Kuramoto Order (12D): <strong>${latest.kuramotoOrder.toFixed(3)}</strong></p>`;
                html += `<p>Frequency Detuning: ${latest.frequencyDetuning.toExponential(2)} Hz</p>`;
                html += `<p>Chimera Measure: ${latest.chimeraIndicator.toFixed(3)}</p>`;
                html += `<p>Psi Coherence: <strong>${latest.psiCoherence.toFixed(3)}</strong></p>`;

                if (latest.hasChimeras) {
                    html += '<p style="color: #ffaa00;">‚ö†Ô∏è Chimera state detected (partial 12D synchronization)</p>';
                }

                const display = document.getElementById('synchronizationDisplay');
                if (display) display.innerHTML = html;
            }
        }

        const syncAnalyzer = new SynchronizationAnalyzer();

        // ============================================================================
        // PHI-HARMONIC AUDIO SYNTHESIS (NEW)
        // ============================================================================

        class PhiHarmonicSynthesizer {
            constructor(audioContext) {
                this.ctx = audioContext;
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);

                this.oscillators = [];
                this.gains = [];
                this.phi = 1.618033988749895;
            }

            generatePhiHarmonics(fundamental, numHarmonics = 8) {
                const harmonics = [];

                for (let i = 0; i < numHarmonics; i++) {
                    let freq = fundamental * Math.pow(this.phi, i / 2);

                    // Octave fold to reasonable range
                    while (freq > fundamental * 8) freq /= 2;
                    while (freq < fundamental / 4) freq *= 2;

                    harmonics.push(freq);
                }

                return harmonics;
            }

            synthesizeParticleSound(particle, duration = 0.5) {
                const fundamental = particle.nu || 440;
                if (!fundamental || fundamental === 0) return;

                const harmonics = this.generatePhiHarmonics(fundamental, 6);

                harmonics.forEach((freq, index) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();

                    osc.frequency.value = Math.max(20, Math.min(20000, freq));
                    osc.type = ['sine', 'triangle', 'square', 'sawtooth'][index % 4];

                    // Envelope: fade in, sustain, fade out
                    gain.gain.setValueAtTime(0, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.1 / (index + 1), this.ctx.currentTime + duration * 0.2);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(this.masterGain);

                    osc.start(this.ctx.currentTime);
                    osc.stop(this.ctx.currentTime + duration);

                    this.oscillators.push(osc);
                });
            }

            generateMusicFromParticles(duration = 2.0) {
                if (particles.length === 0) return;

                // Sort by energy and select top N
                const topParticles = particles
                    .sort((a, b) => (b.Ec || 0) - (a.Ec || 0))
                    .slice(0, Math.min(5, particles.length));

                // Stagger synthesis to create melody
                topParticles.forEach((p, index) => {
                    setTimeout(() => {
                        this.synthesizeParticleSound(p, duration / 2);
                    }, index * (duration * 1000 / topParticles.length));
                });
            }

            setVolume(value) {
                this.masterGain.gain.value = Math.max(0, Math.min(1, value));
            }
        }

        let audioContextForSynth = null;
        let phiSynthesizer = null;

        function initializeAudioSynthesis() {
            if (audioContextForSynth) return;

            audioContextForSynth = new (window.AudioContext || window.webkitAudioContext)();
            phiSynthesizer = new PhiHarmonicSynthesizer(audioContextForSynth);
        }

        // ============================================================================
        // EMERGENCE QUANTIFICATION (NEW)
        // ============================================================================

        class EmergenceDetector {
            constructor() {
                this.emergenceHistory = [];
                this.maxHistory = 500;
            }

            // CST v2.5+ ULTIMATE ENHANCEMENT: 12D Quantum-Correlated Integrated Information
            computeIntegratedInformation(particleArray, timescale = 100) {
                // Enhanced Œ¶ (integrated information) with 12D mutual information
                if (particleArray.length < 3) return 0;

                // Compute mutual information between subgroups
                const midpoint = Math.floor(particleArray.length / 2);
                const group1 = particleArray.slice(0, midpoint);
                const group2 = particleArray.slice(midpoint);

                // 12D-Enhanced information in each group
                const info1 = this.computeGroupEntropy(group1);
                const info2 = this.computeGroupEntropy(group2);

                // Information in whole
                const infoTotal = this.computeGroupEntropy(particleArray);

                // 12D Mutual Information: I_12D(A,B) = H(x12_A) + H(x12_B) - H(x12_combined)
                const H_x12_A = this.compute12DEntropy(group1, 'x12');
                const H_x12_B = this.compute12DEntropy(group2, 'x12');
                const H_x12_combined = this.compute12DEntropy(particleArray, 'x12');
                const I_x12 = H_x12_A + H_x12_B - H_x12_combined;

                // Psi mutual information
                const H_psi_A = this.compute12DEntropy(group1, 'psi');
                const H_psi_B = this.compute12DEntropy(group2, 'psi');
                const H_psi_combined = this.compute12DEntropy(particleArray, 'psi');
                const I_psi = H_psi_A + H_psi_B - H_psi_combined;

                // Integrated information (simplified) with 12D contribution
                const phi_base = Math.max(0, info1 + info2 - infoTotal);
                const phi_12D = Math.max(0, I_x12) * 0.5 + Math.max(0, I_psi) * 0.3;
                const phi = phi_base + phi_12D;

                return Math.max(0, phi);
            }

            // CST v2.5+ NEW: Compute 12D entropy for specific variable
            compute12DEntropy(particleArray, variable) {
                if (particleArray.length === 0) return 0;

                const bins = 16;
                const histogram = new Array(bins).fill(0);

                // Extract values
                const values = particleArray.map(p => {
                    const val = isFinite(p[variable]) ? p[variable] : 0;
                    return variable === 'psi' ? Math.abs(val) : val;
                });

                const maxVal = Math.max(...values.map(Math.abs), 1);

                // Bin values
                values.forEach(val => {
                    const normalized = variable === 'psi' ? val / maxVal : (val + maxVal) / (2 * maxVal);
                    const bin = Math.min(bins - 1, Math.max(0, Math.floor(normalized * bins)));
                    histogram[bin]++;
                });

                // Shannon entropy
                let H = 0;
                const total = particleArray.length;
                histogram.forEach(count => {
                    if (count > 0) {
                        const p = count / total;
                        H -= p * Math.log(p);
                    }
                });

                return H;
            }

            computeGroupEntropy(particleArray) {
                if (particleArray.length === 0) return 0;

                let totalEntropy = 0;
                particleArray.forEach(p => {
                    totalEntropy += p.entropyS || 0;
                });

                return totalEntropy / Math.log(particleArray.length + 1);
            }

            // CST v2.5+ ENHANCEMENT: 12D Causal Density with dx12_dt correlation
            computeCausalDensity(particleArray) {
                // Enhanced measure of downward causation via 12D state influence
                if (particleArray.length < 2) return 0;

                // Count particles influenced by emergent patterns
                let influenced = 0;

                // Calculate global average psi (emergent collective state)
                const avgPsi = particleArray.reduce((sum, p) => sum + Math.abs(isFinite(p.psi) ? p.psi : 0), 0) / particleArray.length;

                // Detect collective oscillations in both nu and x12
                const avgFreq = particleArray.reduce((sum, p) => sum + (p.nu || 0), 0) / particleArray.length;
                const freqVariance = particleArray.reduce((sum, p) => sum + ((p.nu || 0) - avgFreq)**2, 0) / particleArray.length;

                // 12D state influence: dx12_dt correlates with global <psi>
                particleArray.forEach(p => {
                    const freqDistance = Math.abs((p.nu || 0) - avgFreq);
                    const freqInfluenced = freqDistance < Math.sqrt(freqVariance);

                    // Check if dx12_dt is influenced by global psi (correlation)
                    const dx12_dt = Math.abs(isFinite(p.dx12_dt) ? p.dx12_dt : 0);
                    const psi = Math.abs(isFinite(p.psi) ? p.psi : 0);

                    // Correlation: particles with psi close to avgPsi and non-zero dx12_dt are influenced
                    const psiDistance = Math.abs(psi - avgPsi);
                    const psiInfluenced = (psiDistance < avgPsi * 0.5) && (dx12_dt > 0.01);

                    if (freqInfluenced || psiInfluenced) {
                        influenced++;
                    }
                });

                return influenced / Math.max(particleArray.length, 1);
            }

            // CST v2.5+ ENHANCEMENT: 12D Hierarchical Levels by combined energy
            detectHierarchicalLevels(particleArray) {
                // Cluster particles by combined energy (E_3D + E_12D + E_quantum)
                const levels = [];

                // Calculate combined energy for each particle
                const particlesWithEnergy = particleArray.map(p => {
                    const E_3D = p.Ec || 0;
                    const v2 = (p.velocity.x**2 + p.velocity.y**2 + p.velocity.z**2) || 0;
                    const E_kinetic = 0.5 * (p.mass || 1) * v2;

                    // 12D kinetic energy
                    const dx12_dt = isFinite(p.dx12_dt) ? p.dx12_dt : 0;
                    const m12 = isFinite(p.m12) ? Math.abs(p.m12) : 0.1;
                    const E_12D = 0.5 * m12 * (dx12_dt**2) * (p.mass || 1);

                    // Quantum energy from psi
                    const psi = isFinite(p.psi) ? Math.abs(p.psi) : 0;
                    const x12 = isFinite(p.x12) ? Math.abs(p.x12) : 0;
                    const E_quantum = psi * x12 * 0.1;

                    const E_total = E_kinetic + E_12D + E_quantum;

                    return { particle: p, energy: E_total };
                });

                const sortedByEnergy = particlesWithEnergy.sort((a, b) => a.energy - b.energy);

                let currentLevel = [];
                let lastEnergy = 0;
                const energyThreshold = sortedByEnergy.length > 0 ?
                    (sortedByEnergy[Math.floor(sortedByEnergy.length / 2)].energy || 1) * 0.3 : 1;

                sortedByEnergy.forEach(({ particle, energy }) => {
                    if (currentLevel.length === 0 || Math.abs(energy - lastEnergy) < energyThreshold) {
                        currentLevel.push(particle);
                        lastEnergy = energy;
                    } else {
                        if (currentLevel.length > 1) {
                            levels.push(currentLevel);
                        }
                        currentLevel = [particle];
                        lastEnergy = energy;
                    }
                });

                if (currentLevel.length > 1) {
                    levels.push(currentLevel);
                }

                return levels;
            }

            recordEmergenceState() {
                const phi = this.computeIntegratedInformation(particles);
                const causalDensity = this.computeCausalDensity(particles);
                const hierarchyLevels = this.detectHierarchicalLevels(particles);

                const record = {
                    timestamp: Date.now(),
                    integratedInformation: phi,
                    causalDensity: causalDensity,
                    hierarchyDepth: hierarchyLevels.length,
                    isEmergent: phi > 0.1 && causalDensity > 0.3
                };

                this.emergenceHistory.push(record);
                if (this.emergenceHistory.length > this.maxHistory) {
                    this.emergenceHistory.shift();
                }

                return record;
            }

            displayEmergenceMetrics() {
                if (this.emergenceHistory.length === 0) return;

                const latest = this.emergenceHistory[this.emergenceHistory.length - 1];

                let html = '<h4>Emergence Analysis</h4>';
                html += `<p>Integrated Information (Œ¶): ${latest.integratedInformation.toFixed(3)}</p>`;
                html += `<p>Causal Density: ${latest.causalDensity.toFixed(3)}</p>`;
                html += `<p>Hierarchy Depth: ${latest.hierarchyDepth}</p>`;

                if (latest.isEmergent) {
                    html += '<p style="color: #00ff00;">‚úì Emergent behavior detected</p>';
                }

                const display = document.getElementById('emergenceDisplay');
                if (display) display.innerHTML = html;
            }
        }

        const emergenceDetector = new EmergenceDetector();

        // ============================================================================
        // STOCHASTIC RESONANCE MODULE (NEW - CST v2.0 COMPLETION)
        // ============================================================================

        class StochasticResonanceDetector {
            constructor() {
                this.noiseLevel = 0.1;
                this.signalAmplitude = 1.0;
                this.resonantFrequency = 100;
                this.optimalNoise = null;
                this.snrHistory = [];
                this.maxHistory = 200;
            }

            // Calculate Signal-to-Noise Ratio
            calculateSNR(signal, noise) {
                const signalPower = signal.reduce((sum, s) => sum + s * s, 0) / Math.max(signal.length, 1);
                const noisePower = noise.reduce((sum, n) => sum + n * n, 0) / Math.max(noise.length, 1);

                return signalPower / Math.max(noisePower, 1e-10);
            }

            // Detect resonant frequency from particle speeds
            detectResonantFrequency() {
                if (particles.length === 0) return 0;

                const speeds = particles.map(p =>
                    Math.sqrt(p.velocity.x**2 + p.velocity.y**2 + p.velocity.z**2)
                );

                const mean = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                const variance = speeds.reduce((sum, s) => sum + (s - mean)**2, 0) / speeds.length;

                this.resonantFrequency = Math.sqrt(variance) || 100;
                return this.resonantFrequency;
            }

            // Optimal noise calculation (simplified)
            findOptimalNoise() {
                let maxSNR = 0;
                let bestNoise = 0.1;

                for (let noise = 0.01; noise < 1.0; noise += 0.05) {
                    const signal = particles.map(p => p.Ec).slice(0, 20);
                    const noiseArray = Array(signal.length).fill(0).map(() => Math.random() * noise);
                    const snr = this.calculateSNR(signal, noiseArray);

                    if (snr > maxSNR) {
                        maxSNR = snr;
                        bestNoise = noise;
                    }
                }

                this.optimalNoise = bestNoise;
                return { optimalNoise: bestNoise, maxSNR: maxSNR };
            }

            // Add stochastic noise to particle states
            applyStochasticNoise(intensity = 0.1) {
                particles.forEach(p => {
                    p.x += (Math.random() - 0.5) * intensity;
                    p.y += (Math.random() - 0.5) * intensity;
                    p.z += (Math.random() - 0.5) * intensity;
                });
            }

            // Detect SR enhancement
            detectSREnhancement() {
                if (this.snrHistory.length < 2) return null;

                const current = this.snrHistory[this.snrHistory.length - 1];
                const previous = this.snrHistory[this.snrHistory.length - 2];

                const improvement = (current - previous) / Math.max(previous, 1e-10);

                return {
                    currentSNR: current,
                    previousSNR: previous,
                    improvement: improvement,
                    isEnhanced: improvement > 0.1 // 10% improvement threshold
                };
            }

            recordSNR() {
                const signal = particles.map(p => p.Ec).slice(0, 20);
                const noise = Array(signal.length).fill(0).map(() => Math.random() * this.noiseLevel);
                const snr = this.calculateSNR(signal, noise);

                this.snrHistory.push(snr);
                if (this.snrHistory.length > this.maxHistory) {
                    this.snrHistory.shift();
                }

                return snr;
            }
        }

        const stochasticResonanceDetector = new StochasticResonanceDetector();
        console.log('[CST Stochastic Resonance] ‚úÖ Stochastic resonance detector initialized');

        // ============================================================================
        // ENHANCED CHAOS MEASUREMENT (CST v2.0 COMPLETION)
        // ============================================================================

        class ChaosMeasurement {
            constructor() {
                this.trajectoryPairs = new Map();
                this.maxTrajectories = 100;
                this.divergenceHistory = [];
                this.maxHistory = 200;
                this.perturbationScale = 1e-6;
            }

            // Wolf's algorithm for Lyapunov exponent
            computeLyapunovExponent() {
                if (particles.length < 2) return 0;

                // Compute mean field divergence
                let totalDivergence = 0;
                let count = 0;

                for (let i = 0; i < Math.min(5, particles.length); i++) {
                    for (let j = i + 1; j < Math.min(i + 5, particles.length); j++) {
                        const p1 = particles[i];
                        const p2 = particles[j];

                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const dz = p2.z - p1.z;
                        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);

                        if (distance > this.perturbationScale) {
                            totalDivergence += Math.log(distance / this.perturbationScale);
                            count++;
                        }
                    }
                }

                const lyapunov = totalDivergence / Math.max(count, 1) / (timestep.dt || 0.005);
                return Math.abs(lyapunov);
            }

            // KIM (Kaplan-Yorke) dimension (simplified)
            computeAttractorDimension() {
                if (particles.length < 3) return 0;

                // Compute correlation dimension
                const positions = particles.map(p => [p.x, p.y, p.z]);
                let correlations = 0;
                const testRadius = 5.0;

                for (let i = 0; i < positions.length; i++) {
                    for (let j = i + 1; j < positions.length; j++) {
                        const dx = positions[j][0] - positions[i][0];
                        const dy = positions[j][1] - positions[i][1];
                        const dz = positions[j][2] - positions[i][2];
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                        if (dist < testRadius) correlations++;
                    }
                }

                const correlation = correlations / (positions.length * (positions.length - 1) / 2);
                const dimension = Math.log(correlation) / Math.log(testRadius / 10);

                return Math.max(0, dimension);
            }

            recordDivergence() {
                const lyapunov = this.computeLyapunovExponent();
                const dimension = this.computeAttractorDimension();

                this.divergenceHistory.push({
                    lyapunov: lyapunov,
                    dimension: dimension,
                    timestamp: Date.now()
                });

                if (this.divergenceHistory.length > this.maxHistory) {
                    this.divergenceHistory.shift();
                }

                return { lyapunov, dimension };
            }

            getChaoticRegime() {
                if (this.divergenceHistory.length === 0) return 'unknown';

                const latest = this.divergenceHistory[this.divergenceHistory.length - 1];

                if (latest.lyapunov > 1.0) return 'chaotic';
                if (latest.lyapunov > 0.1) return 'mixed';
                return 'ordered';
            }
        }

        const chaosMeasurement = new ChaosMeasurement();
        console.log('[CST Chaos Measurement] ‚úÖ Enhanced chaos measurement system initialized');

        // ============================================================================
        // VOICE BIO-FREQUENCY EXTRACTION (NEW - CST v2.0 COMPLETION)
        // ============================================================================

        // CST v2.5+ ULTIMATE ENHANCEMENT: AI Voice Bio-Frequency with Autocorrelation
        class VoiceBioFrequencyExtractor {
            constructor() {
                this.baselineFrequency = 150; // Hz (typical neutral voice fundamental)
                this.userFrequency = null;
                this.emotionalState = 'neutral';
                this.personalizedParams = {};
                this.pitchHistory = []; // For pitch tracking filter
                this.maxHistoryLength = 10; // Moving average over 10 frames
            }

            // CST v2.5+ ENHANCEMENT: Autocorrelation-based F0 detection (more accurate)
            extractFundamentalFrequency(analyser, dataArray) {
                if (!analyser || !dataArray) return this.baselineFrequency;

                // Get time-domain data for autocorrelation
                const timeData = new Uint8Array(analyser.fftSize);
                analyser.getByteTimeDomainData(timeData);

                const sampleRate = audioContext ? audioContext.sampleRate : 44100;

                // Autocorrelation method for pitch detection
                const autoCorrelation = this.autocorrelate(timeData, sampleRate);

                if (autoCorrelation > 0) {
                    // Apply pitch tracking filter (moving average)
                    this.pitchHistory.push(autoCorrelation);
                    if (this.pitchHistory.length > this.maxHistoryLength) {
                        this.pitchHistory.shift();
                    }

                    // Smooth pitch with moving average
                    const smoothedPitch = this.pitchHistory.reduce((a, b) => a + b, 0) / this.pitchHistory.length;
                    return Math.max(50, Math.min(500, smoothedPitch));
                }

                // Fallback to frequency-domain method if autocorrelation fails
                analyser.getByteFrequencyData(dataArray);

                let maxValue = 0;
                let maxIndex = 0;

                // Search in voice range 80-300 Hz (human voice fundamental)
                const minBin = Math.floor(80 * dataArray.length / (sampleRate / 2));
                const maxBin = Math.floor(300 * dataArray.length / (sampleRate / 2));

                for (let i = minBin; i < maxBin; i++) {
                    if (dataArray[i] > maxValue) {
                        maxValue = dataArray[i];
                        maxIndex = i;
                    }
                }

                const frequency = maxIndex * (sampleRate / 2) / dataArray.length;
                return Math.max(50, Math.min(500, frequency));
            }

            // CST v2.5+ NEW: Autocorrelation pitch detection algorithm
            autocorrelate(buffer, sampleRate) {
                const SIZE = buffer.length;
                const rms = this.rootMeanSquare(buffer);

                // Not enough signal
                if (rms < 10) return -1;

                // Find period by autocorrelation
                let r1 = 0, r2 = SIZE - 1, threshold = 0.2;

                // Find first zero crossing
                for (let i = 0; i < SIZE / 2; i++) {
                    if (Math.abs(buffer[i] - 128) < threshold) {
                        r1 = i;
                        break;
                    }
                }

                // Find correlation
                let maxval = -1, maxpos = -1;
                const minPeriod = Math.floor(sampleRate / 500); // 500 Hz max
                const maxPeriod = Math.floor(sampleRate / 50);  // 50 Hz min

                for (let i = minPeriod; i < Math.min(maxPeriod, SIZE / 2); i++) {
                    let sum = 0;
                    for (let j = 0; j < SIZE / 2; j++) {
                        sum += Math.abs((buffer[j] - 128) - (buffer[j + i] - 128));
                    }
                    sum = 1 - (sum / (SIZE / 2) / 128);

                    if (sum > maxval) {
                        maxval = sum;
                        maxpos = i;
                    }
                }

                if (maxval > 0.01 && maxpos > 0) {
                    return sampleRate / maxpos;
                }

                return -1;
            }

            // Helper: Calculate RMS of buffer
            rootMeanSquare(buffer) {
                let sum = 0;
                for (let i = 0; i < buffer.length; i++) {
                    const val = (buffer[i] - 128) / 128;
                    sum += val * val;
                }
                return Math.sqrt(sum / buffer.length) * 128;
            }

            // CST v2.5+ ENHANCEMENT: Detailed emotional state classification
            classifyEmotionalState(frequency) {
                if (frequency < 100) return 'calm/sad';
                else if (frequency >= 100 && frequency < 150) return 'neutral';
                else if (frequency >= 150 && frequency < 200) return 'excited';
                else if (frequency >= 200) return 'stressed/high-energy';
                return 'neutral';
            }

            // CST v2.5+ ENHANCEMENT: Generate personalized parameters from voice bio-frequency
            generatePersonalizedParams(userFrequency) {
                this.userFrequency = userFrequency;
                this.emotionalState = this.classifyEmotionalState(userFrequency);

                // Base parameters (default values)
                const base_k = 0.5;
                const base_omega_scale = 1.0;
                const base_dx12_rate = 1.0;
                const base_m12_damping = 1.0;

                // Emotional state-specific modulation
                let k_mod = 1.0, omega_mod = 1.0, dx12_mod = 1.0, m12_damp = 1.0, chaos_mod = 1.0;

                if (userFrequency < 100) {
                    // CALM/SAD: decrease Ksync, increase m12 damping
                    k_mod = 0.7;
                    omega_mod = 0.8;
                    dx12_mod = 0.8;
                    m12_damp = 1.3;
                    chaos_mod = 0.6;
                } else if (userFrequency >= 100 && userFrequency < 150) {
                    // NEUTRAL: default parameters
                    k_mod = 1.0;
                    omega_mod = 1.0;
                    dx12_mod = 1.0;
                    m12_damp = 1.0;
                    chaos_mod = 1.0;
                } else if (userFrequency >= 150 && userFrequency < 200) {
                    // EXCITED: increase Ksync, increase omega
                    k_mod = 1.3;
                    omega_mod = 1.4;
                    dx12_mod = 1.3;
                    m12_damp = 0.8;
                    chaos_mod = 1.2;
                } else {
                    // STRESSED/HIGH-ENERGY: increase chaos, increase dx12_dt rate
                    k_mod = 1.5;
                    omega_mod = 1.6;
                    dx12_mod = 1.6;
                    m12_damp = 0.6;
                    chaos_mod = 1.5;
                }

                // Personalized parameters with smooth modulation
                const personalized_k = base_k * (1 + (userFrequency - 150) / 150) * 0.5;
                const personalized_omega_scale = 1 + (userFrequency - 150) / 300;
                const personalized_x12_rate = base_dx12_rate * (userFrequency / 150);

                this.personalizedParams = {
                    // Adjust k (coupling) based on emotional state
                    k: Math.max(0.3, Math.min(0.8, personalized_k * k_mod)),

                    // Adjust gamma (decay) - inverse relationship
                    gamma: 0.2 * (1.0 / m12_damp),

                    // Adjust alpha (memory) - excited state = more memory
                    alpha: 0.3 * omega_mod,

                    // Adjust Ksync (synchronization strength)
                    Ksync: 0.1 * k_mod,

                    // Omega scaling
                    omegaScale: personalized_omega_scale * omega_mod,

                    // dx12_dt rate modulation
                    x12RateScale: personalized_x12_rate * dx12_mod,

                    // m12 damping factor
                    m12DampingFactor: m12_damp,

                    // Chaos/entropy influence
                    chaosInfluence: chaos_mod,

                    // Audio sensitivity
                    audioSensitivity: Math.max(0.5, Math.min(3.0, userFrequency / 100)),

                    // Visual energy scale
                    visualScale: userFrequency / 150,

                    emotionalState: this.emotionalState,
                    voiceFrequency: userFrequency
                };

                return this.personalizedParams;
            }

            applyPersonalization() {
                if (!this.personalizedParams.k) return;

                // Apply to global config
                adapt.k = this.personalizedParams.k;
                adapt.gamma = this.personalizedParams.gamma;
                adapt.alpha = this.personalizedParams.alpha;
                sync.Ksync = this.personalizedParams.Ksync;
                audioSensitivity = this.personalizedParams.audioSensitivity;

                console.log('[CST AI Voice] Applied personalization for', this.emotionalState, 'state');
            }
        }

        const voiceBioExtractor = new VoiceBioFrequencyExtractor();
        console.log('[CST Voice Bio] ‚úÖ Voice bio-frequency extractor initialized');

        // ============================================================================
        // OBSERVATIONAL COMPARISON & POWER SPECTRUM (NEW)
        // ============================================================================

        class ObservationalComparison {
            constructor() {
                this.powerSpectrum = [];
                this.correlationFunction = [];
            }

            computePowerSpectrum(particleArray) {
                if (particleArray.length === 0) return [];

                const frequencies = [];
                const k_min = 1e-5;
                const k_max = 1.0;
                const n_bins = 50;

                // Log-spaced k bins
                for (let i = 0; i < n_bins; i++) {
                    frequencies.push(Math.pow(10, Math.log10(k_min) + i * (Math.log10(k_max) - Math.log10(k_min)) / n_bins));
                }

                const P_k = new Array(n_bins).fill(0);

                // Compute power for each k
                particleArray.forEach(p => {
                    const k = Math.sqrt(p.x**2 + p.y**2 + p.z**2);

                    frequencies.forEach((freq, idx) => {
                        if (Math.abs(k - freq) < freq * 0.1) {
                            P_k[idx] += p.Ec || 0;
                        }
                    });
                });

                return frequencies.map((freq, idx) => ({
                    frequency: freq,
                    power: P_k[idx]
                }));
            }

            compareToPlanck() {
                // Simplified Planck 2018 CMB parameters
                const planckParams = {
                    H0: 67.4,  // Hubble constant
                    Omega_m: 0.315,  // Matter density
                    Omega_Lambda: 0.685,  // Dark energy density
                    A_s: 2.1e-9,  // Scalar amplitude
                    n_s: 0.965  // Scalar spectral index
                };

                // Extract CST parameters from particle distribution
                const cstParams = this.extractCosmologicalParameters(particles);

                return {
                    planck: planckParams,
                    cst: cstParams,
                    deviations: {
                        H0_deviation: Math.abs(cstParams.H0 - planckParams.H0) / planckParams.H0,
                        matter_deviation: Math.abs(cstParams.Omega_m - planckParams.Omega_m) / planckParams.Omega_m
                    }
                };
            }

            extractCosmologicalParameters(particleArray) {
                const totalEnergy = particleArray.reduce((sum, p) => sum + (p.Ec || 0), 0);
                const darkMatterEnergy = particleArray.filter(p => p.isDarkMatter).reduce((sum, p) => sum + (p.Ec || 0), 0);

                return {
                    H0: 70.0,  // Placeholder
                    Omega_m: totalEnergy > 0 ? darkMatterEnergy / totalEnergy : 0,
                    Omega_Lambda: 0.68,
                    A_s: 2.0e-9,
                    n_s: 0.96
                };
            }

            displayComparison() {
                const comparison = this.compareToPlanck();

                let html = '<h4>Observational Comparison</h4>';
                html += '<table style="width: 100%; font-size: 0.85em;">';
                html += '<tr><th>Parameter</th><th>Planck</th><th>CST</th><th>Deviation</th></tr>';
                html += `<tr><td>H‚ÇÄ</td><td>${comparison.planck.H0}</td><td>${comparison.cst.H0.toFixed(1)}</td><td>${(comparison.deviations.H0_deviation * 100).toFixed(1)}%</td></tr>`;
                html += `<tr><td>Œ©‚Çò</td><td>${comparison.planck.Omega_m.toFixed(3)}</td><td>${comparison.cst.Omega_m.toFixed(3)}</td><td>${(comparison.deviations.matter_deviation * 100).toFixed(1)}%</td></tr>`;
                html += '</table>';

                const display = document.getElementById('observationalDisplay');
                if (display) display.innerHTML = html;
            }
        }

        const obsComparison = new ObservationalComparison();

        // ============================================================================
        // MEMORY DYNAMICS VISUALIZATION (NEW)
        // ============================================================================

        function visualizeMemoryState() {
            if (particles.length === 0) return;

            // Find particle with highest energy
            const maxEnergyParticle = particles.reduce((max, p) =>
                (p.Ec || 0) > (max.Ec || 0) ? p : max
            );

            // Display memory vector
            const memoryDisplay = document.getElementById('memoryStateDisplay');
            if (!memoryDisplay) return;

            let html = '<h4>Top Particle Memory State</h4>';
            html += `<p>Particle ID: ${maxEnergyParticle.id.substring(0, 8)}...</p>`;
            html += `<p>Energy: ${(maxEnergyParticle.Ec || 0).toExponential(2)}</p>`;

            if (maxEnergyParticle.memory && maxEnergyParticle.memory.length > 0) {
                html += '<p>Memory Vector (normalized):</p>';
                html += '<div style="font-family: monospace; font-size: 0.8em;">';

                for (let i = 0; i < Math.min(10, maxEnergyParticle.memory.length); i++) {
                    // Fix: Add bounds checking to prevent negative values in String.repeat()
                    const memValue = maxEnergyParticle.memory[i];
                    const normalized = (typeof memValue === 'number' && isFinite(memValue))
                        ? (memValue / 255).toFixed(3)
                        : '0.000';
                    const barLength = Math.max(0, Math.min(20, Math.round(parseFloat(normalized) * 20)));
                    const emptyLength = Math.max(0, 20 - barLength);
                    const bar = '‚ñà'.repeat(barLength) + '‚ñë'.repeat(emptyLength);
                    html += `[${i}]: ${bar} ${normalized}<br>`;
                }

                html += '</div>';
            } else {
                html += '<p style="color: #ffaa00;">No memory data available</p>';
            }

            memoryDisplay.innerHTML = html;
        }

        // Call in animation loop
        function updateMemoryVisualization() {
            visualizeMemoryState();
        }

        // ============================================================================
        // END NEW ANALYSIS SYSTEMS
        // ============================================================================

        class LorenzParticle {
            constructor(x, y, z, color, frequency = 0, parent = null) {
                this.id = generateUUID();
                this.x = x || 0.1;
                this.y = y || 0;
                this.z = z || 0;
                this.color = color || 0x00d4ff;
                this.frequency = frequency;
                this.energy = 0; // Legacy energy (kept for compatibility)
                this.mass = 1;
                this.velocity = { x: 0, y: 0, z: 0 };
                this.entropy = 0; // Legacy entropy
                this.memory = new Array(10).fill(0);
                this.tokens = []; // Token list per particle
                this.parent = parent; // Track parent for replication
                this.points = [];
                this.maxPoints = 2000;
                this.createdAt = Date.now();
                
                // ============================================================================
                // 12D CST NEW PROPERTIES - COMPLETE IMPLEMENTATION
                // ============================================================================
                // Internal adaptive state (12th dimension)
                this.x12 = 0; // Adaptive state (dimensionless, bounded [-1, 1])
                this.m12 = 0; // Memory of x12
                this.dx12_dt = 0; // Rate of change of internal state
                this.dm12_dt = 0; // Rate of change of memory

                // 12D evolution parameters (Equation 2.11 from paper)
                this.k_adaptation = 0.01;    // Rate constant for interaction-driven changes (1/s)
                this.gamma_decay = 0.005;    // Decay constant for stability (1/s)
                this.alpha_memory = 0.1;     // Memory adaptation rate (1/s)
                this.sigma_similarity = 1.0; // Spread parameter for Gaussian similarity

                // Energy and potential
                this.Ec = 0; // Cosmic energy = kinetic + potential + dark matter
                this.Ugrav = 0; // Gravitational potential energy
                this.Udm = 0; // Dark matter potential contribution
                this.vi = 0; // Characteristic frequency = Ec/h
                this.theta = getRandom() * 2 * Math.PI; // Phase (initialized randomly)

                // Network properties
                this.neighbors = []; // Cached neighbor indices
                this.omega = 0; // Œ©i = synaptic strength (includes Gaussian similarity)
                this.entropyS = 0; // Boltzmann-style coarse-grained entropy

                // State function tracking (œà breakdown - Section 2.8)
                this.total_x12_variation = 0.0; // ‚à´|Œîx‚ÇÅ‚ÇÇ|dt - accumulated over time
                this.total_velocity_integral = 0.0; // ‚à´||v||dt - accumulated over time
                this.psi = 0.0; // Complete 12D state function
                this.x12_history = []; // Track internal state evolution

                // 11D projection
                this.projection11D = {
                    pos11D: new Float64Array(11).fill(0),
                    vel11D: new Float64Array(11).fill(0)
                };

                // Initialize 11D projection (project 3D position to 11D)
                this.update11DProjection();
                
                // Create line geometry
                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({ 
                    color: this.color,
                    transparent: true,
                    opacity: 0.7
                });
                this.line = new THREE.Line(geometry, material);
                scene.add(this.line);
                
                // Add starting glow sphere
                const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: this.color,
                    transparent: true,
                    opacity: 0.8
                });
                this.sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                scene.add(this.sphere);
            }

            // Update 11D projection from 3D position
            // CST v2.0+ additive: Maintains per-particle 11D position/velocity projections
            // Hook for alternative projection maps: orthogonal, random embedding, learned
            update11DProjection() {
                // Use projection mode selector
                if (projectionConfig.mode === 'orthogonal') {
                    orthogonalProjection(this);
                } else if (projectionConfig.mode === 'random_embedding') {
                    randomEmbeddingProjection(this);
                } else if (projectionConfig.mode === 'learned_embedding') {
                    learnedEmbeddingProjection(this);
                } else {
                    // Fallback to orthogonal
                    orthogonalProjection(this);
                }
            }

            update(audioModulation = 1.0, gravAcceleration = null) {
                // === NaN PREVENTION ===
                sanitizeParticleState(this);
                audioModulation = isFinite(audioModulation) && audioModulation > 0 ? audioModulation : 1.0;

                // Audio-modulated Lorenz equations
                const effectiveSigma = sigma * (1 + audioModulation * 0.5);
                const effectiveRho = rho * (1 + audioModulation * 0.3);
                
                const dxLorenz = effectiveSigma * (this.y - this.x) * timestep.dt;
                const dyLorenz = (this.x * (effectiveRho - this.z) - this.y) * timestep.dt;
                const dzLorenz = (this.x * this.y - beta * this.z) * timestep.dt;

                // Blend Lorenz and gravitational accelerations
                let dx, dy, dz;
                if (gravAcceleration && physics.gravEnabled) {
                    const dxGrav = gravAcceleration.x * timestep.dt;
                    const dyGrav = gravAcceleration.y * timestep.dt;
                    const dzGrav = gravAcceleration.z * timestep.dt;
                    
                    dx = physics.blendLorenz * dxLorenz + (1 - physics.blendLorenz) * dxGrav;
                    dy = physics.blendLorenz * dyLorenz + (1 - physics.blendLorenz) * dyGrav;
                    dz = physics.blendLorenz * dzLorenz + (1 - physics.blendLorenz) * dzGrav;
                } else {
                    dx = dxLorenz;
                    dy = dyLorenz;
                    dz = dzLorenz;
                }

                this.x += dx;
                this.y += dy;
                this.z += dz;

                // Update velocity
                this.velocity = { x: dx / timestep.dt, y: dy / timestep.dt, z: dz / timestep.dt };
                
                // Update 11D projection
                this.update11DProjection();

                // Store point
                this.points.push(new THREE.Vector3(this.x, this.y, this.z));
                
                if (this.points.length > this.maxPoints) {
                    this.points.shift();
                }

                // Update geometry
                // CST v2.0+ fix: Properly handle geometry updates when point count changes
                const pointCount = this.points.length;
                if (pointCount > 0) {
                    const positions = new Float32Array(pointCount * 3);
                    for (let i = 0; i < pointCount; i++) {
                        positions[i * 3] = this.points[i].x;
                        positions[i * 3 + 1] = this.points[i].y;
                        positions[i * 3 + 2] = this.points[i].z;
                    }
                    
                    // Update or create position attribute
                    if (this.line.geometry.attributes.position) {
                        // Update existing attribute if size matches
                        if (this.line.geometry.attributes.position.count === pointCount) {
                            this.line.geometry.attributes.position.array.set(positions);
                            this.line.geometry.attributes.position.needsUpdate = true;
                        } else {
                            // Recreate if size changed - Three.js will dispose old attribute automatically
                            this.line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        }
                    } else {
                        // Create new attribute
                        this.line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    }
                    // Set draw range to ensure only valid points are rendered
                    this.line.geometry.setDrawRange(0, pointCount);
                }

                // Update sphere position
                this.sphere.position.set(this.x, this.y, this.z);

                // Calculate cosmic energy: Ec = 0.5 * m * v^2 * c^2 (relativistic-inspired)
                const velocityMagnitude = Math.sqrt(dx*dx + dy*dy + dz*dz) / timestep.dt;
                this.energy = 0.5 * this.mass * velocityMagnitude * velocityMagnitude;
                
                // Update entropy based on trajectory complexity
                this.entropy = Math.log(this.points.length + 1) * this.energy;

                // Note: œà integrals (‚à´||v|| dt, ‚à´|Œîx‚ÇÅ‚ÇÇ| dt) are accumulated in updatePsiNormalized()
                // which is called after all particles are updated for efficiency

                // Check for replication
                this.checkReplication();

                // === POST-UPDATE NaN CHECK ===
                sanitizeParticleState(this);

                return { dx, dy, dz };
            }

            checkReplication() {
                // Replication when Ec and omega exceed thresholds
                const energyThreshold = this.Ec > replicationThreshold;
                const omegaThreshold = this.omega > 0.1; // Minimum synaptic strength
                
                if (energyThreshold && omegaThreshold && particles.length < 30) {
                    // Create offspring particle
                    const offset = (getRandom() * 2 - 1) * 0.5;
                    const color = new THREE.Color(this.color);
                    color.offsetHSL(0.1, 0, 0); // Slight color variation
                    
                    const offspring = new LorenzParticle(
                        this.x + offset,
                        this.y + offset,
                        this.z + offset,
                        color.getHex(),
                        this.frequency * (1 + (getRandom() * 0.1 - 0.05)), // Slight frequency mutation
                        this.id // Set parent
                    );
                    
                    offspring.mass = this.mass * (0.95 + getRandom() * 0.1);
                    offspring.x12 = this.x12 + (getRandom() * 0.2 - 0.1); // Inherit with variation
                    offspring.m12 = this.m12;
                    
                    // Split energy
                    this.Ec *= 0.5;
                    offspring.Ec = this.Ec;
                    this.energy *= 0.5; // Legacy
                    offspring.energy = this.energy;
                    
                    particles.push(offspring);
                    replicationCount++;
            
                    // Generate replication token for offspring
                    generateParticleToken(offspring, 'replication');
                    
                    updateStatus(`Particle ${this.id.substr(0, 8)} replicated ‚Üí ${offspring.id.substr(0, 8)}`);
                }
            }

            assignFrequency(freq, magnitude) {
                this.frequency = freq;
                // Additive: fixed token hygiene - use object instead of string
                const tokenObj = {
                    id: nextDeterministicId(),
                    type: 'frequency_assignment',
                    frequency: freq,
                    magnitude: magnitude,
                    particleId: this.id,
                    timestamp: Date.now() / 1000,
                    eventType: 'frequency_assignment'
                };
                this.tokens.push(tokenObj);
            }

            /**
             * Update 12th dimension internal state and memory
             * Implements evolution equations from Section 2.11 of the 12D CST paper
             *
             * @param {number} Omega_i - Total synaptic strength for this particle
             * @param {number} dt - Time step (seconds)
             *
             * Evolution equations:
             *   dx‚ÇÅ‚ÇÇ/dt = k¬∑Œ©·µ¢ - Œ≥¬∑x‚ÇÅ‚ÇÇ  (Equation 2.11)
             *   dm‚ÇÅ‚ÇÇ/dt = Œ±¬∑(x‚ÇÅ‚ÇÇ - m‚ÇÅ‚ÇÇ)  (Memory adaptation)
             */
            update12thDimension(Omega_i, dt) {
                // Validate inputs
                if (!isFinite(Omega_i) || !isFinite(dt)) {
                    console.warn('Invalid inputs to update12thDimension:', { Omega_i, dt });
                    return;
                }

                // Evolution equation: dx12/dt = k¬∑Œ© - Œ≥¬∑x12 (Equation 2.11)
                // This drives internal state toward high connectivity (high Œ©) while decay provides stability
                this.dx12_dt = this.k_adaptation * Omega_i - this.gamma_decay * this.x12;

                // Update internal state using forward Euler integration
                this.x12 += this.dx12_dt * dt;

                // Clamp to reasonable bounds [-1, 1] to prevent runaway
                this.x12 = Math.max(-1, Math.min(1, this.x12));

                // Track total variation for œà calculation: ‚à´|Œîx‚ÇÅ‚ÇÇ|dt (Section 2.8, Term 4)
                this.total_x12_variation += Math.abs(this.dx12_dt) * dt;

                // Memory evolution: dm12/dt = Œ±¬∑(x12 - m12)
                // Memory tracks internal state with time constant œÑ = 1/Œ±
                this.dm12_dt = this.alpha_memory * (this.x12 - this.m12);
                this.m12 += this.dm12_dt * dt;

                // Clamp memory as well
                this.m12 = Math.max(-1, Math.min(1, this.m12));

                // Store history for analysis (limit to prevent memory issues)
                this.x12_history.push(this.x12);
                if (this.x12_history.length > 1000) {
                    this.x12_history.shift(); // Keep last 1000 values
                }
            }

            destroy() {
                scene.remove(this.line);
                scene.remove(this.sphere);
                this.line.geometry.dispose();
                this.line.material.dispose();
                this.sphere.geometry.dispose();
                this.sphere.material.dispose();
            }
        }

        // ============================================================================
        // 12D CST CORE ALGORITHMS
        // ============================================================================
        
        // 1) Spatial indexing for neighbor queries
        function buildSpatialIndex(particles, rCutoff) {
            // Simple uniform grid spatial index (3D)
            const cellSize = rCutoff;
            const grid = new Map();
            
            particles.forEach((p, i) => {
                const gx = Math.floor(p.x / cellSize);
                const gy = Math.floor(p.y / cellSize);
                const gz = Math.floor(p.z / cellSize);
                const key = `${gx},${gy},${gz}`;
                
                if (!grid.has(key)) {
                    grid.set(key, []);
                }
                grid.get(key).push(i);
            });
            
            return { grid, cellSize };
        }

        function queryNeighbors(i, particles, index, rCutoff) {
            const p = particles[i];
            const neighbors = [];
            const cellSize = index.cellSize;
            
            // Check current cell and 26 neighboring cells
            const gx = Math.floor(p.x / cellSize);
            const gy = Math.floor(p.y / cellSize);
            const gz = Math.floor(p.z / cellSize);
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        const key = `${gx + dx},${gy + dy},${gz + dz}`;
                        const cell = index.grid.get(key);
                        if (cell) {
                            cell.forEach(j => {
                                if (i !== j) {
                                    const pj = particles[j];
                                    const dx2 = pj.x - p.x;
                                    const dy2 = pj.y - p.y;
                                    const dz2 = pj.z - p.z;
                                    const r = Math.sqrt(dx2*dx2 + dy2*dy2 + dz2*dz2);
                                    if (r <= rCutoff) {
                                        neighbors.push(j);
                                    }
                                }
                            });
                        }
                    }
                }
            }
            
            return neighbors;
        }

        // 2) Gravitational forces and energies
        function computeGravitationalAccelerations(particles, index, physics) {
            const accelerations = particles.map(() => ({ x: 0, y: 0, z: 0 }));
            
            if (!physics.gravEnabled) return accelerations;
            
            particles.forEach((pi, i) => {
                const neighbors = queryNeighbors(i, particles, index, physics.rCutoff);
                
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - pi.x;
                    const dy = pj.y - pi.y;
                    const dz = pj.z - pi.z;
                    const r2 = dx*dx + dy*dy + dz*dz;
                    const r_eff2 = r2 + physics.epsilon * physics.epsilon;
                    const r_eff = Math.sqrt(r_eff2);
                    
                    const force = physics.G * pi.mass * pj.mass / r_eff2;
                    const fx = force * (dx / r_eff);
                    const fy = force * (dy / r_eff);
                    const fz = force * (dz / r_eff);
                    
                    accelerations[i].x += fx / pi.mass;
                    accelerations[i].y += fy / pi.mass;
                    accelerations[i].z += fz / pi.mass;
                });
            });

            // === DARK MATTER FORCE CONTRIBUTION ===
            if (physics.dmEnabled) {
                particles.forEach((pi, i) => {
                    // Compute numerical gradient of dark matter potential
                    const h = 0.01; // Small step for numerical derivative

                    // Current position
                    const r = Math.sqrt(pi.x*pi.x + pi.y*pi.y + pi.z*pi.z) + physics.epsilon;

                    // Compute potential at current position
                    const r_rs = r / dmParams.rs;
                    const rho = r_rs > 1e-10 ? dmParams.rho0 / (r_rs * Math.pow(1 + r_rs, 2)) : 0;
                    const U_current = -physics.G * pi.mass * rho * 4 * Math.PI * r * r / 3;

                    // Compute potential gradient using finite differences
                    // ‚àáU = (‚àÇU/‚àÇx, ‚àÇU/‚àÇy, ‚àÇU/‚àÇz)
                    // F = -‚àáU

                    // X direction
                    const rx_plus = Math.sqrt((pi.x+h)*(pi.x+h) + pi.y*pi.y + pi.z*pi.z) + physics.epsilon;
                    const r_rs_x = rx_plus / dmParams.rs;
                    const rho_x = r_rs_x > 1e-10 ? dmParams.rho0 / (r_rs_x * Math.pow(1 + r_rs_x, 2)) : 0;
                    const U_x = -physics.G * pi.mass * rho_x * 4 * Math.PI * rx_plus * rx_plus / 3;
                    const dU_dx = (U_x - U_current) / h;

                    // Y direction
                    const ry_plus = Math.sqrt(pi.x*pi.x + (pi.y+h)*(pi.y+h) + pi.z*pi.z) + physics.epsilon;
                    const r_rs_y = ry_plus / dmParams.rs;
                    const rho_y = r_rs_y > 1e-10 ? dmParams.rho0 / (r_rs_y * Math.pow(1 + r_rs_y, 2)) : 0;
                    const U_y = -physics.G * pi.mass * rho_y * 4 * Math.PI * ry_plus * ry_plus / 3;
                    const dU_dy = (U_y - U_current) / h;

                    // Z direction
                    const rz_plus = Math.sqrt(pi.x*pi.x + pi.y*pi.y + (pi.z+h)*(pi.z+h)) + physics.epsilon;
                    const r_rs_z = rz_plus / dmParams.rs;
                    const rho_z = r_rs_z > 1e-10 ? dmParams.rho0 / (r_rs_z * Math.pow(1 + r_rs_z, 2)) : 0;
                    const U_z = -physics.G * pi.mass * rho_z * 4 * Math.PI * rz_plus * rz_plus / 3;
                    const dU_dz = (U_z - U_current) / h;

                    // Apply dark matter force: F = -‚àáU, a = F/m
                    accelerations[i].x -= dU_dx / pi.mass;
                    accelerations[i].y -= dU_dy / pi.mass;
                    accelerations[i].z -= dU_dz / pi.mass;
                });
            }

            return accelerations;
        }

        function computeGravitationalEnergy(particles, index, physics) {
            if (!physics.gravEnabled) {
                particles.forEach(p => p.Ugrav = 0);
                return;
            }
            
            particles.forEach((pi, i) => {
                let U = 0;
                const neighbors = queryNeighbors(i, particles, index, physics.rCutoff);
                
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - pi.x;
                    const dy = pj.y - pi.y;
                    const dz = pj.z - pi.z;
                    const r2 = dx*dx + dy*dy + dz*dz;
                    const r_eff = Math.sqrt(r2 + physics.epsilon * physics.epsilon);
                    
                    U -= physics.G * pi.mass * pj.mass / r_eff;
                });
                
                pi.Ugrav = U;
            });
        }

        // Implements Section 2.7: Dark Matter Integration
        function computeDarkMatterPotential(particles, dmParams) {
            if (!physics.dmEnabled) {
                particles.forEach(p => p.Udm = 0);
                return;
            }

            particles.forEach(p => {
                // CST v2.0+ fix: Add epsilon to avoid division by zero at r=0
                const r = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z) + physics.epsilon;
                const r_rs = r / dmParams.rs;

                // Paper Section 2.7: NFW density profile
                // œÅ_DM(r) = œÅ‚ÇÄ / ((r/rs) ¬∑ (1 + r/rs)¬≤)
                const rho = r_rs > 1e-10 ? dmParams.rho0 / (r_rs * Math.pow(1 + r_rs, 2)) : 0;

                // Dark matter contribution to gravitational potential
                // ŒîE_dark,i = -‚à´‚ÇÄ^ri G¬∑m·µ¢¬∑œÅ_DM(r')¬∑4œÄr'¬≤/r' dr'
                // Simplified: Udm ‚âà -G ¬∑ m ¬∑ œÅ ¬∑ 4œÄ ¬∑ r¬≤ / 3
                p.Udm = -physics.G * p.mass * rho * 4 * Math.PI * r * r / 3;
            });
        }

        /**
         * Compute Enhanced Synaptic Strength with Internal State Similarity
         * Implements Section 2.11 of the 12D CST paper
         *
         * Key innovation: Connection strength depends on BOTH gravitational coupling
         * AND cognitive similarity (Gaussian kernel on internal state difference)
         * This creates Hebbian-like learning: "neurons that fire together, wire together"
         *
         * @param {Array} particles - Array of all particles
         * @param {Object} index - Spatial index for neighbor queries
         * @param {Object} physics - Physics parameters
         * @param {Object} adapt - Adaptation parameters (fallback values)
         */
        function computeSynapticStrength(particles, index, physics, adapt) {
            particles.forEach((pi, i) => {
                let omegaSum = 0;
                const neighbors = queryNeighbors(i, particles, index, physics.rCutoff);
                pi.neighbors = neighbors;

                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - pi.x;
                    const dy = pj.y - pi.y;
                    const dz = pj.z - pi.z;
                    const r2 = dx*dx + dy*dy + dz*dz;
                    const r_eff2 = r2 + physics.epsilon * physics.epsilon;

                    // Paper Section 2.11: Synaptic strength with internal state similarity
                    // Œ©_ij = (G¬∑m·µ¢¬∑m‚±º)/(r_ij¬≤¬∑a‚ÇÄ¬∑m‚ÇÄ) ¬∑ exp(-(x‚ÇÅ‚ÇÇ,·µ¢ - x‚ÇÅ‚ÇÇ,‚±º)¬≤/(2œÉ¬≤))

                    // Gravitational coupling (normalized to be dimensionless)
                    // Use safe division to prevent NaN
                    const mi = isFinite(pi.mass) && pi.mass > 0 ? pi.mass : 1;
                    const mj = isFinite(pj.mass) && pj.mass > 0 ? pj.mass : 1;
                    const gravTerm = safeDivide(
                        physics.G * mi * mj,
                        r_eff2 * physics.a0 * physics.m0,
                        0
                    );

                    // Gaussian similarity measure
                    const sigma = pi.sigma_similarity || adapt.sigmaSimilarity || 1.0;
                    const x12_i = isFinite(pi.x12) ? pi.x12 : 0;
                    const x12_j = isFinite(pj.x12) ? pj.x12 : 0;
                    const x12Diff = x12_i - x12_j;
                    const sigmaSq = sigma * sigma;
                    const expArg = safeDivide(-(x12Diff * x12Diff), 2 * sigmaSq, 0);
                    const similarity = safeExp(expArg, 1, 1);

                    // Combined synaptic strength
                    const omega_ij = gravTerm * similarity;

                    // Validate result
                    if (isFinite(omega_ij) && omega_ij >= 0) {
                        omegaSum += omega_ij;
                    }
                });

                pi.omega = isFinite(omegaSum) && omegaSum >= 0 ? omegaSum : 0;
            });
        }

        /**
         * Update 12th dimension evolution and memory for all particles
         * Implements Section 2.9: Internal State Evolution Dynamics
         *
         * Now uses particle-specific update12thDimension() method for consistency
         */
        function updateAdaptiveStates(particles, adapt, dt) {
            particles.forEach(p => {
                // Use the particle's update12thDimension method which implements:
                // - dx‚ÇÅ‚ÇÇ/dt = k¬∑Œ©·µ¢ - Œ≥¬∑x‚ÇÅ‚ÇÇ  (Equation 2.11)
                // - dm‚ÇÅ‚ÇÇ/dt = Œ±¬∑(x‚ÇÅ‚ÇÇ - m‚ÇÅ‚ÇÇ)  (Memory adaptation)
                // - Accumulation of ‚à´|Œîx‚ÇÅ‚ÇÇ|dt for œà calculation
                p.update12thDimension(p.omega, dt);

                // Track velocity integral for œà calculation (Section 2.8, Term 3)
                const velocityMag = Math.sqrt(
                    p.velocity.x * p.velocity.x +
                    p.velocity.y * p.velocity.y +
                    p.velocity.z * p.velocity.z
                );
                if (isFinite(velocityMag)) {
                    p.total_velocity_integral += velocityMag * dt;
                }

                // === NEURAL NETWORK ENERGY MODULATION ===
                if (neuralConfig.enabled && p.neighbors && p.neighbors.length > 0) {
                    // Prepare input: memory (10D) + top 5 frequency components
                    const memoryInput = p.memory.slice(0, 10);
                    const topFrequencies = (frequencyData || []).slice(0, 5);
                    const freqInput = topFrequencies.map(f => f.magnitude || 0);
                    const neuralInput = [...memoryInput, ...freqInput];

                    // Pad to 15 if needed
                    while (neuralInput.length < 15) {
                        neuralInput.push(0);
                    }

                    // Forward pass
                    const [deltaAlpha, deltaEnergy] = neuralAdapter.forward(neuralInput);

                    // Apply energy adjustment
                    const inputMean = neuralInput.reduce((a, b) => a + b, 0) / neuralInput.length;
                    const adjustment = neuralConfig.sensitivity * deltaEnergy * (inputMean - p.Ec / 100);
                    p.Ec += adjustment;
                    p.Ec = Math.max(0.01, p.Ec); // Ensure positive energy

                    // Training: target should maintain energy conservation
                    // Simple training rule: minimize deviation from average neighbor energy
                    if (p.neighbors.length > 0) {
                        const avgNeighborEnergy = p.neighbors
                            .map(j => particles[j].Ec)
                            .reduce((a, b) => a + b, 0) / p.neighbors.length;
                        const targetDeltaEnergy = (avgNeighborEnergy - p.Ec) / 100;
                        neuralAdapter.backward([0, targetDeltaEnergy]);
                    }
                }
            });
        }

        // Implements Section 2.6 (Frequency) and Kuramoto-style Synchronization
        function updatePhases(particles, sync, index, dt) {
            particles.forEach((pi, i) => {
                // Paper Section 2.6: Characteristic frequency
                // ŒΩ·µ¢ = E_c,i / h (where h is Planck's constant)
                pi.vi = pi.Ec / h;

                // Kuramoto-style phase coupling (adapted from Kuramoto model)
                // Paper mentions: dŒ∏·µ¢/dt = œâ·µ¢ + (K_sync/N) Œ£‚±º sin(Œ∏‚±º - Œ∏·µ¢)
                // Implementation uses local degree instead of N for sparse networks
                let phaseCoupling = 0;
                const neighbors = pi.neighbors || queryNeighbors(i, particles, index, physics.rCutoff);
                const degree = Math.max(1, neighbors.length);

                neighbors.forEach(j => {
                    const pj = particles[j];
                    phaseCoupling += Math.sin(pj.theta - pi.theta);
                });

                // dŒ∏·µ¢/dt = œâ·µ¢ + (K_sync/degree) Œ£‚±º sin(Œ∏‚±º ‚àí Œ∏·µ¢)
                const dtheta = (pi.vi + (sync.Ksync / degree) * phaseCoupling) * dt;
                pi.theta += dtheta;

                // Keep theta in [0, 2œÄ]
                pi.theta = ((pi.theta % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            });

            // === SYNCHRONIZATION FORCE FEEDBACK ===
            // Particles feel a force based on how synchronized they are with global phase
            if (sync.Ksync > 0 && particles.length > 1) {
                // Compute global synchronization order parameter
                const syncMetric = computeSynchronizationMetric(particles);
                const orderParameter = syncMetric.r;
                const globalPhase = syncMetric.meanTheta;

                if (orderParameter > 0.1) {
                    particles.forEach((p, i) => {
                        const phaseDiff = p.theta - globalPhase;
                        const syncForce = sync.Ksync * orderParameter * Math.sin(phaseDiff);

                        // Apply synchronization force as modulation to velocity
                        // This creates emergent synchronized motion
                        const forceMag = syncForce * 0.1;
                        p.velocity.x += forceMag * Math.cos(p.theta);
                        p.velocity.y += forceMag * Math.sin(p.theta);
                        p.velocity.z += forceMag * Math.cos(phaseDiff);
                    });
                }
            }
        }

        // CST v2.5+ ULTIMATE ENHANCEMENT: 12D Quantum-Correlated Synchronization Metrics
        function computeSynchronizationMetric(particles) {
            if (particles.length === 0) return {
                r: 0,
                meanTheta: 0,
                R_freq: 0,
                R_omega: 0,
                R_psi: 0,
                x12_clustering: 0
            };

            const N = particles.length;

            // === ORIGINAL THETA SYNCHRONIZATION (Kuramoto order parameter) ===
            let sumReal = 0;
            let sumImag = 0;

            particles.forEach(p => {
                sumReal += Math.cos(p.theta);
                sumImag += Math.sin(p.theta);
            });

            const r = Math.sqrt(sumReal*sumReal + sumImag*sumImag) / N;
            const meanTheta = Math.atan2(sumImag, sumReal);

            // === 12D FREQUENCY SYNCHRONIZATION (nu alignment) ===
            // R_freq = |Œ£ exp(i * 2œÄ * nu_j / <nu>)| / N
            let freqSumReal = 0;
            let freqSumImag = 0;
            const avgNu = particles.reduce((sum, p) => sum + (isFinite(p.nu) ? p.nu : 0), 0) / N;
            const safeAvgNu = Math.abs(avgNu) > 1e-10 ? avgNu : 1e-10;

            particles.forEach(p => {
                const nu = isFinite(p.nu) ? p.nu : 0;
                const phase = (2 * Math.PI * nu) / safeAvgNu;
                freqSumReal += Math.cos(phase);
                freqSumImag += Math.sin(phase);
            });

            const R_freq = Math.sqrt(freqSumReal**2 + freqSumImag**2) / N;

            // === OMEGA COHERENCE (synaptic strength synchronization) ===
            // R_omega = 1 - std(omega) / mean(omega) [higher = more synchronized]
            const omegaValues = particles.map(p => isFinite(p.omega) ? p.omega : 0);
            const meanOmega = omegaValues.reduce((a, b) => a + b, 0) / N;
            const stdOmega = Math.sqrt(omegaValues.reduce((sum, o) => sum + (o - meanOmega)**2, 0) / N);
            const safeMeanOmega = Math.abs(meanOmega) > 1e-10 ? meanOmega : 1e-10;
            const R_omega = Math.max(0, 1 - stdOmega / safeMeanOmega);

            // === PSI PHASE LOCKING (normalized state function alignment) ===
            // R_psi = |Œ£ exp(i * angle(psi_j))| / N
            let psiSumReal = 0;
            let psiSumImag = 0;

            particles.forEach(p => {
                const psi = isFinite(p.psi) ? p.psi : 0;
                // Normalize psi to phase angle
                const psiPhase = Math.atan2(psi, 1); // Map to [-œÄ/2, œÄ/2]
                psiSumReal += Math.cos(psiPhase);
                psiSumImag += Math.sin(psiPhase);
            });

            const R_psi = Math.sqrt(psiSumReal**2 + psiSumImag**2) / N;

            // === X12 CLUSTERING (12D position synchronization) ===
            // Measure variance of x12 distribution (lower = more clustered)
            const x12Values = particles.map(p => isFinite(p.x12) ? p.x12 : 0);
            const meanX12 = x12Values.reduce((a, b) => a + b, 0) / N;
            const varianceX12 = x12Values.reduce((sum, x) => sum + (x - meanX12)**2, 0) / N;
            // Convert to clustering metric: 0 = no clustering, 1 = perfect clustering
            const x12_clustering = Math.max(0, 1 - Math.sqrt(varianceX12));

            // === COMBINED 12D-ENHANCED ORDER PARAMETER ===
            // Weighted combination of all synchronization measures
            const r_combined = 0.40 * r + 0.25 * R_freq + 0.15 * R_omega + 0.10 * R_psi + 0.10 * x12_clustering;

            return {
                r: r_combined,              // Combined 12D-enhanced order parameter
                meanTheta,                  // Mean phase angle
                R_freq,                     // Frequency synchronization
                R_omega,                    // Omega coherence
                R_psi,                      // Psi phase locking
                x12_clustering              // X12 clustering measure
            };
        }

        // 7) Entropy via coarse-graining
        function computeEntropy(particles, kB, bins = 32) {
            if (particles.length === 0) return 0;
            
            // Bin particle speeds
            const speeds = particles.map(p => {
                const v = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                return v;
            });
            
            const maxSpeed = Math.max(...speeds, 1);
            const histogram = new Array(bins).fill(0);
            
            speeds.forEach(v => {
                const bin = Math.min(bins - 1, Math.floor((v / maxSpeed) * bins));
                histogram[bin]++;
            });
            
            // Shannon entropy: S = -kB Œ£ p_b ln p_b
            let S = 0;
            histogram.forEach(count => {
                if (count > 0) {
                    const p = count / particles.length;
                    S -= p * Math.log(p);
                }
            });
            
            const entropy = kB * S;
            
            // Update per-particle entropy (use global for now)
            particles.forEach(p => {
                p.entropyS = entropy;
            });
            
            return entropy;
        }

        // 8) Energy and conservation diagnostics
        function computeConservationStats(particles) {
            let Etotal = 0;
            const P = { x: 0, y: 0, z: 0 };
            const L = { x: 0, y: 0, z: 0 };
            
            particles.forEach(p => {
                // Kinetic energy
                const v2 = p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z;
                const K = 0.5 * p.mass * v2;
                
                // Cosmic energy: Ec = K + Ugrav + Udm
                p.Ec = K + p.Ugrav + p.Udm;
                Etotal += p.Ec;
                
                // Momentum
                P.x += p.mass * p.velocity.x;
                P.y += p.mass * p.velocity.y;
                P.z += p.mass * p.velocity.z;
                
                // Angular momentum: L = r √ó (m v)
                L.x += p.mass * (p.y * p.velocity.z - p.z * p.velocity.y);
                L.y += p.mass * (p.z * p.velocity.x - p.x * p.velocity.z);
                L.z += p.mass * (p.x * p.velocity.y - p.y * p.velocity.x);
            });
            
            // Compute drift
            const now = Date.now();
            const timeDiff = (now - conservationStats.lastUpdate) / 1000;
            let drift = { E: 0, P: 0, L: 0 };
            
            if (conservationStats.E0 !== 0 && timeDiff > 0) {
                drift.E = Math.abs((Etotal - conservationStats.E0) / conservationStats.E0);
                const P0mag = Math.sqrt(conservationStats.P0.x**2 + conservationStats.P0.y**2 + conservationStats.P0.z**2);
                const Pmag = Math.sqrt(P.x**2 + P.y**2 + P.z**2);
                if (P0mag > 0) {
                    drift.P = Math.abs((Pmag - P0mag) / P0mag);
                }
                const L0mag = Math.sqrt(conservationStats.L0.x**2 + conservationStats.L0.y**2 + conservationStats.L0.z**2);
                const Lmag = Math.sqrt(L.x**2 + L.y**2 + L.z**2);
                if (L0mag > 0) {
                    drift.L = Math.abs((Lmag - L0mag) / L0mag);
        }
            }

            // Additive: advance timestamp after drift calculation for coherent time window
            conservationStats.lastUpdate = now;

            return { Etotal, P, L, drift };
        }
        
        function checkVirial(particles) {
            let Ksum = 0;
            let Usum = 0;
            
            particles.forEach(p => {
                const v2 = p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z;
                Ksum += 0.5 * p.mass * v2;
                Usum += p.Ugrav + p.Udm;
            });
            
            // Virial: 2<K> ‚âà -<U>
            const ratio = Math.abs(Usum) > 1e-10 ? (2 * Ksum) / Math.abs(Usum) : 1;
            const ok = Math.abs(ratio - 1) < 0.1; // Within 10% tolerance
            
            return { ratio, ok };
        }

        // --- NEW: œà term computation helpers (dimensionless) ---
        // Normalize a value safely by a reference; fallback to 1 to avoid NaN.
        function safeNormalize(value, ref) {
            const r = (typeof ref === 'number' && ref !== 0) ? ref : 1;
            const v = (typeof value === 'number' && isFinite(value)) ? value : 0;
            return v / r;
        }

        // Compute Œª (Lyapunov-like) from audio chaos and system derivatives
        function computeLambdaTerm(audioChaos, chaosDerivativeSum) {
            // Œª = log(1 + chaosDerivativeSum) / scale + audioChaos contribution
            const scale = 100; // mild normalization
            const base = Math.log(Math.abs(chaosDerivativeSum) + 1) / scale;
            return base + (isFinite(audioChaos) ? audioChaos : 0);
        }

        // Compute Œ© term = Œ£_i Œ©_i ¬∑ (Ec/Eref)
        // Compute omega term Œ©¬∑(Ec/Eref) for œà normalized breakdown
        // Per Section 2.11: Synaptic strength weighted by normalized cosmic energy
        function computeOmegaTerm(particles, Eref) {
            let sum = 0;
            for (const p of particles) {
                const normE = safeNormalize(p.Ec, Eref);
                const omega = (typeof p.omega === 'number' && isFinite(p.omega)) ? p.omega : 0;
                // Œ© term = Œ£·µ¢ Œ©·µ¢ ¬∑ (Ec,i / Eref) - synaptic strength weighted by energy
                sum += omega * normE;
            }
            return sum;
        }

        // Compute potential term (Ugrav+Udm)/Eref for œà normalized breakdown
        // Per Sections 2.6-2.7: 11D gravitational potential + dark matter contribution
        function computePotentialTerm(particles, Eref) {
            let sum = 0;
            for (const p of particles) {
                // U11D = Ugrav (gravitational) + Udm (dark matter NFW profile)
                const U = ((p.Ugrav || 0) + (p.Udm || 0));
                // Normalize by reference energy for dimensionless term
                sum += safeNormalize(U, Eref);
            }
            return sum;
        }

        // Compute energy term œÜ ¬∑ (Ec/Eref)
        function computeEnergyTerm(particles, Eref) {
            let sum = 0;
            for (const p of particles) {
                sum += phi * safeNormalize(p.Ec, Eref);
            }
            return sum;
        }

        // 9) œà normalization and breakdown
        // Implements complete œà function: œà = œÜ¬∑(Ec/Eref) + Œª + ‚à´||v||dt/vref + ‚à´|Œîx12|dt + Œ©¬∑(Ec/Eref) + (Ugrav+Udm)/Eref
        // Per Sections 2.5-2.12: All terms computed per particle and aggregated for normalized breakdown
        // CST v2.0+ fix: Corrected ‚à´|Œîx12|dt calculation to properly integrate rate of change
        function updatePsiNormalized(particles, refs, accum) {
            const terms = {
                energyTerm: 0,
                lambdaTerm: 0,
                velocityIntegralTerm: 0,
                x12IntegralTerm: 0,
                omegaTerm: 0,
                potentialTerm: 0
            };
            
            if (particles.length === 0) {
                return { terms, psiTotal: 0 };
            }
            
            // Accumulate ‚à´||v|| dt and ‚à´|Œîx12| dt per particle
            let chaosDerivativeSum = 0;
            
            particles.forEach((p, i) => {
                // CST v2.0+ fix: Use particle ID as key for stable accumulator indexing
                const pid = p.id;
                
                const vMag = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                chaosDerivativeSum += Math.abs(vMag);
                
                // Update velocity integral accumulator: ‚à´||v|| dt normalized by vref
                const vIntPrev = accum.velocityIntegral.get(pid) || 0;
                const vIntNew = vIntPrev + safeNormalize(vMag, refs.vref) * timestep.dt;
                accum.velocityIntegral.set(pid, vIntNew);
                
                // Update x12 integral accumulator: ‚à´|dx‚ÇÅ‚ÇÇ/dt| dt (dimensionless)
                // Per Section 2.11: Integrate the absolute rate of change of internal state
                const x12Prev = accum.x12Previous.get(pid);
                if (x12Prev !== undefined) {
                    // deltaX12 = |x12(t) - x12(t-dt)| = |dx12|
                    // The integral is: ‚à´|dx‚ÇÅ‚ÇÇ/dt| dt = Œ£ |dx12/dt| * dt = Œ£ |dx12|
                    const deltaX12 = Math.abs(p.x12 - x12Prev);
                    const x12IntPrev = accum.x12Integral.get(pid) || 0;
                    // CST v2.0+ fix: Don't multiply by dt again (already in deltaX12)
                    const x12IntNew = x12IntPrev + deltaX12;
                    accum.x12Integral.set(pid, x12IntNew);
                } else {
                    // First frame: initialize accumulator
                    accum.x12Integral.set(pid, 0);
                }
                accum.x12Previous.set(pid, p.x12); // Store current x12 for next frame
            });
            
            // Compute dimensionless terms using helper functions
            terms.energyTerm = computeEnergyTerm(particles, refs.Eref);
            terms.lambdaTerm = computeLambdaTerm(isAudioActive ? calculateAudioChaos() : 0, chaosDerivativeSum);
            terms.velocityIntegralTerm = Array.from(accum.velocityIntegral.values()).reduce((a, b) => a + b, 0);
            terms.x12IntegralTerm = Array.from(accum.x12Integral.values()).reduce((a, b) => a + b, 0);
            terms.omegaTerm = computeOmegaTerm(particles, refs.Eref);
            terms.potentialTerm = computePotentialTerm(particles, refs.Eref);

            // CST v2.0+ additive: Compute average and max ‚à´|Œîx‚ÇÅ‚ÇÇ|dt per particle for diagnostics
            const x12IntValues = Array.from(accum.x12Integral.values());
            const x12IntAvg = x12IntValues.length > 0 ? x12IntValues.reduce((a, b) => a + b, 0) / x12IntValues.length : 0;
            const x12IntMax = x12IntValues.length > 0 ? Math.max(...x12IntValues) : 0;

            const psiTotal = terms.energyTerm + terms.lambdaTerm + terms.velocityIntegralTerm +
                           terms.x12IntegralTerm + terms.omegaTerm + terms.potentialTerm;

            return { terms, psiTotal, x12IntAvg, x12IntMax };
        }

        /**
         * Compute complete 12D state function (œà) for a single particle
         * Implements Section 2.8 of the 12D CST paper
         *
         * œà = œÜ¬∑(Ec/c¬≤) + Œª + ‚à´||v||dt + ‚à´|Œîx‚ÇÅ‚ÇÇ|dt + Œ©¬∑Ec + (Ugrav+Udm)
         *
         * @param {Object} particle - The particle to compute œà for
         * @param {number} phi - Golden ratio (1.618...)
         * @param {number} c - Speed of light
         * @returns {number} Complete 12D state function value
         */
        function computeParticlePsi(particle, phi = 1.618033988749895, c = 3.0e8) {
            // Term 1: œÜ¬∑Ec/c¬≤ (mass-energy equivalence term scaled by golden ratio)
            const Ec = isFinite(particle.Ec) && particle.Ec > 0 ? particle.Ec : 0.01;
            const term1 = safeDivide(phi * Ec, c * c, 0);

            // Term 2: Œª (cosmological constant / chaos term - normalized)
            const lambda = isFinite(particle.lambda) ? particle.lambda : 0;
            const term2 = safeDivide(lambda, 1e-52, 0);

            // Term 3: ‚à´||v||dt (integrated 11D velocity - cumulative path)
            const term3 = isFinite(particle.total_velocity_integral) ? particle.total_velocity_integral : 0;

            // Term 4: ‚à´|Œîx‚ÇÅ‚ÇÇ|dt (total variation of internal state - NEW IN 12D)
            const term4 = isFinite(particle.total_x12_variation) ? particle.total_x12_variation : 0;

            // Term 5: Œ©¬∑Ec (synaptic interaction term)
            const omega = isFinite(particle.omega) ? particle.omega : 0;
            const term5 = omega * Ec;

            // Term 6: Ugrav + Udm (gravitational + dark matter potential)
            const Ugrav = isFinite(particle.Ugrav) ? particle.Ugrav : 0;
            const Udm = isFinite(particle.Udm) ? particle.Udm : 0;
            const term6 = Ugrav + Udm;

            // Combine all terms
            const psi = term1 + term2 + term3 + term4 + term5 + term6;

            // Validate result - NEVER allow NaN
            return isFinite(psi) ? psi : 0;
        }

        /**
         * Calculate spectral centroid from frequency data
         * The spectral centroid is the "center of mass" of the spectrum
         *
         * @param {Array} frequencyData - Array of {frequency, magnitude} objects
         * @returns {number} Spectral centroid in Hz
         */
        function calculateSpectralCentroid(frequencyData) {
            if (!frequencyData || frequencyData.length === 0) return 1000;

            let numerator = 0;
            let denominator = 0;
            let validCount = 0;

            frequencyData.forEach(data => {
                const freq = isFinite(data.frequency) && data.frequency > 0 ? data.frequency : 0;
                const mag = isFinite(data.magnitude) && data.magnitude >= 0 ? data.magnitude : 0;

                if (freq > 0 && mag > 0) {
                    numerator += freq * mag;
                    denominator += mag;
                    validCount++;
                }
            });

            if (validCount === 0 || denominator === 0) return 1000;

            const centroid = safeDivide(numerator, denominator, 1000);
            return safeClamp(centroid, 20, 20000, 1000); // Human hearing range
        }

        /**
         * Map audio features to 12D internal state parameters
         * Implements Section 5 of the 12D CST paper: Audio-Driven Modulation
         *
         * Audio modulates the 12th dimension evolution parameters:
         * - High frequencies increase adaptation rate (k)
         * - Low frequencies increase stability (higher Œ≥ decay)
         * - Spectral centroid influences similarity spread (œÉ)
         * - RMS energy directly nudges internal state (x‚ÇÅ‚ÇÇ)
         *
         * @param {Object} particle - Particle to modulate
         * @param {Array} audioFrequencies - Array of frequency values
         * @param {Array} audioMagnitudes - Array of magnitude values
         * @param {number} rmsEnergy - RMS energy of audio signal
         * @param {number} spectralCentroid - Spectral centroid (Hz)
         */
        function mapAudioToInternalState(particle, audioFrequencies, audioMagnitudes, rmsEnergy, spectralCentroid) {
            // Validate inputs
            if (!audioFrequencies || audioFrequencies.length === 0) return;

            // 1. High-frequency content increases adaptation rate
            const highFreqCount = audioFrequencies.filter(f => f > 1000).length;
            const highFreqRatio = highFreqCount / audioFrequencies.length;
            particle.k_adaptation = 0.005 + highFreqRatio * 0.015; // Range: [0.005, 0.020]

            // 2. Low-frequency content increases stability (higher decay)
            const lowFreqCount = audioFrequencies.filter(f => f < 200).length;
            const lowFreqRatio = lowFreqCount / audioFrequencies.length;
            particle.gamma_decay = 0.003 + lowFreqRatio * 0.007; // Range: [0.003, 0.010]

            // 3. Spectral centroid influences similarity parameter
            // Higher centroid = broader similarity (more connections)
            const centroid = spectralCentroid || 1000;
            particle.sigma_similarity = 0.5 + (centroid / 2000) * 1.5; // Map [0, 2000Hz] to [0.5, 2.0]
            particle.sigma_similarity = Math.min(2.0, Math.max(0.5, particle.sigma_similarity));

            // 4. RMS energy directly nudges internal state
            // This creates direct audio-to-consciousness coupling
            if (isFinite(rmsEnergy)) {
                const audio_nudge = 0.1 * (rmsEnergy - 0.5); // Center around 0
                particle.x12 += audio_nudge * 0.01; // Small perturbation
                particle.x12 = Math.max(-1, Math.min(1, particle.x12)); // Clamp
            }

            // 5. Overall magnitude affects memory adaptation rate
            const avgMagnitude = audioMagnitudes.reduce((a, b) => a + b, 0) / audioMagnitudes.length;
            particle.alpha_memory = 0.05 + avgMagnitude * 0.15; // Range: [0.05, 0.20]
        }

        // 10) Adaptive timestep
        function computeAdaptiveDt(particles, physics, timestepConfig) {
            if (!timestepConfig.adaptive || particles.length === 0) {
                return timestepConfig.dt;
            }
            
            let rMin = Infinity;
            let vMax = 0;
            
            particles.forEach(p => {
                const v = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                vMax = Math.max(vMax, v);
                
                // Find minimum distance to neighbors
                const neighbors = p.neighbors || [];
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - p.x;
                    const dy = pj.y - p.y;
                    const dz = pj.z - p.z;
                    const r = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        rMin = Math.min(rMin, r);
                });
            });
            
            if (rMin === Infinity) rMin = 1.0;
            if (vMax === 0) vMax = 1.0;
            
            // CST v2.0+ additive: Enhanced adaptive timestep with proper clamping
            // dt = min(dtMax, 0.1 * r_min / v_max)
            const dt = Math.min(timestepConfig.dtMax, 0.1 * rMin / vMax);
            // Clamp to [0.001, dtMax] for stability (per spec)
            return Math.max(0.001, Math.min(dt, timestepConfig.dtMax));
        }

        // CST v2.0 additive: Enhanced deterministic replay mode
        // 11) Deterministic replay mode
        function recordAudioFrame(frame) {
            if (determinism.isRecording) {
                // CST v2.0 additive: Record complete frame data for deterministic replay
                determinism.recordedAudioFrames.push({
                    timestamp: Date.now() / 1000,
                    rmsEnergy: frame.rmsEnergy,
                    frequencyData: JSON.parse(JSON.stringify(frame.frequencyData)), // Deep copy
                    spectralCentroid: frame.spectralCentroid,
                    harmonics: frame.harmonics ? JSON.parse(JSON.stringify(frame.harmonics)) : [],
                    dataArray: frame.dataArray ? Array.from(frame.dataArray) : null // Store raw FFT data
                });
            }
        }

        // CST v2.0 additive: Enhanced replay mode with deterministic seed reset
        function toggleReplayMode(data) {
            if (data && data.recordedAudioFrames) {
                determinism.mode = 'replay';
                determinism.recordedAudioFrames = JSON.parse(JSON.stringify(data.recordedAudioFrames)); // Deep copy
                determinism.replayIndex = 0;
                
                // CST v2.0 additive: Reset seed for deterministic replay
                const seed = data.seed || determinism.seed || 12345;
                setDeterministicSeed(seed);
                
                // CST v2.0 fix: Reset deterministicRandom to ensure clean RNG state
                deterministicRandom = seed;
                
                // CST v2.0+ additive: Reset token arrays and counters for clean replay
                tokens = [];
                tokenCount = 0;
                tokenRateWindow.timestamps = [];
                replicationCount = 0;
                deterministicIdCounter = 0; // Reset deterministic ID counter
                
                // CST v2.0+ additive: Reset œà accumulators, conservation stats, and entropy
                resetIntegralsAndConservation();
                updateEntropy(); // Update UI immediately
                
                // CST v2.0+ additive: Reset particles to initial state if needed
                // (Optional: could reset particles array here for full determinism)
                // Note: For full determinism, particles should be reset to initial state
                // or replay should start with a known particle configuration
                
                // Start replay processing
                startReplayProcessing();
            } else {
                determinism.mode = 'live';
                determinism.recordedAudioFrames = [];
                stopReplayProcessing();
            }
        }

        // CST v2.0+ additive: Helper function to reset integrals and conservation stats
        function resetIntegralsAndConservation() {
            // Reset œà accumulators
            psiAccumulators.velocityIntegral.clear();
            psiAccumulators.x12Integral.clear();
            psiAccumulators.x12Previous.clear();
            
            // Reset conservation stats
            conservationStats.E0 = 0;
            conservationStats.P0 = { x: 0, y: 0, z: 0 };
            conservationStats.L0 = { x: 0, y: 0, z: 0 };
            conservationStats.lastUpdate = Date.now();
            
            // Reset entropy state
            entropyState.histogram = new Array(entropyState.bins).fill(0);
            entropyState.lastEntropy = 0;
            entropyState.tempProxy = 0;
            entropyTrace.length = 0;
            // NEW: Reset entropy smoothing EMA
            entropyEma = null;
        }

        // CST v2.0 additive: Enhanced deterministic replay processing
        // Process recorded audio frames in replay mode
        function processReplayAudio() {
            if (determinism.mode !== 'replay' || determinism.recordedAudioFrames.length === 0) {
                stopReplayProcessing();
                return;
            }

            // Get current frame
            const frame = determinism.recordedAudioFrames[determinism.replayIndex];
            if (!frame) {
                // Loop back to start
                determinism.replayIndex = 0;
                return;
            }

            // CST v2.0 additive: Deep copy frequency data to avoid mutation
            audioEnergy = frame.rmsEnergy || 0;
            frequencyData = JSON.parse(JSON.stringify(frame.frequencyData || []));
            spectralCentroid = frame.spectralCentroid || 0;

            // Update displays
            const rmsEl = document.getElementById('rms-energy');
            const dominantEl = document.getElementById('dominant-freq');
            const centroidEl = document.getElementById('spectral-centroid');
            const gainEl = document.getElementById('audio-gain');
            
            if (rmsEl) rmsEl.textContent = audioEnergy.toFixed(3);
            if (gainEl) gainEl.textContent = (1 + audioEnergy * audioSensitivity).toFixed(2);
            if (frequencyData.length > 0 && dominantEl) {
                dominantEl.textContent = frequencyData[0].frequency.toFixed(1);
            }
            if (centroidEl) centroidEl.textContent = spectralCentroid.toFixed(1);

            // CST v2.0 additive: Generate tokens with deterministic RNG (already set via seed)
            generateTokens(frequencyData, audioEnergy, spectralCentroid);

            // Update chaos measure
            const chaos = calculateAudioChaos();
            const chaosEl = document.getElementById('audio-chaos');
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);

            // Move to next frame
            determinism.replayIndex = (determinism.replayIndex + 1) % determinism.recordedAudioFrames.length;
        }

        function startReplayProcessing() {
            stopReplayProcessing(); // Clear any existing interval
            if (determinism.mode === 'replay' && determinism.recordedAudioFrames.length > 0) {
                // CST v2.0+ additive: Reset deterministic ID counter for replay
                deterministicIdCounter = 0;
                // Process immediately, then at configured cadence
                processReplayAudio();
                determinism.replayInterval = setInterval(processReplayAudio, audioConfig.cadence);
                startTokenBufferFlush();
            }
        }

        function stopReplayProcessing() {
            if (determinism.replayInterval) {
                clearInterval(determinism.replayInterval);
                determinism.replayInterval = null;
            }
            stopTokenBufferFlush();
        }

        // Additive: replay scheduler state
        let replayIndex = 0;
        let replayTimer = null;

        // Additive: deterministic replay scheduler and feeding loop
        function startReplay() {
            const frames = determinism.recordedAudioFrames;
            if (!frames || frames.length === 0) {
                alert('No recorded frames available. Start recording first.');
                return;
            }
            determinism.mode = 'replay';
            replayIndex = 0;

            // Deterministic visuals for reproducibility
            applyDeterministicInit(determinism.seed || 12345);

            // Disable live audio path without touching UI
            isAudioActive = false;

            // Honor recorded timestamps if present; else use configured cadence
            const baseTs = frames[0].timestamp || 0;
            const tick = () => {
                if (replayIndex >= frames.length) {
                    stopReplay();
                    return;
                }
                const prev = replayIndex > 0 ? frames[replayIndex - 1] : null;
                stepReplayFrame(frames[replayIndex], prev, baseTs);
                replayIndex++;
                const nextDelay = replayIndex < frames.length
                    ? Math.max(50, Math.min(250, ((frames[replayIndex].timestamp || 0) - (frames[replayIndex - 1].timestamp || 0)) * 1000 || audioConfig.cadence))
                    : audioConfig.cadence;
                replayTimer = setTimeout(tick, nextDelay);
            };

            tick();
            updateStatus(`Replay mode enabled - ${frames.length} frames`);
            reflectDeterminismUI();
        }

        // Additive: stop deterministic replay
        function stopReplay() {
            determinism.mode = 'live';
            if (replayTimer) {
                clearTimeout(replayTimer);
                replayTimer = null;
            }
            updateStatus('Replay mode disabled - back to live mode');
            reflectDeterminismUI();
        }

        // Additive: step through a single replay frame
        function stepReplayFrame(frame, prevFrame, baseTs) {
            // Set pipeline inputs without WebAudio
            audioEnergy = frame.rmsEnergy || 0;
            spectralCentroid = frame.spectralCentroid || 0;
            frequencyData = (frame.frequencyData || []).map(({ frequency, magnitude }) => ({ frequency, magnitude }));

            // Generate tokens deterministically (seed already set)
            generateTokens(frequencyData, audioEnergy, spectralCentroid);

            // Update frequency spectrum explicitly from replay data
            updateFrequencyViz(
                frequencyData.map(d => d.frequency),
                frequencyData.map(d => d.magnitude)
            );

            // Update chaos indicator
            const chaos = calculateAudioChaos();
            const chaosEl = document.getElementById('audio-chaos');
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);
        }

        // Additive: apply deterministic initialization for reproducible visuals
        function applyDeterministicInit(seed) {
            setDeterministicSeed(seed);
            // Deterministic placement/colors for reproducible visuals
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const jitter = (getRandom() * 2 - 1) * 0.05;
                p.x = 0.1 + i * 0.1 + jitter;
                p.y = i * 0.1 + jitter;
                p.z = i * 0.1 - jitter;

                const baseHue = 180 + Math.floor(getRandom() * 360);
                const color = new THREE.Color();
                color.setHSL(baseHue / 360, 1.0, 0.5); // Fix: Use setHSL instead of HSL string
                p.line.material.color.setHex(color.getHex());
                p.sphere.material.color.setHex(color.getHex());
            }
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a1a, 0.002);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(50, 30, 50);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x0a0a1a, 0.5);
            container.appendChild(renderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Add initial particle
            addParticle();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            // Added: Validate Three.js scene initialization to fix runtime errors
            if (scene && camera && renderer) {
                console.log('[CST Runtime] ‚úÖ Three.js scene properly initialized');
                console.log('[CST Runtime]   - Scene:', scene);
                console.log('[CST Runtime]   - Camera:', camera.type);
                console.log('[CST Runtime]   - Renderer:', renderer.domElement.tagName);
            } else {
                console.error('[CST Runtime] ‚ùå Three.js scene initialization incomplete');
                console.error('[CST Runtime]   - scene:', !!scene, '- camera:', !!camera, '- renderer:', !!renderer);
            }
        }

        function initFrequencyCanvas() {
            freqCanvas = document.getElementById('frequencyCanvas');
            if (freqCanvas) {
            freqCtx = freqCanvas.getContext('2d');
                freqCanvas.width = freqCanvas.offsetWidth || 400;
                freqCanvas.height = freqCanvas.offsetHeight || 150;
                
                // Handle window resize for frequency canvas
                window.addEventListener('resize', () => {
                    if (freqCanvas) {
                        freqCanvas.width = freqCanvas.offsetWidth || 400;
                        freqCanvas.height = freqCanvas.offsetHeight || 150;
                    }
                });
            }
        }

        // CST v2.0+ additive: Initialize entropy canvas
        function initEntropyCanvas() {
            const canvas = document.getElementById('entropyCanvas');
            if (canvas) {
                entropyState.ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth || 400;
                canvas.height = 100;
                
                // Handle window resize for entropy canvas
                window.addEventListener('resize', () => {
                    if (canvas) {
                        canvas.width = canvas.offsetWidth || 400;
                        canvas.height = 100;
                        // Redraw histogram on resize
                        if (entropyState.histogram) {
                            drawEntropyHistogram(entropyState.histogram);
                        }
                    }
                });
            }
            
            // CST v2.0+ additive: Initialize entropy trace canvas
            const traceCanvas = document.getElementById('entropyTraceCanvas');
            if (traceCanvas) {
                entropyState.traceCtx = traceCanvas.getContext('2d');
                traceCanvas.width = traceCanvas.offsetWidth || 400;
                traceCanvas.height = 60;
                
                // Handle window resize for trace canvas
                window.addEventListener('resize', () => {
                    if (traceCanvas) {
                        const oldWidth = traceCanvas.width;
                        traceCanvas.width = traceCanvas.offsetWidth || 400;
                        traceCanvas.height = 60;
                        
                        // Adjust trace buffer size if canvas width changed
                        const newWidth = traceCanvas.width;
                        if (newWidth !== oldWidth && entropyTrace.length > 0) {
                            // Trim or pad trace buffer to match new canvas width
                            if (entropyTrace.length > newWidth) {
                                // Remove oldest entries
                                entropyTrace.splice(0, entropyTrace.length - newWidth);
                            }
                            // Redraw trace immediately after resize
                            if (entropyState.lastEntropy !== undefined) {
                                drawEntropyTrace(entropyState.lastEntropy);
                            }
                        }
                    }
                });
            }
        }
        
        // --- NEW: adaptive state canvas init ---
        function initAdaptiveStateCanvas() {
            const canvas = document.getElementById('adaptiveStateCanvas');
            if (!canvas) return;
            adaptiveStateCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth || 400;
            canvas.height = 120;

            window.addEventListener('resize', () => {
                if (!adaptiveStateCtx) return;
                const c = adaptiveStateCtx.canvas;
                c.width = c.offsetWidth || 400;
                c.height = 120;
            });
        }
        
        // --- NEW: dark matter profile canvas init ---
        function initDmProfileCanvas() {
            const canvas = document.getElementById('dmProfileCanvas');
            if (!canvas) return;
            dmProfileCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth || 400;
            canvas.height = 120;
            window.addEventListener('resize', () => {
                if (!dmProfileCtx) return;
                const c = dmProfileCtx.canvas;
                c.width = c.offsetWidth || 400;
                c.height = 120;
            });
        }

        // CST v2.0+ additive: Projection mode functions
        function orthogonalProjection(p) {
            // Identity mapping: replicate x,y,z with variations
            const scale = 0.1;
            for (let i = 0; i < 11; i++) {
                const dim = i % 3;
                const coord = dim === 0 ? p.x : (dim === 1 ? p.y : p.z);
                p.projection11D.pos11D[i] = coord * (1 + i * scale);
                p.projection11D.vel11D[i] = (dim === 0 ? p.velocity.x : (dim === 1 ? p.velocity.y : p.velocity.z)) * (1 + i * scale);
            }
        }

        function randomEmbeddingProjection(p) {
            // Seeded random projection matrix (deterministic in replay mode)
            if (!projectionConfig.randomR) {
                // Initialize random projection matrix (11x3)
                projectionConfig.randomR = [];
                const seed = determinism.mode === 'replay' && determinism.seed !== null 
                    ? determinism.seed 
                    : projectionConfig.randomSeed;
                let rng = seed;
                
                for (let i = 0; i < 11; i++) {
                    projectionConfig.randomR[i] = [];
                    for (let j = 0; j < 3; j++) {
                        rng = (rng * 1103515245 + 12345) & 0x7fffffff;
                        projectionConfig.randomR[i][j] = (rng / 0x7fffffff) * 2 - 1; // [-1, 1]
                    }
                }
            }
            
            // Project 3D position to 11D using random matrix
            const pos3D = [p.x, p.y, p.z];
            const vel3D = [p.velocity.x, p.velocity.y, p.velocity.z];
            
            for (let i = 0; i < 11; i++) {
                let posSum = 0;
                let velSum = 0;
                for (let j = 0; j < 3; j++) {
                    posSum += projectionConfig.randomR[i][j] * pos3D[j];
                    velSum += projectionConfig.randomR[i][j] * vel3D[j];
                }
                p.projection11D.pos11D[i] = posSum;
                p.projection11D.vel11D[i] = velSum;
            }
        }

        function learnedEmbeddingProjection(p) {
            // NEW: Use neural network-based learned embedding projection
            if (!learnedProjector) {
                initializeLearnedProjector();
            }

            // Prepare 11D input from particle state
            const input11d = [
                p.x / 1e11,
                p.y / 1e11,
                p.z / 1e11,
                p.velocity.x / 1e3,
                p.velocity.y / 1e3,
                p.velocity.z / 1e3,
                Math.log10(Math.max(p.mass, 1)) / 30,
                Math.log10(Math.max(p.Ec || 1, 1)) / 60,
                (p.entropyS || 0) / 100,
                (p.nu || 0) / 1e20,
                (p.chaos || 0) / 100
            ];

            // Get 3D projection from learned network
            const projection3D = learnedProjector.project(input11d);

            // Map the 3D projection back to 11D space by repeating and transforming
            for (let i = 0; i < 11; i++) {
                const idx = i % 3;
                const scale = 1.0 + (i / 11.0);  // Progressive scaling
                p.projection11D.pos11D[i] = projection3D[idx] * scale * 10.0;
                p.projection11D.vel11D[i] = projection3D[idx] * scale * 0.1;
            }

            // Fallback: If neural network projection fails, use legacy method
            if (!projection3D || projection3D.some(v => isNaN(v))) {
                if (projectionConfig.learnedWeights && projectionConfig.learnedWeights.length === 11) {
                    // Use learned weights for projection
                    for (let i = 0; i < 11; i++) {
                        if (projectionConfig.learnedWeights[i] && projectionConfig.learnedWeights[i].length === 3) {
                            p.projection11D.pos11D[i] =
                                projectionConfig.learnedWeights[i][0] * p.x +
                                projectionConfig.learnedWeights[i][1] * p.y +
                                projectionConfig.learnedWeights[i][2] * p.z;
                            p.projection11D.vel11D[i] =
                                projectionConfig.learnedWeights[i][0] * p.velocity.x +
                                projectionConfig.learnedWeights[i][1] * p.velocity.y +
                                projectionConfig.learnedWeights[i][2] * p.velocity.z;
                        } else {
                            // Fallback to orthogonal for this dimension
                            const dim = i % 3;
                            const coord = dim === 0 ? p.x : (dim === 1 ? p.y : p.z);
                            p.projection11D.pos11D[i] = coord;
                            p.projection11D.vel11D[i] = (dim === 0 ? p.velocity.x : (dim === 1 ? p.velocity.y : p.velocity.z));
                        }
                    }
                } else {
                    // Fallback to orthogonal if no learned weights
                    orthogonalProjection(p);
                }
            }
        }

        // CST v2.0+ additive: Compute entropy metrics from particle speeds
        // CST v2.5+ ULTIMATE ENHANCEMENT: 12D Quantum-Correlated Entropy System
        function computeEntropyMetrics() {
            const bins = 32;
            const histogram = new Array(bins).fill(0);
            let totalSpeed = 0;

            if (particles.length === 0) {
                return {
                    entropy: 0,
                    histogram,
                    tempProxy: 0,
                    entropy12D: 0,
                    S_velocity: 0,
                    S_x12: 0,
                    S_m12: 0,
                    S_psi: 0,
                    S_dx12: 0
                };
            }

            // === 3D VELOCITY ENTROPY (Original) ===
            // Compute speeds first
            const speeds = particles.map(p => {
                const speed = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                totalSpeed += speed;
                return speed;
            });

            // Find max speed for normalization - CST v2.0+ fix: Handle empty speeds array
            const maxSpeed = speeds.length > 0 ? Math.max(...speeds, 1) : 1;

            // Bin particle speeds into histogram
            speeds.forEach(speed => {
                const bin = Math.min(bins - 1, Math.floor((speed / maxSpeed) * bins));
                histogram[bin]++;
            });

            // Normalize to probabilities
            const total = particles.length || 1;
            const probs = histogram.map(c => c / total);

            // Compute Shannon entropy: S_velocity = -Œ£ p_b ln p_b
            let S_velocity = 0;
            probs.forEach(p => {
                if (p > 0) {
                    S_velocity -= p * Math.log(p);
                }
            });

            // === 12D POSITION ENTROPY (x12 distribution) ===
            const x12Histogram = new Array(bins).fill(0);
            const x12Values = particles.map(p => isFinite(p.x12) ? p.x12 : 0);
            const maxX12 = Math.max(...x12Values.map(Math.abs), 1);

            x12Values.forEach(x12 => {
                // Map [-maxX12, maxX12] to [0, bins-1]
                const normalized = (x12 + maxX12) / (2 * maxX12);
                const bin = Math.min(bins - 1, Math.max(0, Math.floor(normalized * bins)));
                x12Histogram[bin]++;
            });

            const x12Probs = x12Histogram.map(c => c / total);
            let S_x12 = 0;
            x12Probs.forEach(p => {
                if (p > 0) {
                    S_x12 -= p * Math.log(p);
                }
            });

            // === 12D MOMENTUM ENTROPY (dx12_dt distribution) ===
            const dx12Histogram = new Array(bins).fill(0);
            const dx12Values = particles.map(p => isFinite(p.dx12_dt) ? p.dx12_dt : 0);
            const maxDx12 = Math.max(...dx12Values.map(Math.abs), 0.01);

            dx12Values.forEach(dx12 => {
                const normalized = (dx12 + maxDx12) / (2 * maxDx12);
                const bin = Math.min(bins - 1, Math.max(0, Math.floor(normalized * bins)));
                dx12Histogram[bin]++;
            });

            const dx12Probs = dx12Histogram.map(c => c / total);
            let S_dx12 = 0;
            dx12Probs.forEach(p => {
                if (p > 0) {
                    S_dx12 -= p * Math.log(p);
                }
            });

            // === INTERNAL STATE ENTROPY (m12 memory distribution) ===
            const m12Histogram = new Array(bins).fill(0);
            const m12Values = particles.map(p => isFinite(p.m12) ? p.m12 : 0);
            const maxM12 = Math.max(...m12Values.map(Math.abs), 1);

            m12Values.forEach(m12 => {
                const normalized = (m12 + maxM12) / (2 * maxM12);
                const bin = Math.min(bins - 1, Math.max(0, Math.floor(normalized * bins)));
                m12Histogram[bin]++;
            });

            const m12Probs = m12Histogram.map(c => c / total);
            let S_m12 = 0;
            m12Probs.forEach(p => {
                if (p > 0) {
                    S_m12 -= p * Math.log(p);
                }
            });

            // === QUANTUM CORRELATION ENTROPY (psi distribution) ===
            const psiHistogram = new Array(bins).fill(0);
            const psiValues = particles.map(p => isFinite(p.psi) ? p.psi : 0);
            const maxPsi = Math.max(...psiValues.map(Math.abs), 1);

            psiValues.forEach(psi => {
                const normalized = (psi + maxPsi) / (2 * maxPsi);
                const bin = Math.min(bins - 1, Math.max(0, Math.floor(normalized * bins)));
                psiHistogram[bin]++;
            });

            const psiProbs = psiHistogram.map(c => c / total);
            let S_psi = 0;
            psiProbs.forEach(p => {
                if (p > 0) {
                    S_psi -= p * Math.log(p);
                }
            });

            // === TOTAL 12D-ENHANCED ENTROPY ===
            // Weighted combination: velocity gets more weight as it's more dynamic
            const S_total = 0.35 * S_velocity + 0.25 * S_x12 + 0.15 * S_m12 + 0.15 * S_psi + 0.10 * S_dx12;

            // === ENHANCED TEMPERATURE PROXY (includes 12D kinetic energy) ===
            // T ‚àù <v¬≤> + <(dx12_dt)¬≤>
            let totalKineticEnergy = 0;
            particles.forEach(p => {
                const v2 = p.velocity.x**2 + p.velocity.y**2 + p.velocity.z**2;
                const dx12_2 = isFinite(p.dx12_dt) ? p.dx12_dt**2 : 0;
                totalKineticEnergy += v2 + 0.1 * dx12_2; // 12D contribution scaled down
            });
            const tempProxy = totalKineticEnergy / total;

            return {
                entropy: S_velocity,           // Original 3D entropy for backward compatibility
                histogram,                     // Original histogram
                tempProxy,                     // Enhanced temperature proxy
                entropy12D: S_total,          // Total 12D-enhanced entropy
                S_velocity,                    // Individual entropy components
                S_x12,
                S_m12,
                S_psi,
                S_dx12
            };
        }
        
        // CST v2.0+ additive: Update entropy metrics and UI
        function updateEntropy() {
            if (particles.length === 0) {
                // Reset entropy state and update UI to zeros
                entropyState.histogram = new Array(entropyState.bins).fill(0);
                entropyState.lastEntropy = 0;
                entropyState.tempProxy = 0;
                entropyTrace.length = 0; // CST v2.0+ additive: Clear entropy trace
                
                const entropyEl = document.getElementById('entropy-global');
                const binsEl = document.getElementById('entropy-bins');
                const tempEl = document.getElementById('entropy-temperature');
                
                if (entropyEl) entropyEl.textContent = '0.000';
                if (binsEl) binsEl.textContent = '[]';
                if (tempEl) tempEl.textContent = '0.000';
                // CST v2.0+ additive: Clear trace when no particles - draw empty trace
                if (entropyState.traceCtx) {
                    const ctx = entropyState.traceCtx;
                    const canvas = ctx.canvas;
                    const width = canvas.width || 400;
                    const height = canvas.height || 60;
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
                    ctx.fillRect(0, 0, width, height);
                    // Draw baseline
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, height / 2);
                    ctx.lineTo(width, height / 2);
                    ctx.stroke();
                }
                return;
            }
            
            // Compute entropy metrics (now with 12D enhancements)
            const { entropy, histogram, tempProxy, entropy12D, S_velocity, S_x12, S_m12, S_psi, S_dx12 } = computeEntropyMetrics();

            // Store in state
            entropyState.lastEntropy = kB * entropy12D; // Use 12D-enhanced entropy
            entropyState.histogram = histogram;
            entropyState.tempProxy = tempProxy;

            // Update UI
            const entropyEl = document.getElementById('entropy-global');
            const binsEl = document.getElementById('entropy-bins');
            const tempEl = document.getElementById('entropy-temperature');

            // Display 12D-enhanced entropy (scaled to meaningful range)
            if (entropyEl) entropyEl.textContent = (entropyState.lastEntropy * 1.5).toFixed(3);
            if (binsEl) binsEl.textContent = JSON.stringify(histogram.slice(0, 5)); // Show first 5 bins as preview
            if (tempEl) tempEl.textContent = entropyState.tempProxy.toFixed(3);

            // CST v2.0+ additive: Draw entropy trace after updating metrics
            drawEntropyTrace(entropyState.lastEntropy);
        }
        
        // CST v2.0+ additive: Draw scrolling entropy trace (heart-rate monitor style)
        function drawEntropyTrace(entropyValue) {
            if (!entropyState.traceCtx) return;
            
            // Apply exponential moving average smoothing
            const smoothed = getSmoothedEntropy(entropyValue);
            
            const ctx = entropyState.traceCtx;
            const canvas = ctx.canvas;
            const width = canvas.width || 400;
            const height = canvas.height || 60;
            
            // Add new entropy value to trace buffer (only if it's a valid number)
            if (typeof smoothed === 'number' && !isNaN(smoothed) && isFinite(smoothed)) {
                entropyTrace.push(smoothed);
            }
            
            // Limit trace buffer to canvas width (ensure we don't exceed it)
            while (entropyTrace.length > width) {
                entropyTrace.shift();
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw baseline at mid-height
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
            
            // Draw trace line
            if (entropyTrace.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = '#00ffcc'; // Bright cyan
                ctx.lineWidth = 2;
                
                // Auto-scale based on min/max in trace (like heart-rate monitor)
                const validValues = entropyTrace.filter(v => typeof v === 'number' && !isNaN(v) && isFinite(v));
                if (validValues.length > 0) {
                    const minEntropy = Math.min(...validValues);
                    const maxEntropy = Math.max(...validValues);
                    const range = Math.max(maxEntropy - minEntropy, 0.001); // Avoid division by zero
                    
                    // Use 80% of canvas height for the trace, centered
                    const traceHeight = height * 0.8;
                    const baseline = height / 2;
                    
                    // Draw the trace line
                    let firstPoint = true;
                    entropyTrace.forEach((val, i) => {
                        if (typeof val === 'number' && !isNaN(val) && isFinite(val)) {
                            const x = i;
                            // Normalize to [0, 1] then scale and center around baseline
                            const normalized = (val - minEntropy) / range;
                            const y = baseline + (traceHeight / 2) - (normalized * traceHeight);
                            
                            // Clamp y to canvas bounds
                            const clampedY = Math.max(0, Math.min(height, y));
                            
                            if (firstPoint) {
                                ctx.moveTo(x, clampedY);
                                firstPoint = false;
                            } else {
                                ctx.lineTo(x, clampedY);
                            }
                        }
                    });
                    
                    ctx.stroke();
                }
            } else if (entropyTrace.length === 1) {
                // Draw a single point if only one value
                const val = entropyTrace[0];
                if (typeof val === 'number' && !isNaN(val) && isFinite(val)) {
                    ctx.fillStyle = '#00ffcc';
                    ctx.beginPath();
                    ctx.arc(0, height / 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // CST v2.0+ additive: Draw entropy histogram
        function drawEntropyHistogram(histogram) {
            if (!entropyState.ctx) return;
            
            const ctx = entropyState.ctx;
            const canvas = ctx.canvas;
            const width = canvas.width;
            const height = canvas.height;
            
            // Use provided histogram or fall back to state
            const hist = histogram || entropyState.histogram || new Array(entropyState.bins).fill(0);
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw histogram bars with gradient colors
            const barW = width / entropyState.bins;
            const maxCount = Math.max(...hist, 1);
            
            for (let i = 0; i < entropyState.bins; i++) {
                const barH = (hist[i] / maxCount) * height;
                const hue = (i / entropyState.bins) * 360;
                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.fillRect(i * barW, height - barH, barW - 1, barH);
            }
        }
        
        // --- NEW: adaptive state updater ---
        function updateAdaptiveStateTrace() {
            if (!adaptiveStateCtx) return;
            const ctx = adaptiveStateCtx;
            const c = ctx.canvas;
            const width = c.width || 400;
            const height = c.height || 120;

            // Extend x12History to number of particles
            while (x12History.length < particles.length) x12History.push([]);
            // Trim if particles removed
            if (x12History.length > particles.length) x12History.length = particles.length;

            // Append current x12 to each particle's history
            particles.forEach((p, i) => {
                const val = (typeof p.x12 === 'number' && isFinite(p.x12)) ? p.x12 : 0;
                x12History[i].push(val);
                while (x12History[i].length > width) x12History[i].shift();
            });

            // Draw background
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            ctx.fillRect(0, 0, width, height);

            // Draw baseline at y=0 centered
            const baseline = height / 2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.moveTo(0, baseline);
            ctx.lineTo(width, baseline);
            ctx.stroke();

            // Draw each particle's trace
            particles.forEach((p, i) => {
                const colorHex = '#' + p.color.toString(16).padStart(6, '0');
                ctx.strokeStyle = colorHex;
                ctx.lineWidth = 1;
                ctx.beginPath();
                let first = true;
                const hist = x12History[i];
                for (let x = 0; x < hist.length; x++) {
                    // x12 in [-1,1] mapped to vertical extent
                    const y = baseline - (hist[x] * (height * 0.45));
                    const clampedY = Math.max(0, Math.min(height, y));
                    if (first) { ctx.moveTo(x, clampedY); first = false; } else { ctx.lineTo(x, clampedY); }
                }
                ctx.stroke();
            });
        }
        
        // --- NEW: dark matter profile plot ---
        function drawNfwProfile(rho0, rs) {
            if (!dmProfileCtx) return;
            const ctx = dmProfileCtx;
            const c = ctx.canvas;
            const width = c.width || 400;
            const height = c.height || 120;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(10,10,26,0.25)';
            ctx.fillRect(0, 0, width, height);

            // r from 0.1*rs to 10*rs (avoid 0 singularity)
            const samples = 200;
            const rMin = Math.max(0.1 * rs, 1e-6);
            const rMax = 10 * rs;
            let values = [];
            for (let i = 0; i < samples; i++) {
                const t = i / (samples - 1);
                const r = rMin * Math.pow(rMax / rMin, t); // log spacing
                const r_rs = r / rs;
                const rho = r_rs > 0 ? rho0 / (r_rs * Math.pow(1 + r_rs, 2)) : 0;
                values.push({ r, rho });
            }

            const rhoMax = Math.max(...values.map(v => v.rho), 1e-12);
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.beginPath();

            values.forEach((v, i) => {
                const x = (i / (samples - 1)) * width;
                const y = height - (Math.log(v.rho + 1) / Math.log(rhoMax + 1)) * height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }
        
        // --- NEW: theta std deviation ---
        function computeThetaStd(particles) {
            if (!particles || particles.length === 0) return 0;
            const thetas = particles.map(p => p.theta);
            const mean = thetas.reduce((a,b)=>a+b,0)/thetas.length;
            const variance = thetas.reduce((a,b)=>a + (b - mean)**2, 0) / thetas.length;
            return Math.sqrt(variance);
        }
        
        // --- NEW: replay validation updater ---
        function updateReplayValidation(consStats, virial) {
            if (determinism.mode !== 'replay') return;
            const edriftEl = document.getElementById('replay-edrift');
            const pmagEl = document.getElementById('replay-pmag');
            const lmagEl = document.getElementById('replay-lmag');
            const virialEl = document.getElementById('replay-virial');
            if (!edriftEl || !pmagEl || !lmagEl || !virialEl) return;

            edriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
            const Pmag = Math.sqrt(consStats.P.x**2 + consStats.P.y**2 + consStats.P.z**2);
            const Lmag = Math.sqrt(consStats.L.x**2 + consStats.L.y**2 + consStats.L.z**2);
            pmagEl.textContent = Pmag.toExponential(2);
            lmagEl.textContent = Lmag.toExponential(2);
            virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
        }
        
        // --- NEW: package œà terms for tokens ---
        function currentPsiSnapshot() {
            const psiResult = updatePsiNormalized(particles, physics, psiAccumulators);
            return {
                energyTerm: parseFloat(psiResult.terms.energyTerm.toFixed(6)),
                lambdaTerm: parseFloat(psiResult.terms.lambdaTerm.toFixed(6)),
                velocityIntegralTerm: parseFloat(psiResult.terms.velocityIntegralTerm.toFixed(6)),
                x12IntegralTerm: parseFloat(psiResult.terms.x12IntegralTerm.toFixed(6)),
                omegaTerm: parseFloat(psiResult.terms.omegaTerm.toFixed(6)),
                potentialTerm: parseFloat(psiResult.terms.potentialTerm.toFixed(6)),
                psiTotal: parseFloat(psiResult.psiTotal.toFixed(6))
            };
        }

        // CST v2.0+ additive: Audio setup helpers
        async function startAudio() {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
            analyser.fftSize = audioConfig.fftSize; // Use configurable FFT size
                    bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);

                    // CST v2.0 COMPLETION: Extract voice bio-frequency after stabilization
                    setTimeout(() => {
                        if (analyser && dataArray) {
                            const voiceFreq = voiceBioExtractor.extractFundamentalFrequency(analyser, dataArray);
                            voiceBioExtractor.generatePersonalizedParams(voiceFreq);
                            voiceBioExtractor.applyPersonalization();

                            // Update display if elements exist
                            const freqEl = document.getElementById('voice-freq');
                            const stateEl = document.getElementById('emotional-state');
                            const kEl = document.getElementById('personalized-k');
                            if (freqEl) freqEl.textContent = voiceFreq.toFixed(1);
                            if (stateEl) stateEl.textContent = voiceBioExtractor.emotionalState;
                            if (kEl) kEl.textContent = voiceBioExtractor.personalizedParams.k.toFixed(3);

                            console.log('[CST Voice Bio] Detected voice frequency:', voiceFreq.toFixed(1), 'Hz, State:', voiceBioExtractor.emotionalState);
                        }
                    }, 3000); // Wait 3 seconds for audio stabilization
        }

        // CST v2.0+ additive: Restart audio processing loop with new cadence
        function restartAudioProcessingLoop() {
            if (audioProcessingInterval) {
                clearInterval(audioProcessingInterval);
                audioProcessingInterval = null;
            }
            if (isAudioActive && analyser) {
                // Process immediately, then at configured cadence
                    processAudio();
                audioProcessingInterval = setInterval(processAudio, audioConfig.cadence);
            }
        }
        
        // CST v2.0+ additive: Restart replay loop with new cadence
        function restartReplayLoop() {
            if (determinism.replayInterval) {
                clearInterval(determinism.replayInterval);
                determinism.replayInterval = null;
            }
            if (determinism.mode === 'replay' && determinism.recordedAudioFrames.length > 0) {
                processReplayAudio();
                determinism.replayInterval = setInterval(processReplayAudio, audioConfig.cadence);
            }
        }
        
        // CST v2.0+ additive: Start token buffer flush loop
        function startTokenBufferFlush() {
            if (tokenBuffer.flushInterval) {
                clearInterval(tokenBuffer.flushInterval);
            }
            tokenBuffer.flushInterval = setInterval(() => {
                flushTokenBuffer();
            }, tokenBuffer.flushRate);
            
            // CST v2.0+ additive: Start periodic token rate updates at ~500ms cadence
            if (tokenRateUpdateInterval) {
                clearInterval(tokenRateUpdateInterval);
            }
            tokenRateUpdateInterval = setInterval(() => {
                updateTokenRate();
            }, 500);
        }
        
        // CST v2.0+ additive: Stop token buffer flush loop
        function stopTokenBufferFlush() {
            if (tokenBuffer.flushInterval) {
                clearInterval(tokenBuffer.flushInterval);
                tokenBuffer.flushInterval = null;
            }
            // CST v2.0+ additive: Stop token rate update interval
            if (tokenRateUpdateInterval) {
                clearInterval(tokenRateUpdateInterval);
                tokenRateUpdateInterval = null;
            }
            // Flush any remaining tokens
            flushTokenBuffer();
        }
        
        // CST v2.0+ additive: Flush token buffer to UI
        function flushTokenBuffer() {
            if (tokenBuffer.tokens.length === 0) return;
            
            // Add buffered tokens to main tokens array
            tokenBuffer.tokens.forEach(token => {
                tokens.push(token);
                tokenCount++;
            });
            
            // Update token display (bounded to limit)
            updateTokenDisplay();
            
            // Update counters
            const countEl = document.getElementById('token-count');
            const countStatusEl = document.getElementById('token-count-status');
            const replEl = document.getElementById('replication-count');
            if (countEl) countEl.textContent = tokens.length;
            if (countStatusEl) countStatusEl.textContent = tokens.length;
            if (replEl) replEl.textContent = replicationCount;
            
            // Clear buffer
            tokenBuffer.tokens = [];
        }

        function stopAudio() {
            if (audioProcessingInterval) {
                clearInterval(audioProcessingInterval);
                audioProcessingInterval = null;
            }
            stopTokenBufferFlush();
                if (microphone) {
                    microphone.disconnect();
                    microphone = null;
                }
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
                isAudioActive = false;
            const button = document.getElementById('micButton');
            const indicator = document.getElementById('audioIndicator');
            if (button) {
                button.textContent = 'üé§ START MICROPHONE ENGINE';
                button.classList.remove('active');
            }
            if (indicator) indicator.classList.remove('active');
            const tokenIndicator = document.getElementById('tokenIndicator');
            if (tokenIndicator) tokenIndicator.classList.remove('active');
            updateStatus('Audio engine stopped');
        }

        function computeFFTFrame() {
            if (!analyser || !dataArray || bufferLength === 0) return { frequencies: [], rms: 0, centroid: 0, raw: [] };
            
            // Frequency-domain
            analyser.getByteFrequencyData(dataArray);
            const freqBins = Array.from(dataArray);
            const sr = audioContext.sampleRate;
            const top = freqBins
                .map((v, idx) => ({ v, idx }))
                .sort((a, b) => b.v - a.v)
                .slice(0, 10)
                .map(({ v, idx }) => ({
                    frequency: (idx * sr) / (2 * bufferLength),
                    magnitude: v / 255
                }))
                .filter(f => f.magnitude > 0.05); // Filter low magnitude
            
            // Time-domain RMS
            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const normalized = (dataArray[i] - 128) / 128;
                sum += normalized * normalized;
            }
            const rms = Math.sqrt(sum / dataArray.length);
            
            // Spectral centroid
            analyser.getByteFrequencyData(dataArray);
            let wSum = 0;
            let mSum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const freq = (i * sr) / (2 * bufferLength);
                wSum += freq * dataArray[i];
                mSum += dataArray[i];
            }
            const centroid = mSum > 0 ? wSum / mSum : 0;
            
            return { frequencies: top, rms, centroid, raw: Array.from(dataArray) };
        }

        async function toggleMicrophone() {
            const button = document.getElementById('micButton');
            const indicator = document.getElementById('audioIndicator');
            
            if (!isAudioActive) {
                try {
                    await startAudio();
                    isAudioActive = true;
                    if (button) {
                        button.textContent = 'üé§ STOP MICROPHONE';
                        button.classList.add('active');
                    }
                    if (indicator) indicator.classList.add('active');
                    updateStatus('üéµ Audio engine active - CONTINUOUSLY generating tokens from audio stream');
                    
                    // CST v2.0+ fix: Use configurable cadence
                    restartAudioProcessingLoop();
                    startTokenBufferFlush();
                } catch (err) {
                    console.error('Microphone access error:', err);
                    updateStatus('‚ùå Microphone access denied. Please grant permission and try again.');
                    alert('Could not access microphone. Please grant permission.');
                    stopAudio();
                }
            } else {
                stopAudio();
                // Stop replay if active
                if (determinism.mode === 'replay') {
                    stopReplayProcessing();
                }
            }
        }

        // Token generation function - called every 100ms from processAudio()
        // CST v2.0+ fix: Handle silent input gracefully - still generate frame tokens
        function generateTokens(frequencyData, rmsEnergy, spectralCentroid) {
            // Ensure frequencyData is an array (handle null/undefined)
            if (!frequencyData) frequencyData = [];

            // Use default fundamental frequency if no frequencies detected (silent input)
            const fundamental = frequencyData.length > 0 ? frequencyData[0].frequency : 0;
            const harmonics = fundamental > 0 ? generatePhiHarmonics(fundamental, 8) : [];
            const harmonicsCountEl = document.getElementById('harmonics-count');
            if (harmonicsCountEl) harmonicsCountEl.textContent = harmonics.length;

            // CST v2.0+ additive: Record complete audio frame for deterministic replay
            if (determinism.isRecording) {
                recordAudioFrame({
                    rmsEnergy: rmsEnergy,
                    frequencyData: frequencyData,
                    spectralCentroid: spectralCentroid,
                    harmonics: harmonics,
                    dataArray: dataArray ? Array.from(dataArray) : null // Store raw FFT data
                });
            }

            // CST v2.0+ fix: Always generate Audio Frame Token (even with silent input)
            generateAudioFrameToken(
                frequencyData,
                rmsEnergy,
                spectralCentroid,
                harmonics
            );

            // CST v2.0+ fix: Only process frequencies if available
            if (frequencyData.length > 0) {
            // Map each frequency to visual particles continuously
            frequencyData.forEach((freqData, idx) => {
                // Sound-to-color mapping
                const colorHue = (freqData.frequency / 20000) * 360;
                const color = new THREE.Color();
                color.setHSL(colorHue / 360, freqData.magnitude, 0.5); // Fix: Use setHSL instead of HSL string

                // Create or update particle for this frequency
                if (particles.length < 20) {
                    createParticleFromFrequency(freqData.frequency, freqData.magnitude, color.getHex());
                } else {
                    // Update existing particles with frequency assignment
                    const targetParticle = particles[idx % particles.length];
                    if (targetParticle) {
                        updateParticleFromAudio(targetParticle, freqData.frequency, freqData.magnitude, color.getHex());
                    }
                }
            });

            // Generate œÜ-Harmonic Tokens for each harmonic
            harmonics.forEach((harmonic, idx) => {
                if (idx < frequencyData.length) {
                    generateHarmonicToken(harmonic, frequencyData[idx].magnitude, idx);
                }
            });
            }
        }

        // CST v2.0 fix: Use setInterval for exact 100ms cadence (no drift)
        function processAudio() {
            if (!isAudioActive || !analyser) return;

            const tokenIndicator = document.getElementById('tokenIndicator');
            if (tokenIndicator) tokenIndicator.classList.add('active');

            const frame = computeFFTFrame();
            audioEnergy = frame.rms || 0;
            frequencyData = frame.frequencies || [];
            spectralCentroid = frame.centroid || 0;

            // === ONSET DETECTION ===
            if (onsetConfig.enabled && frame.raw && frame.raw.length > 0) {
                if (detectOnset(frame.raw) && particles.length < 30) {
                    // Create particle on onset
                    console.log('[CST Onset] üéµ Audio onset detected - creating particle');
                    addParticle();
                }
            }

            // Update displays
            const rmsEl = document.getElementById('rms-energy');
            const dominantEl = document.getElementById('dominant-freq');
            const centroidEl = document.getElementById('spectral-centroid');
            const gainEl = document.getElementById('audio-gain');

            if (rmsEl) rmsEl.textContent = audioEnergy.toFixed(3);
            if (gainEl) gainEl.textContent = (1 + audioEnergy * audioSensitivity).toFixed(2);
            if (frequencyData.length > 0 && dominantEl) {
                dominantEl.textContent = frequencyData[0].frequency.toFixed(1);
            } else if (dominantEl) {
                dominantEl.textContent = '0.0';
            }
            if (centroidEl) centroidEl.textContent = spectralCentroid.toFixed(1);

            // Generate tokens and visualization
            generateTokens(frequencyData, audioEnergy, spectralCentroid);

            // Chaos display
            const chaos = calculateAudioChaos();
            const chaosEl = document.getElementById('audio-chaos');
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);
        }

        function generatePhiHarmonics(fundamental, count) {
            const harmonics = [];
            for (let i = 0; i < count; i++) {
                let freq = fundamental * Math.pow(phi, i / 2);
                
                // Octave folding
                while (freq > fundamental * 4) {
                    freq /= 2;
                }
                while (freq < fundamental / 2) {
                    freq *= 2;
                }
                
                harmonics.push(freq);
            }
            return harmonics.sort((a, b) => a - b);
        }

        function generateParticleToken(particle, eventType = 'creation') {
            // Token structure from 12D CST specification (extended with new fields)
            const token = {
                id: nextDeterministicId(), // Use deterministic ID in replay mode
                particleId: particle.id,
                frequency: parseFloat(particle.frequency.toFixed(2)),
                energy: parseFloat(particle.energy.toFixed(6)), // Legacy
                position: [
                    parseFloat(particle.x.toFixed(4)),
                    parseFloat(particle.y.toFixed(4)),
                    parseFloat(particle.z.toFixed(4))
                ],
                velocity: [
                    parseFloat(particle.velocity.x.toFixed(4)),
                    parseFloat(particle.velocity.y.toFixed(4)),
                    parseFloat(particle.velocity.z.toFixed(4))
                ],
                mass: parseFloat(particle.mass.toFixed(3)),
                entropy: parseFloat(particle.entropy.toFixed(3)), // Legacy
                timestamp: Date.now() / 1000, // Unix timestamp
                parent: particle.parent || null,
                eventType: eventType, // 'creation', 'replication', 'frequency_assignment'
                color: '#' + particle.color.toString(16).padStart(6, '0'),
                // 12D CST new fields
                x12: parseFloat(particle.x12.toFixed(4)),
                m12: parseFloat(particle.m12.toFixed(4)),
                Ec: parseFloat(particle.Ec.toFixed(6)),
                Ugrav: parseFloat(particle.Ugrav.toFixed(6)),
                Udm: parseFloat(particle.Udm.toFixed(6)),
                vi: parseFloat(particle.vi.toFixed(2)),
                theta: parseFloat(particle.theta.toFixed(4)),
                omega: parseFloat(particle.omega.toFixed(6)),
                entropyS: parseFloat(particle.entropyS.toFixed(6)),
                neighborCount: particle.neighbors ? particle.neighbors.length : 0,
                // CST v2.0+ additive: Include 11D projection data
                projection11D: {
                    pos11D: Array.from(particle.projection11D.pos11D).map(v => parseFloat(v.toFixed(6))),
                    vel11D: Array.from(particle.projection11D.vel11D).map(v => parseFloat(v.toFixed(6)))
                },
                trailCount: particle.points ? particle.points.length : 0,
                psiBreakdown: currentPsiSnapshot() // NEW: Include œà breakdown in token
            };
            
            // Add to particle's token list
            particle.tokens.push(token);
            
            // CST v2.0+ additive: Buffer token for batched UI updates
            addToken(token);
            
            return token;
        }

        function generateAudioFrameToken(frequencyData, rmsEnergy, spectralCentroid, harmonics) {
            // CONTINUOUS audio frame token - captures entire audio state
            // CST v2.0+ fix: Handle silent input gracefully
            const safeFreqData = frequencyData || [];
            const token = {
                id: nextDeterministicId(), // Use deterministic ID in replay mode
                type: 'audio_frame',
                timestamp: Date.now() / 1000,
                rmsEnergy: parseFloat((rmsEnergy || 0).toFixed(4)),
                spectralCentroid: parseFloat((spectralCentroid || 0).toFixed(2)),
                frequencyCount: safeFreqData.length,
                topFrequencies: safeFreqData.slice(0, 5).map(f => ({
                    freq: parseFloat(f.frequency.toFixed(2)),
                    magnitude: parseFloat(f.magnitude.toFixed(3))
                })),
                phiHarmonics: (harmonics || []).slice(0, 5).map(h => parseFloat(h.toFixed(2))),
                seed: generateAudioSeed(safeFreqData, rmsEnergy || 0), // Deterministic seed
                psi: calculatePsiFromAudio(safeFreqData, rmsEnergy || 0, spectralCentroid || 0),
                psiBreakdown: currentPsiSnapshot() // NEW: Include œà breakdown in token
            };
            
            // CST v2.0+ additive: Buffer token for batched UI updates
            addToken(token);
            
            return token;
        }

        function flashTokenIndicator() {
            const indicator = document.getElementById('tokenIndicator');
            indicator.classList.add('active');
            setTimeout(() => {
                // Keep it active while audio is processing
                if (!isAudioActive) {
                    indicator.classList.remove('active');
                }
            }, 100);
        }

        function generateHarmonicToken(harmonic, magnitude, index) {
            // Token for each phi-harmonic generated
            const token = {
                id: nextDeterministicId(), // Use deterministic ID in replay mode
                type: 'phi_harmonic',
                timestamp: Date.now() / 1000,
                harmonic: parseFloat(harmonic.toFixed(2)),
                magnitude: parseFloat(magnitude.toFixed(3)),
                harmonicIndex: index,
                phiRatio: Math.pow(phi, index / 2),
                colorMapping: frequencyToColor(harmonic),
                seed: hashFrequency(harmonic),
                psiBreakdown: currentPsiSnapshot() // NEW: Include œà breakdown in token
            };
            
            // CST v2.0+ additive: Buffer token for batched UI updates
            addToken(token);
            
            return token;
        }

        function generateAudioSeed(frequencyData, rmsEnergy) {
            // Generate deterministic seed from audio data
            let seedValue = 0;
            frequencyData.forEach((f, i) => {
                seedValue += f.frequency * f.magnitude * (i + 1);
            });
            seedValue += rmsEnergy * 10000;
            return Math.floor(seedValue) % 1000000;
        }

        function hashFrequency(frequency) {
            // Simple hash for frequency-based seed
            return Math.floor((frequency * phi) % 100000);
        }

        function frequencyToColor(frequency) {
            // Sound-to-color mapping
            const hue = (frequency / 20000) * 360;
            const saturation = 100;
            const lightness = 50;
            return `hsl(${hue.toFixed(0)}, ${saturation}%, ${lightness}%)`;
        }

        function calculatePsiFromAudio(frequencyData, rmsEnergy, spectralCentroid) {
            // Calculate œà directly from audio using the 12D formula
            const mass = 1;
            const energyComponent = (phi * mass * c * c * rmsEnergy) / (c * c);
            const lambdaComponent = Math.log(spectralCentroid + 1) / 100;
            const frequencyIntegral = frequencyData.reduce((sum, f) => sum + f.frequency * f.magnitude, 0) / 1000;
            const omegaComponent = frequencyData.length * rmsEnergy * phi;
            
            return energyComponent + phi + lambdaComponent + frequencyIntegral + omegaComponent;
        }

        function createParticleFromFrequency(frequency, magnitude, color) {
            // Create new particle from frequency data
            // CST v2.0+ additive: Use getRandom() for determinism in replay mode
            const offset = particles.length * 0.1;
            const particle = new LorenzParticle(
                getRandom() * 10 - 5,
                getRandom() * 10 - 5,
                getRandom() * 10 - 5,
                color,
                frequency,
                null
            );
            
            particle.mass = 1 + magnitude * 5;
            particle.energy = magnitude * 50;
            particles.push(particle);

            // Generate creation token
            generateParticleToken(particle, 'audio_creation');
        }

        function updateParticleFromAudio(particle, frequency, magnitude, color) {
            // Update existing particle with new audio data
            particle.frequency = frequency;
            particle.color = color;
            particle.line.material.color.setHex(color);
            particle.sphere.material.color.setHex(color);
            particle.mass = Math.max(1, particle.mass * (0.95 + magnitude * 0.1));
            
            // Generate frequency update token
            const token = {
                id: nextDeterministicId(), // Use deterministic ID in replay mode
                type: 'frequency_update',
                particleId: particle.id,
                frequency: parseFloat(frequency.toFixed(2)),
                magnitude: parseFloat(magnitude.toFixed(3)),
                color: '#' + color.toString(16).padStart(6, '0'),
                timestamp: Date.now() / 1000
            };
            
            // Add to particle's token list
            particle.tokens.push(token);
            
            // CST v2.0+ additive: Buffer token for batched UI updates
            addToken(token);
        }

        function calculateAudioChaos() {
            if (frequencyData.length < 2) return 0;
            
            let variance = 0;
            const mean = frequencyData.reduce((sum, d) => sum + d.magnitude, 0) / frequencyData.length;
            frequencyData.forEach(d => {
                variance += Math.pow(d.magnitude - mean, 2);
            });
            return Math.sqrt(variance / frequencyData.length);
        }

        function addParticleFromAudio(frequency, energy) {
            const offset = particles.length * 0.1;
            const hue = (frequency / 20000) * 360;
            const color = new THREE.Color();
            color.setHSL(hue / 360, 1.0, 0.5); // Fix: Use setHSL instead of HSL string

            const particle = new LorenzParticle(
                0.1 + offset + energy * 5,
                offset,
                offset,
                color.getHex(),
                frequency,
                null // No parent for audio-generated particles
            );
            
            particle.mass = 1 + energy * 10;
            particles.push(particle);

            // Generate creation token
            generateParticleToken(particle, 'creation');
            
            updateStatus(`Audio particle created: ${frequency.toFixed(1)}Hz, E=${energy.toFixed(3)}`);
        }

        // CST v2.0 additive: Enhanced token display with bounded view
        function updateTokenDisplay() {
            const display = document.getElementById('tokenDisplay');
            if (tokens.length === 0) {
                if (display) display.innerHTML = '<div class="token-item">Waiting for audio input...</div>';
                const countEl = document.getElementById('token-count');
                if (countEl) countEl.textContent = '0';
                return;
            }
            
            // CST v2.0+ additive: Use configurable token display limit
            const recentTokens = tokens.slice(-audioConfig.tokenDisplayLimit).reverse();
            display.innerHTML = recentTokens.map(t => {
                // Different display formats based on token type
                if (t.type === 'audio_frame') {
                    return `<div class="token-item">
                        <strong>üéµ AUDIO FRAME</strong> ${t.id.substr(0, 13)}...<br>
                        <strong>RMS:</strong> ${t.rmsEnergy} | <strong>Centroid:</strong> ${t.spectralCentroid}Hz<br>
                        <strong>Top Freq:</strong> ${t.topFrequencies[0]?.freq || 0}Hz<br>
                        <strong>Seed:</strong> ${t.seed} | <strong>œà:</strong> ${t.psi?.toFixed(2)}
                    </div>`;
                } else if (t.type === 'phi_harmonic') {
                    return `<div class="token-item">
                        <strong>üåÄ œÜ-HARMONIC #${t.harmonicIndex}</strong><br>
                        <strong>Freq:</strong> ${t.harmonic}Hz | <strong>Mag:</strong> ${t.magnitude}<br>
                        <strong>œÜ^${(t.harmonicIndex / 2).toFixed(1)}:</strong> ${t.phiRatio?.toFixed(3)}<br>
                        <strong>Color:</strong> <span style="color: ${t.colorMapping}">${t.colorMapping}</span> | <strong>Seed:</strong> ${t.seed}
                    </div>`;
                } else if (t.type === 'frequency_update') {
                    return `<div class="token-item">
                        <strong>üîÑ FREQ UPDATE</strong> Particle: ${t.particleId.substr(0, 8)}...<br>
                        <strong>Freq:</strong> ${t.frequency}Hz | <strong>Mag:</strong> ${t.magnitude}<br>
                        <strong>Color:</strong> <span style="color: ${t.color}">${t.color}</span>
                    </div>`;
                } else {
                    // Standard particle token
                    const parentInfo = t.parent ? `Parent: ${t.parent.substr(0, 8)}...` : 'No parent';
                    const posStr = `[${t.position[0].toFixed(1)}, ${t.position[1].toFixed(1)}, ${t.position[2].toFixed(1)}]`;
                    return `<div class="token-item">
                        <strong>‚öõÔ∏è ${t.eventType?.toUpperCase()}</strong> ${t.id.substr(0, 13)}...<br>
                        <strong>Freq:</strong> ${t.frequency}Hz | <strong>E:</strong> ${t.energy?.toFixed(3)}<br>
                        <strong>Pos:</strong> ${posStr}<br>
                        <strong>${parentInfo}</strong>
                    </div>`;
                }
            }).join('');
            
            // Smooth scroll to bottom if near bottom
            if (display) {
                requestAnimationFrame(() => {
                    const isNearBottom = display.scrollHeight - display.scrollTop - display.clientHeight < 50;
                    if (isNearBottom) {
                        display.scrollTop = display.scrollHeight;
                    }
                });
            }
        }

        // ============================================================================
        // ANIMATION MODULES - Real-time updates and smooth transitions
        // ============================================================================
        
        // State buffers for frequency spectrum smoothing
        let lastFreqBars = null;
        let freqLerp = 0.25; // smoothing factor
        
        // 1) Frequency spectrum animation
        function updateFrequencyViz(freqs, mags) {
            if (!freqCtx || !freqCanvas) return;
            
            // Use provided parameters or read from analyser
            let bars = null;
            let binCount = 0;
            let currentRMS = audioEnergy || 0;
            let currentDominantFreq = 0;
            let currentSpectralCentroid = 0;
            
            if (freqs && mags && freqs.length > 0) {
                // Use provided frequency data
                binCount = Math.max(freqs.length, 100); // Default to 100 bins if not specified
                bars = new Array(binCount).fill(0);
                freqs.forEach((f, i) => {
                    const bin = Math.min(binCount - 1, Math.floor((f / 20000) * binCount));
                    if (mags[i] !== undefined) {
                        bars[bin] = Math.max(bars[bin], mags[i]);
                    }
                });
                
                // Calculate RMS, dominant frequency, and spectral centroid from provided data
                if (mags.length > 0) {
                    const sumSq = mags.reduce((sum, m) => sum + m * m, 0);
                    currentRMS = Math.sqrt(sumSq / mags.length);
                    currentDominantFreq = freqs[0] || 0;
                    
                    // Calculate spectral centroid
                    let weightedSum = 0;
                    let magnitudeSum = 0;
                    freqs.forEach((f, i) => {
                        weightedSum += f * (mags[i] || 0);
                        magnitudeSum += (mags[i] || 0);
                    });
                    currentSpectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
                }
            } else if (analyser && dataArray && bufferLength > 0) {
                // Read from analyser (live audio)
                analyser.getByteFrequencyData(dataArray);
                binCount = bufferLength;
                bars = Array.from(dataArray, v => v / 255);
                
                // Calculate RMS from time domain data
                analyser.getByteTimeDomainData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    const normalized = (dataArray[i] - 128) / 128;
                    sum += normalized * normalized;
                }
                currentRMS = Math.sqrt(sum / dataArray.length);
                
                // Get dominant frequency and spectral centroid from frequency data
                analyser.getByteFrequencyData(dataArray);
                let maxMag = 0;
                let maxIdx = 0;
                let weightedSum = 0;
                let magnitudeSum = 0;
                if (audioContext && audioContext.sampleRate) {
                    for (let i = 0; i < dataArray.length; i++) {
                        const mag = dataArray[i] / 255;
                        if (mag > maxMag) {
                            maxMag = mag;
                            maxIdx = i;
                        }
                        const freq = (i * audioContext.sampleRate) / (2 * bufferLength);
                        weightedSum += freq * dataArray[i];
                        magnitudeSum += dataArray[i];
                    }
                    currentDominantFreq = (maxIdx * audioContext.sampleRate) / (2 * bufferLength);
                    currentSpectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
                }
            } else if (determinism.mode === 'replay' && frequencyData && frequencyData.length > 0) {
                // Use global frequencyData from replay mode
                binCount = 100; // Default bin count
                bars = new Array(binCount).fill(0);
                const freqs = frequencyData.map(f => f.frequency);
                const mags = frequencyData.map(f => f.magnitude);
                
                freqs.forEach((f, i) => {
                    const bin = Math.min(binCount - 1, Math.floor((f / 20000) * binCount));
                    if (mags[i] !== undefined) {
                        bars[bin] = Math.max(bars[bin], mags[i]);
                    }
                });
                
                currentRMS = audioEnergy || 0;
                currentDominantFreq = freqs.length > 0 ? freqs[0] : 0;
                
                // Calculate spectral centroid
                let weightedSum = 0;
                let magnitudeSum = 0;
                freqs.forEach((f, i) => {
                    weightedSum += f * (mags[i] || 0);
                    magnitudeSum += (mags[i] || 0);
                });
                currentSpectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : spectralCentroid || 0;
            } else {
                // No data available
                return;
            }

            // Update RMS energy, dominant frequency, and spectral centroid displays
            const rmsEl = document.getElementById('rms-energy');
            const dominantEl = document.getElementById('dominant-freq');
            const centroidEl = document.getElementById('spectral-centroid');
            if (rmsEl) rmsEl.textContent = currentRMS.toFixed(3);
            if (dominantEl) dominantEl.textContent = currentDominantFreq.toFixed(1);
            if (centroidEl) centroidEl.textContent = currentSpectralCentroid.toFixed(1);
            
            const width = freqCanvas.width;
            const height = freqCanvas.height;
            const barW = (width / binCount) * 2.0;

            // Prepare smoothed bars
            if (!lastFreqBars || lastFreqBars.length !== bars.length) {
                lastFreqBars = bars.slice();
            } else {
                for (let i = 0; i < bars.length; i++) {
                    lastFreqBars[i] = lastFreqBars[i] + freqLerp * (bars[i] - lastFreqBars[i]);
                }
            }
            
            // Clear canvas
            freqCtx.clearRect(0, 0, width, height);
            freqCtx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            freqCtx.fillRect(0, 0, width, height);
            
            // Draw bars with hue mapping (0‚Äì360)
            let x = 0;
            for (let i = 0; i < binCount; i++) {
                const hue = (i / binCount) * 360;
                const barH = lastFreqBars[i] * height;
                freqCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                freqCtx.fillRect(x, height - barH, barW, barH);
                x += barW + 1;
            }
        }
        
        // Legacy function for compatibility (calls new function)
        function drawFrequencySpectrum() {
            updateFrequencyViz();
        }
        
        // 2) Lorenz attractor particle animation update
        function updateLorenzParticles() {
            if (isPaused) return;

            // === PERPETUAL OPERATION SYSTEMS ===
            autoRegenerateParticles();      // Maintain minimum particle count
            injectSystemEnergy();            // Prevent heat death
            selfHealingCheck();              // Fix broken states
            generateFallbackAudio();         // Synthetic audio if no input

            // Validate all particles before processing
            particles.forEach(p => sanitizeParticleState(p));

            if (particles.length === 0) return;

            // Adaptive dt is updated in animate() before this call
            const spatialIndex = buildSpatialIndex(particles, physics.rCutoff);
            const gravAccelerations = computeGravitationalAccelerations(particles, spatialIndex, physics);
            computeGravitationalEnergy(particles, spatialIndex, physics);
            computeDarkMatterPotential(particles, dmParams);
            computeSynapticStrength(particles, spatialIndex, physics, adapt);

            // === AUDIO-TO-INTERNAL-STATE MAPPING (12D CST Section 5) ===
            if (isAudioActive && frequencyData && frequencyData.length > 0) {
                // Extract audio features for mapping
                const audioFrequencies = frequencyData.map(f => f.frequency || 0);
                const audioMagnitudes = frequencyData.map(f => f.magnitude || 0);
                const rmsEnergy = audioEnergy || 0;
                const spectralCentroid = calculateSpectralCentroid(frequencyData);

                // Map audio features to each particle's 12D parameters
                particles.forEach(particle => {
                    mapAudioToInternalState(
                        particle,
                        audioFrequencies,
                        audioMagnitudes,
                        rmsEnergy,
                        spectralCentroid
                    );
                });
            }

            // === UPDATE MEMORY FROM NEIGHBORS ===
            if (frequencyData && frequencyData.length > 0) {
                particles.forEach(particle => {
                    updateMemoryFromNeighbors(particle, particles, frequencyData);
                });
            }

            // === UPDATE 12TH DIMENSION EVOLUTION ===
            updateAdaptiveStates(particles, adapt, timestep.dt);
            updatePhases(particles, sync, spatialIndex, timestep.dt);

            // Audio modulation
                const audioMod = isAudioActive ? audioEnergy * audioSensitivity : 0;

            // Update particle trajectories and visuals
                let chaosSum = 0;
            particles.forEach((p, i) => {
                const accel = gravAccelerations[i];
                const d = p.update(audioMod, accel);
                chaosSum += Math.abs(d.dx) + Math.abs(d.dy) + Math.abs(d.dz);
                });

            // Recompute energies, vi, and complete 12D state function (œà)
            particles.forEach(p => {
                const v2 = p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z;
                const K = 0.5 * p.mass * v2;
                p.Ec = K + p.Ugrav + p.Udm;
                p.vi = p.Ec / h;

                // Compute complete 12D state function (Section 2.8)
                p.psi = computeParticlePsi(p);
            });
            
            // Entropy every N frames (performance)
                if (frameCount % 10 === 0) {
                    computeEntropy(particles, kB, 32);
                }

            // œà normalized breakdown
            const psiResult = updatePsiNormalized(particles, physics, psiAccumulators);
            updatePsi(chaosSum, psiResult);
            
            // Camera slow orbit
            const t = Date.now() * 0.0001;
            camera.position.x = Math.cos(t) * 60;
            camera.position.z = Math.sin(t) * 60;
            camera.lookAt(0, 20, 0);
            
            // Conservation and virial (batched updates)
                const consStats = computeConservationStats(particles);
                if (conservationStats.E0 === 0) {
                    conservationStats.E0 = consStats.Etotal;
                conservationStats.P0 = { ...consStats.P };
                conservationStats.L0 = { ...consStats.L };
                }
            const virial = checkVirial(particles);
            const syncMetric = computeSynchronizationMetric(particles);

            // UI updates throttled
            if (frameCount % Math.floor(60 / Math.max(timestep.dt, 0.01)) === 0) {
                updateAdvancedUI(consStats, virial, psiResult, syncMetric);
            }

            // === POST-UPDATE VALIDATION ===
            // Ensure no NaN leaked through
            particles.forEach(p => {
                sanitizeParticleState(p);

                // Extra check for psi
                if (!isFinite(p.psi)) {
                    p.psi = 0;
                    console.warn('[NaN-GUARD] Reset invalid psi for particle', p.id.substring(0, 8));
                }
            });

            // Update perpetual system status display (every 60 frames)
            if (frameCount % 60 === 0) {
                updatePerpetualStatus();
            }
        }
        
        // CST v2.0+ additive: Enhanced token tracking with buffering
        // Add token to buffer for batched UI updates
        function addToken(tokenObj) {
            if (!tokenObj) return;
            
            // CST v2.0+ additive: Record timestamp for rate calculation
            const now = Date.now();
            tokenRateWindow.timestamps.push(now);
            
            // CST v2.0+ additive: Buffer token instead of immediately updating UI
            tokenBuffer.tokens.push(tokenObj);
            
            // Flash indicator briefly (immediate feedback)
            const indicator = document.getElementById('tokenIndicator');
            if (indicator) {
                indicator.classList.add('active');
                setTimeout(() => {
                    indicator.classList.remove('active');
                }, 100);
            }
            }
            
        // CST v2.0 fix: updateTokenStream now only handles UI updates, not token generation
        // Token generation is handled by processAudio() via setInterval for exact 100ms cadence
        function updateTokenStream() {
            // Token generation is now handled by processAudio() and processReplayAudio()
            // This function only handles UI updates and scrolling
            
            // Smooth scroll to bottom
            const display = document.getElementById('tokenDisplay');
            if (!display) return;
            
            // Only scroll if near bottom (within 50px) to avoid interrupting user scrolling
            const isNearBottom = display.scrollHeight - display.scrollTop - display.clientHeight < 50;
            if (isNearBottom) {
                display.scrollTop = display.scrollHeight;
            }
            
            // Update token count if changed (for non-audio token sources)
            if (tokens.length !== lastTokenCount) {
                const countEl = document.getElementById('token-count');
                const countStatusEl = document.getElementById('token-count-status');
                if (countEl) countEl.textContent = tokens.length;
                if (countStatusEl) countStatusEl.textContent = tokens.length;
                lastTokenCount = tokens.length;
            }
        }
        
        // CST v2.0 additive: Enhanced token rate calculation with rolling window
        function updateTokenRate() {
            const now = Date.now();
            const windowSize = 2000;
            tokenRateWindow.timestamps = tokenRateWindow.timestamps.filter(ts => ts > (now - windowSize));
            
                const rateEl = document.getElementById('token-rate');
            const span = tokenRateWindow.timestamps.length > 0
                ? (now - tokenRateWindow.timestamps[0]) / 1000
                : 0;
            const rate = span > 0 ? tokenRateWindow.timestamps.length / span : 0;
            if (rateEl) rateEl.textContent = rate.toFixed(1);
            tokenGenerationRate = rate;
        }
        
        // Alias for compatibility
        function updateTokenCountersOncePerSecond() {
            updateTokenRate();
        }
        
        // CST v2.5+ ULTIMATE ENHANCEMENT: 12D Quantum-Correlated Chaos Analysis
        // Global state for chaos tracking
        let chaosTracker = {
            referenceStates: [],
            lyapunovHistory: [],
            maxHistory: 100,
            lastUpdate: 0,
            attractorSamples: [],
            maxAttractorSamples: 200
        };

        // 4) Chaos, Lyapunov, and synchronization displays
        function updateChaosMetrics() {
            const chaos = calculateAudioChaos();
            let lyapunov = 0;
            let attractorDim = 0;
            let chaosRegime = 'UNKNOWN';

            if (particles.length > 0) {
                // === 12D LYAPUNOV EXPONENT ===
                // Track divergence in full 12D phase space: (x, y, z, vx, vy, vz, x12, m12, dx12_dt, dm12_dt, theta, psi)
                lyapunov = compute12DLyapunovExponent();

                // === ATTRACTOR DIMENSION (Correlation Dimension) ===
                attractorDim = computeAttractorDimension();

                // === CHAOS REGIME CLASSIFICATION ===
                chaosRegime = classifyChaosRegime(lyapunov);

                // Store in history
                chaosTracker.lyapunovHistory.push(lyapunov);
                if (chaosTracker.lyapunovHistory.length > chaosTracker.maxHistory) {
                    chaosTracker.lyapunovHistory.shift();
                }
            }

            const lyEl = document.getElementById('lyapunov-value');
            const chaosEl = document.getElementById('audio-chaos');
            const regimeEl = document.getElementById('chaos-regime');
            const dimEl = document.getElementById('attractor-dimension');

            if (lyEl) lyEl.textContent = lyapunov.toFixed(3);
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);
            if (regimeEl) regimeEl.textContent = chaosRegime;
            if (dimEl) dimEl.textContent = attractorDim.toFixed(2);
        }

        // CST v2.5+ NEW: Compute 12D Lyapunov Exponent
        function compute12DLyapunovExponent() {
            if (particles.length < 2) return 0;

            // Sample a reference particle
            const refIndex = Math.floor(particles.length / 2);
            const epsilon = 1e-8;

            // Get current 12D state
            const p = particles[refIndex];
            const state = [
                p.x, p.y, p.z,
                p.velocity.x, p.velocity.y, p.velocity.z,
                isFinite(p.x12) ? p.x12 : 0,
                isFinite(p.m12) ? p.m12 : 0,
                isFinite(p.dx12_dt) ? p.dx12_dt : 0,
                isFinite(p.dm12_dt) ? p.dm12_dt : 0,
                isFinite(p.theta) ? p.theta : 0,
                isFinite(p.psi) ? p.psi : 0
            ];

            // Calculate state divergence across all particles
            let totalDivergence = 0;
            particles.forEach(other => {
                if (other === p) return;

                const otherState = [
                    other.x, other.y, other.z,
                    other.velocity.x, other.velocity.y, other.velocity.z,
                    isFinite(other.x12) ? other.x12 : 0,
                    isFinite(other.m12) ? other.m12 : 0,
                    isFinite(other.dx12_dt) ? other.dx12_dt : 0,
                    isFinite(other.dm12_dt) ? other.dm12_dt : 0,
                    isFinite(other.theta) ? other.theta : 0,
                    isFinite(other.psi) ? other.psi : 0
                ];

                // Euclidean distance in 12D phase space
                let distance = 0;
                for (let i = 0; i < state.length; i++) {
                    const diff = state[i] - otherState[i];
                    distance += diff * diff;
                }
                distance = Math.sqrt(distance);

                totalDivergence += distance;
            });

            const avgDivergence = totalDivergence / Math.max(particles.length - 1, 1);

            // Lyapunov exponent: Œª = ln(d / epsilon) / t
            // Using normalized time and small perturbations
            const lambda = avgDivergence > epsilon ? Math.log(avgDivergence / (epsilon * 100)) * 0.1 : 0;

            return Math.max(0, Math.min(lambda, 3)); // Clamp to reasonable range
        }

        // CST v2.5+ NEW: Compute Attractor Dimension (Correlation Dimension)
        function computeAttractorDimension() {
            if (particles.length < 3) return 0;

            // Sample particle states in 12D space
            const now = Date.now();
            if (now - (chaosTracker.lastUpdate || 0) > 100) { // Sample every 100ms
                chaosTracker.lastUpdate = now;

                // Sample first few particles
                const sample = particles.slice(0, Math.min(10, particles.length)).map(p => ({
                    x12: isFinite(p.x12) ? p.x12 : 0,
                    dx12_dt: isFinite(p.dx12_dt) ? p.dx12_dt : 0,
                    psi: isFinite(p.psi) ? p.psi : 0
                }));

                chaosTracker.attractorSamples.push(sample);
                if (chaosTracker.attractorSamples.length > chaosTracker.maxAttractorSamples) {
                    chaosTracker.attractorSamples.shift();
                }
            }

            if (chaosTracker.attractorSamples.length < 10) return 0;

            // Simplified correlation dimension calculation
            // Count pairs within distance r
            const r = 0.5; // Distance threshold
            let pairsWithinR = 0;
            let totalPairs = 0;

            for (let i = 0; i < Math.min(chaosTracker.attractorSamples.length, 50); i++) {
                for (let j = i + 1; j < Math.min(chaosTracker.attractorSamples.length, 50); j++) {
                    const s1 = chaosTracker.attractorSamples[i][0];
                    const s2 = chaosTracker.attractorSamples[j][0];

                    if (s1 && s2) {
                        const dist = Math.sqrt(
                            (s1.x12 - s2.x12)**2 +
                            (s1.dx12_dt - s2.dx12_dt)**2 +
                            (s1.psi - s2.psi)**2
                        );

                        if (dist < r) pairsWithinR++;
                        totalPairs++;
                    }
                }
            }

            // Estimate correlation dimension
            const correlation = totalPairs > 0 ? pairsWithinR / totalPairs : 0;
            const dim = correlation > 0 ? -Math.log(correlation) / Math.log(r) : 0;

            return Math.max(0, Math.min(dim, 12)); // Clamp to [0, 12]
        }

        // CST v2.5+ NEW: Classify Chaos Regime
        function classifyChaosRegime(lambda) {
            if (lambda < 0.1) return 'ORDERED (stable)';
            else if (lambda >= 0.1 && lambda < 0.5) return 'EDGE-OF-CHAOS';
            else if (lambda >= 0.5 && lambda < 1.5) return 'WEAKLY CHAOTIC';
            else return 'STRONGLY CHAOTIC';
        }
        
        // 5) Conservation diagnostics animation
        function updateConservationDiagnostics() {
            if (particles.length === 0) return;
            
            const consStats = computeConservationStats(particles);
            const virial = checkVirial(particles);
            
            const eTotalEl = document.getElementById('conservation-etotal');
            const eDriftEl = document.getElementById('conservation-edrift');
            const pMagEl = document.getElementById('conservation-pmag');
            const lMagEl = document.getElementById('conservation-lmag');
            const virialEl = document.getElementById('conservation-virial');
            
            if (eTotalEl) eTotalEl.textContent = consStats.Etotal.toExponential(2);
            if (eDriftEl) eDriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
            if (pMagEl) pMagEl.textContent = Math.sqrt(consStats.P.x**2 + consStats.P.y**2 + consStats.P.z**2).toExponential(2);
            if (lMagEl) lMagEl.textContent = Math.sqrt(consStats.L.x**2 + consStats.L.y**2 + consStats.L.z**2).toExponential(2);
            if (virialEl) virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
        }
        
        // 6) Replay and determinism feedback
        function reflectDeterminismUI() {
            const status = document.getElementById('recording-status');
            const replayBtn = document.getElementById('replay-btn');
            if (!status || !replayBtn) return;
            
            if (determinism.isRecording) {
                status.textContent = `Recording audio frames... (${determinism.recordedAudioFrames.length} frames)`;
            } else {
                status.textContent = `Recording stopped. ${determinism.recordedAudioFrames.length} frames recorded.`;
            }
            replayBtn.textContent = determinism.mode === 'replay' ? '‚èπÔ∏è Stop Replay' : '‚ñ∂Ô∏è Replay';
        }
        
        // Standalone synchronization metrics update function
        function updateSynchronizationMetrics() {
            if (particles.length === 0) return;
            
            const syncMetric = computeSynchronizationMetric(particles);
            const syncREl = document.getElementById('sync-r');
            const syncMeanEl = document.getElementById('sync-mean');
            const syncStdEl = document.getElementById('sync-std');
            
            if (syncREl) syncREl.textContent = syncMetric.r.toFixed(3);
            if (syncMeanEl) syncMeanEl.textContent = (syncMetric.meanTheta * 180 / Math.PI).toFixed(1) + '¬∞';
            const thetaStd = computeThetaStd(particles);
            if (syncStdEl) syncStdEl.textContent = (thetaStd * 180 / Math.PI).toFixed(1) + '¬∞';
        }

        /**
         * Update 12D Internal State Metrics Display
         * Shows real-time statistics for the 12th dimension evolution
         */
        function update12DMetrics() {
            if (particles.length === 0) {
                // Reset all displays to zero
                const avgX12El = document.getElementById('12d-avg-x12');
                const avgM12El = document.getElementById('12d-avg-m12');
                const avgOmegaEl = document.getElementById('12d-avg-omega');
                const avgDx12El = document.getElementById('12d-avg-dx12');
                const avgPsiEl = document.getElementById('12d-avg-psi');
                const x12MinEl = document.getElementById('12d-x12-min');
                const x12MaxEl = document.getElementById('12d-x12-max');

                if (avgX12El) avgX12El.textContent = '0.000';
                if (avgM12El) avgM12El.textContent = '0.000';
                if (avgOmegaEl) avgOmegaEl.textContent = '0.000';
                if (avgDx12El) avgDx12El.textContent = '0.000';
                if (avgPsiEl) avgPsiEl.textContent = '0.000';
                if (x12MinEl) x12MinEl.textContent = '0.00';
                if (x12MaxEl) x12MaxEl.textContent = '0.00';
                return;
            }

            // Calculate 12D metrics
            let sumX12 = 0, sumM12 = 0, sumOmega = 0, sumDx12 = 0, sumPsi = 0;
            let minX12 = Infinity, maxX12 = -Infinity;

            particles.forEach(p => {
                const x12 = isFinite(p.x12) ? p.x12 : 0;
                const m12 = isFinite(p.m12) ? p.m12 : 0;
                const omega = isFinite(p.omega) ? p.omega : 0;
                const dx12 = isFinite(p.dx12_dt) ? Math.abs(p.dx12_dt) : 0;
                const psi = isFinite(p.psi) ? p.psi : 0;

                sumX12 += x12;
                sumM12 += m12;
                sumOmega += omega;
                sumDx12 += dx12;
                sumPsi += psi;

                minX12 = Math.min(minX12, x12);
                maxX12 = Math.max(maxX12, x12);
            });

            const avgX12 = sumX12 / particles.length;
            const avgM12 = sumM12 / particles.length;
            const avgOmega = sumOmega / particles.length;
            const avgDx12 = sumDx12 / particles.length;
            const avgPsi = sumPsi / particles.length;

            // Update display elements
            const avgX12El = document.getElementById('12d-avg-x12');
            const avgM12El = document.getElementById('12d-avg-m12');
            const avgOmegaEl = document.getElementById('12d-avg-omega');
            const avgDx12El = document.getElementById('12d-avg-dx12');
            const avgPsiEl = document.getElementById('12d-avg-psi');
            const x12MinEl = document.getElementById('12d-x12-min');
            const x12MaxEl = document.getElementById('12d-x12-max');

            if (avgX12El) avgX12El.textContent = avgX12.toFixed(3);
            if (avgM12El) avgM12El.textContent = avgM12.toFixed(3);
            if (avgOmegaEl) avgOmegaEl.textContent = avgOmega.toExponential(2);
            if (avgDx12El) avgDx12El.textContent = avgDx12.toExponential(2);
            if (avgPsiEl) avgPsiEl.textContent = avgPsi.toExponential(2);
            if (x12MinEl) x12MinEl.textContent = minX12.toFixed(2);
            if (x12MaxEl) x12MaxEl.textContent = maxX12.toFixed(2);
        }

        // Standalone œà breakdown update function
        // CST v2.0+ fix: Ensures all œà normalized breakdown terms update in real-time
        function updatePsiBreakdown() {
            if (particles.length === 0) {
                // Reset displays to zero when no particles
                const psiEnergyEl = document.getElementById('psi-energy-term');
                const psiLambdaEl = document.getElementById('psi-lambda-term');
                const psiVelIntEl = document.getElementById('psi-velint-term');
                const psiX12IntEl = document.getElementById('psi-x12int-term');
                const psiX12IntAvgEl = document.getElementById('psi-x12int-avg');
                const psiX12IntMaxEl = document.getElementById('psi-x12int-max');
                const psiOmegaEl = document.getElementById('psi-omega-term');
                const psiPotentialEl = document.getElementById('psi-potential-term');
                const psiTotalEl = document.getElementById('psi-total-normalized');

                if (psiEnergyEl) psiEnergyEl.textContent = '0.000';
                if (psiLambdaEl) psiLambdaEl.textContent = '0.000';
                if (psiVelIntEl) psiVelIntEl.textContent = '0.000';
                if (psiX12IntEl) psiX12IntEl.textContent = '0.000';
                if (psiX12IntAvgEl) psiX12IntAvgEl.textContent = '0.000';
                if (psiX12IntMaxEl) psiX12IntMaxEl.textContent = '0.000';
                if (psiOmegaEl) psiOmegaEl.textContent = '0.000';
                if (psiPotentialEl) psiPotentialEl.textContent = '0.000';
                if (psiTotalEl) psiTotalEl.textContent = '0.000';
                return;
            }
            
            // CST v2.0+ fix: Calculate œà breakdown with current particle states
            const psiResult = updatePsiNormalized(particles, physics, psiAccumulators);
            
            const psiEnergyEl = document.getElementById('psi-energy-term');
            const psiLambdaEl = document.getElementById('psi-lambda-term');
            const psiVelIntEl = document.getElementById('psi-velint-term');
            const psiX12IntEl = document.getElementById('psi-x12int-term');
            const psiX12IntAvgEl = document.getElementById('psi-x12int-avg');
            const psiX12IntMaxEl = document.getElementById('psi-x12int-max');
            const psiOmegaEl = document.getElementById('psi-omega-term');
            const psiPotentialEl = document.getElementById('psi-potential-term');
            const psiTotalEl = document.getElementById('psi-total-normalized');

            // CST v2.0+ fix: Update all terms with proper formatting (show at least 3 decimals)
            if (psiEnergyEl) psiEnergyEl.textContent = psiResult.terms.energyTerm.toFixed(3);
            if (psiLambdaEl) psiLambdaEl.textContent = psiResult.terms.lambdaTerm.toFixed(3);
            if (psiVelIntEl) psiVelIntEl.textContent = psiResult.terms.velocityIntegralTerm.toFixed(3);
            if (psiX12IntEl) psiX12IntEl.textContent = psiResult.terms.x12IntegralTerm.toFixed(3);
            if (psiX12IntAvgEl) psiX12IntAvgEl.textContent = (psiResult.x12IntAvg || 0).toFixed(3);
            if (psiX12IntMaxEl) psiX12IntMaxEl.textContent = (psiResult.x12IntMax || 0).toFixed(3);
            if (psiOmegaEl) psiOmegaEl.textContent = psiResult.terms.omegaTerm.toFixed(3);
            if (psiPotentialEl) psiPotentialEl.textContent = psiResult.terms.potentialTerm.toFixed(3);
            if (psiTotalEl) psiTotalEl.textContent = psiResult.psiTotal.toFixed(3);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!isPaused) {
                try {
                    // === ADAPTIVE TIMESTEP ===
                    const adaptiveDtCheckbox = document.getElementById('adaptive-dt');
                    if (adaptiveDtCheckbox && adaptiveDtCheckbox.checked && particles.length > 0) {
                        timestep.dt = computeAdaptiveDt(particles, physics, timestep);
                    }

                    // === UPDATE PHYSICS ===
                    if (particles.length > 0) {
                        updateLorenzParticles();
                    }

                    // === DRAW VISUALIZATIONS ===
                    drawFrequencySpectrum();

                    // === UPDATE METRICS ===
                    updateChaosMetrics();
                    updateSynchronizationMetrics();
                    update12DMetrics(); // Update 12D internal state metrics display
                    updateConservationDiagnostics();
                    updatePsiBreakdown();

                    // === UPDATE ENTROPY ===
                    if (frameCount % 2 === 0 || frameCount === 0) {
                        updateEntropy();
                    } else {
                        if (particles.length > 0) {
                            const { entropy, histogram, tempProxy } = computeEntropyMetrics();
                            entropyState.lastEntropy = kB * entropy;
                            entropyState.histogram = histogram;
                            entropyState.tempProxy = tempProxy;

                            const entropyEl = document.getElementById('entropy-global');
                            const binsEl = document.getElementById('entropy-bins');
                            const tempEl = document.getElementById('entropy-temperature');

                            if (entropyEl) entropyEl.textContent = entropyState.lastEntropy.toFixed(3);
                            if (binsEl) binsEl.textContent = JSON.stringify(histogram.slice(0, 5));
                            if (tempEl) tempEl.textContent = tempProxy.toFixed(3);
                        }
                    }
                    if (frameCount % 10 === 0 || frameCount === 0) {
                        drawEntropyHistogram(entropyState.histogram);
                    }

                    // === UPDATE TOKEN STREAM ===
                    updateTokenStream();

                    // === UPDATE ADAPTIVE STATE TRACE ===
                    updateAdaptiveStateTrace();

                    // === UPDATE NEW ANALYSIS SYSTEMS (CST Enhanced) ===
                    if (frameCount % 10 === 0) {
                        energyTracker.recordEnergyState();
                        energyTracker.displayEnergyBudget();

                        syncAnalyzer.recordSynchronizationState();
                        syncAnalyzer.displaySynchronizationMetrics();

                        emergenceDetector.recordEmergenceState();
                        emergenceDetector.displayEmergenceMetrics();

                        updateMemoryVisualization();
                    }

                    if (frameCount % 50 === 0 && learnedProjector) {
                        trainLearnedProjector();
                    }

                    if (frameCount % 100 === 0) {
                        obsComparison.displayComparison();
                    }

                    // === CST v2.0 COMPLETION: NEW ANALYSIS SYSTEMS ===
                    // Update chaos measurements every 20 frames
                    if (frameCount % 20 === 0) {
                        const chaosMetrics = chaosMeasurement.recordDivergence();
                        const regime = chaosMeasurement.getChaoticRegime();

                        // Update display if elements exist
                        const lyapEl = document.getElementById('lyapunov-value');
                        const regimeEl = document.getElementById('chaos-regime');
                        const dimEl = document.getElementById('attractor-dimension');
                        if (lyapEl) lyapEl.textContent = chaosMetrics.lyapunov.toFixed(3);
                        if (regimeEl) regimeEl.textContent = regime.toUpperCase();
                        if (dimEl) dimEl.textContent = chaosMetrics.dimension.toFixed(2);
                    }

                    // Update stochastic resonance every 100 frames
                    if (frameCount % 100 === 0) {
                        stochasticResonanceDetector.detectResonantFrequency();
                        const snr = stochasticResonanceDetector.recordSNR();
                        const enhancement = stochasticResonanceDetector.detectSREnhancement();

                        // Update display if elements exist
                        const snrEl = document.getElementById('sr-snr');
                        const noiseEl = document.getElementById('sr-noise');
                        const enhanceEl = document.getElementById('sr-enhancement');
                        if (snrEl) snrEl.textContent = snr.toFixed(2);
                        if (noiseEl && stochasticResonanceDetector.optimalNoise) {
                            noiseEl.textContent = stochasticResonanceDetector.optimalNoise.toFixed(3);
                        }
                        if (enhanceEl && enhancement) {
                            enhanceEl.textContent = enhancement.isEnhanced ? 'YES' : 'NO';
                        }

                        // Find optimal noise periodically
                        if (frameCount % 500 === 0) {
                            const result = stochasticResonanceDetector.findOptimalNoise();
                            console.log('[CST SR] Optimal noise level:', result.optimalNoise.toFixed(3));
                        }
                    }
                } catch (error) {
                    console.error('[CST Animate Error]', error);
                    console.error('[CST Animate Error] Stack:', error.stack);
                    // Continue animation despite error
                }
            }

            try {
                // === RENDER ===
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            } catch (error) {
                console.error('[CST Render Error]', error);
            }

            try {
                // === UPDATE DISPLAYS ===
                frameCount++;
                const now = performance.now();
                if (now >= lastTime + 1000) {
                    const actualFPS = frameCount;
                    const fpsEl = document.getElementById('fps');
                    if (fpsEl) fpsEl.textContent = actualFPS.toFixed(1);
                    const particleEl = document.getElementById('particle-count');
                    const tokenEl = document.getElementById('token-count-status');
                    const replEl = document.getElementById('replication-count');
                    if (particleEl) particleEl.textContent = particles.length;
                    if (tokenEl) tokenEl.textContent = tokens.length;
                    if (replEl) replEl.textContent = replicationCount;
                    frameCount = 0;
                    lastTime = now;
                }
            } catch (error) {
                console.error('[CST Display Update Error]', error);
            }
        }
        
        // Update advanced UI displays
        function updateAdvancedUI(consStats, virial, psiResult, syncMetric) {
            // Update conservation displays if elements exist
            const eTotalEl = document.getElementById('conservation-etotal');
            const eDriftEl = document.getElementById('conservation-edrift');
            const pMagEl = document.getElementById('conservation-pmag');
            const lMagEl = document.getElementById('conservation-lmag');
            const virialEl = document.getElementById('conservation-virial');
            
            if (eTotalEl) eTotalEl.textContent = consStats.Etotal.toExponential(2);
            if (eDriftEl) eDriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
            if (pMagEl) pMagEl.textContent = Math.sqrt(consStats.P.x**2 + consStats.P.y**2 + consStats.P.z**2).toExponential(2);
            if (lMagEl) lMagEl.textContent = Math.sqrt(consStats.L.x**2 + consStats.L.y**2 + consStats.L.z**2).toExponential(2);
            if (virialEl) virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
            
            // Update synchronization displays
            const syncREl = document.getElementById('sync-r');
            const syncMeanEl = document.getElementById('sync-mean');
            if (syncREl) syncREl.textContent = syncMetric.r.toFixed(3);
            if (syncMeanEl) syncMeanEl.textContent = (syncMetric.meanTheta * 180 / Math.PI).toFixed(1) + '¬∞';
            
            // Update psi breakdown displays
            const psiEnergyEl = document.getElementById('psi-energy-term');
            const psiLambdaEl = document.getElementById('psi-lambda-term');
            const psiVelIntEl = document.getElementById('psi-velint-term');
            const psiX12IntEl = document.getElementById('psi-x12int-term');
            const psiX12IntAvgEl = document.getElementById('psi-x12int-avg');
            const psiX12IntMaxEl = document.getElementById('psi-x12int-max');
            const psiOmegaEl = document.getElementById('psi-omega-term');
            const psiPotentialEl = document.getElementById('psi-potential-term');
            const psiTotalEl = document.getElementById('psi-total-normalized');

            if (psiEnergyEl) psiEnergyEl.textContent = psiResult.terms.energyTerm.toFixed(3);
            if (psiLambdaEl) psiLambdaEl.textContent = psiResult.terms.lambdaTerm.toFixed(3);
            if (psiVelIntEl) psiVelIntEl.textContent = psiResult.terms.velocityIntegralTerm.toFixed(3);
            if (psiX12IntEl) psiX12IntEl.textContent = psiResult.terms.x12IntegralTerm.toFixed(3);
            if (psiX12IntAvgEl) psiX12IntAvgEl.textContent = (psiResult.x12IntAvg || 0).toFixed(3);
            if (psiX12IntMaxEl) psiX12IntMaxEl.textContent = (psiResult.x12IntMax || 0).toFixed(3);
            if (psiOmegaEl) psiOmegaEl.textContent = psiResult.terms.omegaTerm.toFixed(3);
            if (psiPotentialEl) psiPotentialEl.textContent = psiResult.terms.potentialTerm.toFixed(3);
            if (psiTotalEl) psiTotalEl.textContent = psiResult.psiTotal.toFixed(3);
            
            // NEW: show validation during replay
            updateReplayValidation(consStats, virial);
        }

        function addParticle() {
            const offset = particles.length * 0.1;
            const color = new THREE.Color();
            color.setHSL((colorHue + offset * 30) / 360, 1.0, 0.5); // Fix: Use setHSL instead of HSL string
            const particle = new LorenzParticle(0.1 + offset, offset, offset, color.getHex(), 440 + offset * 100);
            particles.push(particle);
            
            // Generate creation token
            generateParticleToken(particle, 'creation');
            
            updateStatus(`Added trajectory ${particles.length}`);
        }

        function resetSystem() {
            particles.forEach(p => p.destroy());
            particles = [];
            tokens = [];
            tokenCount = 0;
            replicationCount = 0;
            tokenRateWindow.timestamps = []; // CST v2.0+ fix: Clear token rate window
            // Reset conservation stats, psi accumulators, and entropy
            resetIntegralsAndConservation();
            // NEW: Reset entropy smoothing and adaptive state history
            entropyEma = null;
            x12History = [];
            updateEntropy(); // Update UI immediately
            updateTokenDisplay();
            addParticle();
            updateStatus('System reset - New trajectory initialized');
        }

        function togglePause() {
            isPaused = !isPaused;
            updateStatus(isPaused ? 'Simulation paused' : 'Simulation running');
        }

        function changeColor() {
            colorHue = (colorHue + 60) % 360;
            particles.forEach((p, i) => {
                const color = new THREE.Color();
                color.setHSL((colorHue + i * 30) / 360, 1.0, 0.5); // Fix: Use setHSL instead of HSL string
                p.line.material.color.setHex(color.getHex());
                p.sphere.material.color.setHex(color.getHex());
            });
            updateStatus('Color scheme updated');
        }

        function updatePsi(chaosSum, psiResult = null) {
            const mass = 1;
            const energy = mass * c * c;
            const audioGain = 1 + (isAudioActive ? audioEnergy * audioSensitivity : 0);
            const energyComponent = mass * audioGain;
            
            // Calculate Lyapunov approximation
            const audioChaos = isAudioActive ? calculateAudioChaos() : 0;
            const lyapunov = Math.abs(Math.log(Math.abs(chaosSum) + 1) / 10) + audioChaos;
            
            document.getElementById('energy-value').textContent = (energy * audioGain).toExponential(2);
            document.getElementById('lyapunov-value').textContent = lyapunov.toFixed(3);
            
            // Calculate œà components (legacy display)
                const psiEnergy = energyComponent;
                const psiPhi = phi;
                const psiLambda = lyapunov;
                const psiOmega = chaosSum;
            const psiTotal = psiResult ? psiResult.psiTotal : (psiEnergy + psiPhi + psiLambda + psiOmega);
                
                document.getElementById('psi-energy').textContent = psiEnergy.toFixed(3);
                document.getElementById('psi-phi').textContent = psiPhi.toFixed(3);
                document.getElementById('psi-lambda').textContent = psiLambda.toFixed(3);
                document.getElementById('psi-omega').textContent = psiOmega.toFixed(2);
                document.getElementById('psi-total').textContent = psiTotal.toFixed(3);
        }

        function updateStatus(message) {
            const statusEl = document.getElementById('system-status');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }

        // CST v2.0+ additive: Compute recording hash for deterministic verification
        // Uses FNV-1a hash algorithm for integrity verification
        function computeRecordingHash(frames, seed) {
            // FNV-1a hash (32-bit)
            let hash = 2166136261; // FNV offset basis
            
            // Hash seed
            const seedStr = String(seed || determinism.seed || projectionConfig.randomSeed || 0);
            for (let i = 0; i < seedStr.length; i++) {
                hash ^= seedStr.charCodeAt(i);
                hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
            }
            
            // Hash frame data (first 100 frames for performance)
            const frameCount = Math.min(frames.length, 100);
            for (let i = 0; i < frameCount; i++) {
                const frame = frames[i];
                const rms = (frame.rmsEnergy || frame.rms || 0).toFixed(6);
                const centroid = (frame.spectralCentroid || 0).toFixed(2);
                const hashStr = `${i}:${rms}:${centroid}`;
                
                for (let j = 0; j < hashStr.length; j++) {
                    hash ^= hashStr.charCodeAt(j);
                    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
                }
            }
            
            // Convert to unsigned 32-bit and return as hex string
            hash = hash >>> 0;
            return hash.toString(16).padStart(8, '0');
        }

        function exportTokens(opts = {full: false}) {
            if (tokens.length === 0) {
                alert('No tokens to export yet! Start the microphone or add particles.');
                return;
            }
            
            // CST v2.0+ additive: Support compact/full export
            const compact = !opts.full && document.getElementById('export-compact') && document.getElementById('export-compact').checked;
            
            // Calculate token type statistics
            const tokenTypes = {
                audio_frame: tokens.filter(t => t.type === 'audio_frame').length,
                phi_harmonic: tokens.filter(t => t.type === 'phi_harmonic').length,
                frequency_update: tokens.filter(t => t.type === 'frequency_update').length,
                particle_creation: tokens.filter(t => t.eventType === 'creation' || t.eventType === 'audio_creation').length,
                particle_replication: tokens.filter(t => t.eventType === 'replication').length
            };
            
            // CST v2.0+ additive: Enhanced export with full schema including reference scales and diagnostics
            const exportData = {
                metadata: {
                    engineVersion: '2.0+',
                    exportDate: new Date().toISOString(),
                    startTime: tokens.length > 0 ? tokens[0].timestamp : Date.now() / 1000,
                    totalTokens: tokens.length,
                    tokenGenerationRate: tokenGenerationRate.toFixed(2) + ' tokens/sec',
                    engine: '12D Cosmic Synapse Theory',
                    version: '2.0+',
                    mode: determinism.mode || 'live',
                    seed: determinism.seed || projectionConfig.randomSeed || null, // Include seed for deterministic verification
                    projectionMode: projectionConfig.mode, // CST v2.0+ additive: Include projection mode
                    cadence: audioConfig.cadence, // CST v2.0+ additive: Token generation cadence in ms
                    fftSize: audioConfig.fftSize, // CST v2.0+ additive: FFT size used
                    tokenDisplayLimit: audioConfig.tokenDisplayLimit, // CST v2.0+ additive: Token display limit
                    compact: compact, // CST v2.0+ additive: Include compact flag
                    formula: 'œà = œÜE/c¬≤ + Œª + ‚à´v¬∑dt + ‚à´Œîx‚ÇÅ‚ÇÇ¬∑dt + Œ©E + U‚ÇÅ‚ÇÅD',
                    particleCount: particles.length,
                    replicationCount: replicationCount,
                    tokenTypes: tokenTypes,
                    recordingFrames: determinism.recordedAudioFrames.length, // Number of recorded frames if any
                    // CST v2.0+ additive: Reference scales for dimensionless œà normalization
                    referenceScales: {
                        m0: physics.m0,
                        Eref: physics.Eref,
                        tref: physics.tref,
                        vref: physics.vref
                    },
                    physics: {
                        blendLorenz: physics.blendLorenz,
                        gravEnabled: physics.gravEnabled,
                        dmEnabled: physics.dmEnabled,
                        epsilon: physics.epsilon,
                        rCutoff: physics.rCutoff,
                        G: physics.G
                    },
                    adaptive: {
                        k: adapt.k,
                        gamma: adapt.gamma,
                        alpha: adapt.alpha,
                        sigmaSimilarity: adapt.sigmaSimilarity
                    },
                    sync: {
                        Ksync: sync.Ksync
                    },
                    timestep: {
                        dt: timestep.dt,
                        dtMax: timestep.dtMax,
                        adaptive: timestep.adaptive
                    },
                    darkMatter: {
                        rho0: dmParams.rho0,
                        rs: dmParams.rs
                    }
                },
                // CST v2.0+ additive: Include recorded frames if available
                frames: determinism.recordedAudioFrames.length > 0 ? determinism.recordedAudioFrames.map((frame, idx) => ({
                    frameIndex: idx,
                    timestamp: frame.timestamp,
                    rms: frame.rmsEnergy,
                    dominantFreq: frame.frequencyData && frame.frequencyData.length > 0 ? frame.frequencyData[0].frequency : 0,
                    centroid: frame.spectralCentroid,
                    fftBins: frame.dataArray ? Array.from(frame.dataArray) : null,
                    harmonics: frame.harmonics || []
                })) : [],
                // CST v2.0+ additive: Include particle snapshots with full 11D data
                particles: particles.map(p => ({
                    id: p.id,
                    parent: p.parent || null,
                    createdAt: p.createdAt / 1000, // Convert to seconds
                    color: '#' + p.color.toString(16).padStart(6, '0'),
                    mass: parseFloat(p.mass.toFixed(3)),
                    frequency: parseFloat(p.frequency.toFixed(2)),
                    vi: parseFloat(p.vi.toFixed(2)),
                    theta: parseFloat(p.theta.toFixed(4)),
                    omega: parseFloat(p.omega.toFixed(6)),
                    x12: parseFloat(p.x12.toFixed(4)),
                    m12: parseFloat(p.m12.toFixed(4)),
                    Ec: parseFloat(p.Ec.toFixed(6)),
                    Ugrav: parseFloat(p.Ugrav.toFixed(6)),
                    Udm: parseFloat(p.Udm.toFixed(6)),
                    projection11D: {
                        pos11D: Array.from(p.projection11D.pos11D).map(v => parseFloat(v.toFixed(6))),
                        vel11D: Array.from(p.projection11D.vel11D).map(v => parseFloat(v.toFixed(6)))
                    },
                    trailCount: p.points ? p.points.length : 0
                })),
                tokens: tokens,
                // CST v2.0+ additive: Replay integrity hash for deterministic verification
                replayIntegrity: determinism.mode === 'replay' && determinism.recordedAudioFrames.length > 0 ? {
                    seed: determinism.seed,
                    frameCount: determinism.recordedAudioFrames.length,
                    tokenHash: tokens.length > 0 ? tokens.map(t => t.id).join('').substring(0, 32) : null,
                    // Simple hash of first 10 frames for verification
                    frameHash: determinism.recordedAudioFrames.slice(0, 10).map(f => 
                        `${f.rmsEnergy.toFixed(4)}_${f.spectralCentroid.toFixed(2)}`
                    ).join('|').substring(0, 100)
                } : null,
                // CST v2.0+ additive: Recording hash for deterministic verification
                recordingHash: computeRecordingHash(determinism.recordedAudioFrames, determinism.seed || projectionConfig.randomSeed)
            };
            
            const dataStr = JSON.stringify(exportData, null, compact ? 0 : 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `cosmic_tokens_${compact ? 'compact' : 'full'}_${Date.now()}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            updateStatus(`üì¶ Exported ${tokens.length} tokens (${tokenGenerationRate.toFixed(1)} tokens/sec) to ${compact ? 'compact' : 'full'} JSON file`);
        }

        function clearTokens() {
                tokens = [];
                tokenCount = 0;
                replicationCount = 0;
            tokenRateWindow.timestamps = [];
                particles.forEach(p => p.tokens = []);
                updateTokenDisplay();
                updateStatus('All tokens cleared');
        }

        // ============================================================================
        // NEW ENHANCED UI FUNCTIONS
        // ============================================================================

        async function startParameterSweep() {
            const paramName = document.getElementById('sweepParam').value;
            const minVal = parseFloat(document.getElementById('sweepMin').value);
            const maxVal = parseFloat(document.getElementById('sweepMax').value);
            const steps = parseInt(document.getElementById('sweepSteps').value);
            const metric = document.getElementById('sweepMetric').value;

            const resultsDiv = document.getElementById('sweepResults');
            resultsDiv.innerHTML = '<p>Running parameter sweep...</p>';

            try {
                const results = await paramSweep.sweepParameter(paramName, minVal, maxVal, steps, metric);

                let html = '<h4>Sweep Results:</h4>';
                html += '<div style="font-family: monospace; font-size: 0.85em;">';
                results.forEach(r => {
                    html += `${paramName} = ${r.value.toFixed(3)} ‚Üí ${metric} = ${r.metric.toExponential(2)}<br>`;
                });
                html += '</div>';

                resultsDiv.innerHTML = html;
            } catch (error) {
                resultsDiv.innerHTML = `<p style="color: #ff0000;">Error: ${error.message}</p>`;
                console.error('Parameter sweep error:', error);
            }
        }

        // Update synth volume display
        const synthVolumeEl = document.getElementById('synthVolume');
        if (synthVolumeEl) {
            synthVolumeEl.addEventListener('input', (e) => {
                const vol = parseFloat(e.target.value);
                const displayEl = document.getElementById('synthVolumeDisplay');
                if (displayEl) displayEl.textContent = Math.round(vol * 100) + '%';
            });
        }

        // ============================================================================
        // END NEW ENHANCED UI FUNCTIONS
        // ============================================================================

        // Event listeners - CST v2.0+ fix: Add null checks to prevent errors if elements don't exist
        const sigmaEl = document.getElementById('sigma');
        if (sigmaEl) {
            sigmaEl.addEventListener('input', (e) => {
                sigma = parseFloat(e.target.value);
                const displayEl = document.getElementById('sigma-display');
                if (displayEl) displayEl.textContent = sigma.toFixed(1);
            });
        }

        const rhoEl = document.getElementById('rho');
        if (rhoEl) {
            rhoEl.addEventListener('input', (e) => {
                rho = parseFloat(e.target.value);
                const displayEl = document.getElementById('rho-display');
                if (displayEl) displayEl.textContent = rho.toFixed(1);
            });
        }

        const betaEl = document.getElementById('beta');
        if (betaEl) {
            betaEl.addEventListener('input', (e) => {
                beta = parseFloat(e.target.value);
                const displayEl = document.getElementById('beta-display');
                if (displayEl) displayEl.textContent = beta.toFixed(3);
            });
        }

        const sensitivityEl = document.getElementById('sensitivity');
        if (sensitivityEl) {
            sensitivityEl.addEventListener('input', (e) => {
                audioSensitivity = parseFloat(e.target.value);
                const displayEl = document.getElementById('sensitivity-display');
                if (displayEl) displayEl.textContent = audioSensitivity.toFixed(1);
            });
        }

        const replicationEl = document.getElementById('replication');
        if (replicationEl) {
            replicationEl.addEventListener('input', (e) => {
                replicationThreshold = parseFloat(e.target.value);
                const displayEl = document.getElementById('replication-display');
                if (displayEl) displayEl.textContent = replicationThreshold.toFixed(0);
            });
        }

        // 12D CST Event Listeners
        const blendLorenzEl = document.getElementById('blend-lorenz');
        if (blendLorenzEl) {
            blendLorenzEl.addEventListener('input', (e) => {
                physics.blendLorenz = parseFloat(e.target.value);
                const displayEl = document.getElementById('blend-lorenz-display');
                if (displayEl) displayEl.textContent = physics.blendLorenz.toFixed(2);
            });
        }

        const gravEnabledEl = document.getElementById('grav-enabled');
        if (gravEnabledEl) {
            gravEnabledEl.addEventListener('change', (e) => {
                physics.gravEnabled = e.target.checked;
            });
        }

        const dmEnabledEl = document.getElementById('dm-enabled');
        if (dmEnabledEl) {
            dmEnabledEl.addEventListener('change', (e) => {
                physics.dmEnabled = e.target.checked;
            });
        }

        const rcutoffEl = document.getElementById('rcutoff');
        if (rcutoffEl) {
            rcutoffEl.addEventListener('input', (e) => {
                physics.rCutoff = parseFloat(e.target.value);
                const displayEl = document.getElementById('rcutoff-display');
                if (displayEl) displayEl.textContent = physics.rCutoff.toFixed(1);
            });
        }

        const epsilonEl = document.getElementById('epsilon');
        if (epsilonEl) {
            epsilonEl.addEventListener('input', (e) => {
                physics.epsilon = parseFloat(e.target.value);
                const displayEl = document.getElementById('epsilon-display');
                if (displayEl) displayEl.textContent = physics.epsilon.toFixed(2);
            });
        }

        // Enhanced 12D parameter controls: Update both global and per-particle parameters
        const kEl = document.getElementById('k');
        if (kEl) {
            kEl.addEventListener('input', (e) => {
                adapt.k = parseFloat(e.target.value);
                const displayEl = document.getElementById('k-display');
                if (displayEl) displayEl.textContent = adapt.k.toFixed(1);
                // Update all particles' adaptation rate
                particles.forEach(p => { p.k_adaptation = adapt.k * 0.01; });
            });
        }

        const gammaEl = document.getElementById('gamma');
        if (gammaEl) {
            gammaEl.addEventListener('input', (e) => {
                adapt.gamma = parseFloat(e.target.value);
                const displayEl = document.getElementById('gamma-display');
                if (displayEl) displayEl.textContent = adapt.gamma.toFixed(2);
                // Update all particles' decay rate
                particles.forEach(p => { p.gamma_decay = adapt.gamma * 0.01; });
            });
        }

        const alphaEl = document.getElementById('alpha');
        if (alphaEl) {
            alphaEl.addEventListener('input', (e) => {
                adapt.alpha = parseFloat(e.target.value);
                const displayEl = document.getElementById('alpha-display');
                if (displayEl) displayEl.textContent = adapt.alpha.toFixed(2);
                // Update all particles' memory adaptation rate
                particles.forEach(p => { p.alpha_memory = adapt.alpha; });
            });
        }

        const sigmaSimEl = document.getElementById('sigma-sim');
        if (sigmaSimEl) {
            sigmaSimEl.addEventListener('input', (e) => {
                adapt.sigmaSimilarity = parseFloat(e.target.value);
                const displayEl = document.getElementById('sigma-sim-display');
                if (displayEl) displayEl.textContent = adapt.sigmaSimilarity.toFixed(2);
                // Update all particles' similarity spread
                particles.forEach(p => { p.sigma_similarity = adapt.sigmaSimilarity; });
            });
        }

        const ksyncEl = document.getElementById('ksync');
        if (ksyncEl) {
            ksyncEl.addEventListener('input', (e) => {
                sync.Ksync = parseFloat(e.target.value);
                const displayEl = document.getElementById('ksync-display');
                if (displayEl) displayEl.textContent = sync.Ksync.toFixed(2);
            });
        }

        const dtmaxEl = document.getElementById('dtmax');
        if (dtmaxEl) {
            dtmaxEl.addEventListener('input', (e) => {
                timestep.dtMax = parseFloat(e.target.value);
                const displayEl = document.getElementById('dtmax-display');
                if (displayEl) displayEl.textContent = timestep.dtMax.toFixed(3);
            });
        }

        const adaptiveDtEl = document.getElementById('adaptive-dt');
        if (adaptiveDtEl) {
            adaptiveDtEl.addEventListener('change', (e) => {
                timestep.adaptive = e.target.checked;
            });
        }

        const dmRho0El = document.getElementById('dm-rho0');
        if (dmRho0El) {
            dmRho0El.addEventListener('input', (e) => {
                dmParams.rho0 = parseFloat(e.target.value);
                const displayEl = document.getElementById('dm-rho0-display');
                if (displayEl) displayEl.textContent = dmParams.rho0.toFixed(1);
                // NEW: Update NFW profile plot when slider changes
                drawNfwProfile(dmParams.rho0, dmParams.rs);
            });
        }

        const dmRsEl = document.getElementById('dm-rs');
        if (dmRsEl) {
            dmRsEl.addEventListener('input', (e) => {
                dmParams.rs = parseFloat(e.target.value);
                const displayEl = document.getElementById('dm-rs-display');
                if (displayEl) displayEl.textContent = dmParams.rs.toFixed(1);
                // NEW: Update NFW profile plot when slider changes
                drawNfwProfile(dmParams.rho0, dmParams.rs);
            });
        }

        // CST v2.0+ additive: Projection mode selector event listener
        const projectionModeEl = document.getElementById('projection-mode');
        if (projectionModeEl) {
            projectionModeEl.addEventListener('change', (e) => {
                projectionConfig.mode = e.target.value;
                const statusEl = document.getElementById('projection-status');
                if (statusEl) statusEl.textContent = projectionConfig.mode;
                
                // Reset random projection matrix when switching modes (will regenerate on next use)
                if (projectionConfig.mode !== 'random_embedding') {
                    projectionConfig.randomR = null;
                } else {
                    // Force regeneration of random matrix with current seed
                    projectionConfig.randomR = null;
                }
                
                // Update all particles' projections immediately
                particles.forEach(p => p.update11DProjection());
                
                updateStatus(`Projection mode changed to: ${projectionConfig.mode}`);
            });
        }
        
        // CST v2.0+ additive: Cadence control (if element exists)
        const cadenceEl = document.getElementById('token-cadence');
        if (cadenceEl) {
            cadenceEl.addEventListener('input', (e) => {
                audioConfig.cadence = Math.max(1, Math.min(100, parseInt(e.target.value) || 100));
                const displayEl = document.getElementById('token-cadence-display');
                if (displayEl) displayEl.textContent = audioConfig.cadence;
                restartAudioProcessingLoop();
                restartReplayLoop();
                updateStatus(`Token cadence set to ${audioConfig.cadence}ms`);
            });
        }
        
        // CST v2.0+ additive: FFT size control (if element exists)
        const fftSizeEl = document.getElementById('fft-size');
        if (fftSizeEl) {
            fftSizeEl.addEventListener('change', (e) => {
                const validSizes = [256, 512, 1024, 2048, 4096, 8192];
                const newSize = parseInt(e.target.value);
                if (validSizes.includes(newSize)) {
                    audioConfig.fftSize = newSize;
                    // Restart audio if active
                    if (isAudioActive) {
                        const wasActive = isAudioActive;
                        stopAudio();
                        if (wasActive) {
                            setTimeout(() => toggleMicrophone(), 100);
                        }
                    }
                    updateStatus(`FFT size set to ${audioConfig.fftSize}`);
                }
            });
        }
        
        // CST v2.0+ additive: Token display limit control (if element exists)
        const tokenLimitEl = document.getElementById('token-display-limit');
        if (tokenLimitEl) {
            tokenLimitEl.addEventListener('input', (e) => {
                audioConfig.tokenDisplayLimit = Math.max(50, Math.min(1000, parseInt(e.target.value) || 200));
                const displayEl = document.getElementById('token-display-limit-display');
                if (displayEl) displayEl.textContent = audioConfig.tokenDisplayLimit;
                updateTokenDisplay();
                updateStatus(`Token display limit set to ${audioConfig.tokenDisplayLimit}`);
            });
        }

        // ============================================================================
        // PERPETUAL OPERATION SYSTEM EVENT LISTENERS
        // ============================================================================

        // Perpetual operation controls
        const perpetualAutoRegenEl = document.getElementById('perpetual-auto-regen');
        if (perpetualAutoRegenEl) {
            perpetualAutoRegenEl.addEventListener('change', (e) => {
                PERPETUAL_CONFIG.autoRegenerate = e.target.checked;
                console.log('[PERPETUAL] Auto-regenerate:', PERPETUAL_CONFIG.autoRegenerate);
            });
        }

        const perpetualEnergyInjectEl = document.getElementById('perpetual-energy-inject');
        if (perpetualEnergyInjectEl) {
            perpetualEnergyInjectEl.addEventListener('change', (e) => {
                PERPETUAL_CONFIG.preventHeatDeath = e.target.checked;
                console.log('[PERPETUAL] Energy injection:', PERPETUAL_CONFIG.preventHeatDeath);
            });
        }

        const perpetualSelfHealEl = document.getElementById('perpetual-self-heal');
        if (perpetualSelfHealEl) {
            perpetualSelfHealEl.addEventListener('change', (e) => {
                PERPETUAL_CONFIG.selfHealingEnabled = e.target.checked;
                console.log('[PERPETUAL] Self-healing:', PERPETUAL_CONFIG.selfHealingEnabled);
            });
        }

        const perpetualFallbackAudioEl = document.getElementById('perpetual-fallback-audio');
        if (perpetualFallbackAudioEl) {
            perpetualFallbackAudioEl.addEventListener('change', (e) => {
                PERPETUAL_CONFIG.fallbackAudioEnabled = e.target.checked;
                console.log('[PERPETUAL] Fallback audio:', PERPETUAL_CONFIG.fallbackAudioEnabled);
            });
        }

        const perpetualMinEl = document.getElementById('perpetual-min');
        if (perpetualMinEl) {
            perpetualMinEl.addEventListener('input', (e) => {
                PERPETUAL_CONFIG.minParticles = parseInt(e.target.value);
                const displayEl = document.getElementById('perpetual-min-display');
                if (displayEl) displayEl.textContent = PERPETUAL_CONFIG.minParticles;
            });
        }

        const perpetualMaxEl = document.getElementById('perpetual-max');
        if (perpetualMaxEl) {
            perpetualMaxEl.addEventListener('input', (e) => {
                PERPETUAL_CONFIG.maxParticles = parseInt(e.target.value);
                const displayEl = document.getElementById('perpetual-max-display');
                if (displayEl) displayEl.textContent = PERPETUAL_CONFIG.maxParticles;
            });
        }

        const perpetualInjectRateEl = document.getElementById('perpetual-inject-rate');
        if (perpetualInjectRateEl) {
            perpetualInjectRateEl.addEventListener('input', (e) => {
                PERPETUAL_CONFIG.energyInjectionRate = parseFloat(e.target.value);
                const displayEl = document.getElementById('perpetual-inject-rate-display');
                if (displayEl) displayEl.textContent = PERPETUAL_CONFIG.energyInjectionRate.toFixed(4);
            });
        }

        console.log('[PERPETUAL] ‚úÖ Event listeners initialized');

        // Recording and replay functions
        function toggleRecording() {
            determinism.isRecording = !determinism.isRecording;
            const btn = document.getElementById('record-btn');
            if (determinism.isRecording) {
                btn.textContent = '‚èπÔ∏è Stop Recording';
                determinism.recordedAudioFrames = [];
            } else {
                btn.textContent = 'üî¥ Start Recording';
            }
            reflectDeterminismUI();
        }

        // Additive: enhanced toggleReplay using new replay functions
        function toggleReplay() {
            if (determinism.mode === 'replay') {
                stopReplay();
            } else {
                if (determinism.recordedAudioFrames.length > 0) {
                    if (!determinism.seed) setDeterministicSeed(12345);
                    startReplay();
                } else {
                    alert('No recorded frames available. Start recording first.');
                }
            }
        }

        // CST v2.0: Initialize all UI display values on page load
        function initializeUIDisplays() {
            // Set initial display values for all sliders/controls
            const sigmaEl = document.getElementById('sigma-display');
            const rhoEl = document.getElementById('rho-display');
            const betaEl = document.getElementById('beta-display');
            const sensitivityEl = document.getElementById('sensitivity-display');
            const replicationEl = document.getElementById('replication-display');
            const blendLorenzEl = document.getElementById('blend-lorenz-display');
            const rcutoffEl = document.getElementById('rcutoff-display');
            const epsilonEl = document.getElementById('epsilon-display');
            const kEl = document.getElementById('k-display');
            const gammaEl = document.getElementById('gamma-display');
            const alphaEl = document.getElementById('alpha-display');
            const sigmaSimEl = document.getElementById('sigma-sim-display');
            const ksyncEl = document.getElementById('ksync-display');
            const dtmaxEl = document.getElementById('dtmax-display');
            const dmRho0El = document.getElementById('dm-rho0-display');
            const dmRsEl = document.getElementById('dm-rs-display');
            
            if (sigmaEl) sigmaEl.textContent = sigma.toFixed(1);
            if (rhoEl) rhoEl.textContent = rho.toFixed(1);
            if (betaEl) betaEl.textContent = beta.toFixed(3);
            if (sensitivityEl) sensitivityEl.textContent = audioSensitivity.toFixed(1);
            if (replicationEl) replicationEl.textContent = replicationThreshold.toFixed(0);
            if (blendLorenzEl) blendLorenzEl.textContent = physics.blendLorenz.toFixed(2);
            if (rcutoffEl) rcutoffEl.textContent = physics.rCutoff.toFixed(1);
            if (epsilonEl) epsilonEl.textContent = physics.epsilon.toFixed(2);
            if (kEl) kEl.textContent = adapt.k.toFixed(1);
            if (gammaEl) gammaEl.textContent = adapt.gamma.toFixed(2);
            if (alphaEl) alphaEl.textContent = adapt.alpha.toFixed(2);
            if (sigmaSimEl) sigmaSimEl.textContent = adapt.sigmaSimilarity.toFixed(2);
            if (ksyncEl) ksyncEl.textContent = sync.Ksync.toFixed(2);
            if (dtmaxEl) dtmaxEl.textContent = timestep.dtMax.toFixed(3);
            if (dmRho0El) dmRho0El.textContent = dmParams.rho0.toFixed(1);
            if (dmRsEl) dmRsEl.textContent = dmParams.rs.toFixed(1);
            
            // Set checkbox states
            const gravEnabledEl = document.getElementById('grav-enabled');
            const dmEnabledEl = document.getElementById('dm-enabled');
            const adaptiveDtEl = document.getElementById('adaptive-dt');
            if (gravEnabledEl) gravEnabledEl.checked = physics.gravEnabled;
            if (dmEnabledEl) dmEnabledEl.checked = physics.dmEnabled;
            if (adaptiveDtEl) adaptiveDtEl.checked = timestep.adaptive;
        }

        // === 12D CST: Drop-in completion block (additive, non-destructive) ===
        (function () {
            // Guarded define: helpers
            if (typeof safeNormalize !== 'function') {
                window.safeNormalize = function safeNormalize(value, ref) {
                    const r = (typeof ref === 'number' && ref !== 0) ? ref : 1;
                    const v = (typeof value === 'number' && isFinite(value)) ? value : 0;
                    return v / r;
                };
            }

            if (typeof computeLambdaTerm !== 'function') {
                window.computeLambdaTerm = function computeLambdaTerm(audioChaos, chaosDerivativeSum) {
                    const scale = 100;
                    const base = Math.log(Math.abs(chaosDerivativeSum) + 1) / scale;
                    return base + (isFinite(audioChaos) ? audioChaos : 0);
                };
            }

            if (typeof computeOmegaTerm !== 'function') {
                window.computeOmegaTerm = function computeOmegaTerm(particles, Eref) {
                    let sum = 0;
                    for (const p of particles) {
                        const normE = safeNormalize(p.Ec, Eref);
                        const omega = (typeof p.omega === 'number' && isFinite(p.omega)) ? p.omega : 0;
                        sum += omega * normE;
                    }
                    return sum;
                };
            }

            if (typeof computePotentialTerm !== 'function') {
                window.computePotentialTerm = function computePotentialTerm(particles, Eref) {
                    let sum = 0;
                    for (const p of particles) {
                        const U = ((p.Ugrav || 0) + (p.Udm || 0));
                        sum += safeNormalize(U, Eref);
                    }
                    return sum;
                };
            }

            if (typeof computeEnergyTerm !== 'function') {
                window.computeEnergyTerm = function computeEnergyTerm(particles, Eref) {
                    let sum = 0;
                    for (const p of particles) {
                        sum += phi * safeNormalize(p.Ec, Eref);
                    }
                    return sum;
                };
            }

            // Guarded define: œà normalized breakdown
            if (typeof updatePsiNormalized !== 'function') {
                window.updatePsiNormalized = function updatePsiNormalized(particles, refs, accum) {
                    const terms = {
                        energyTerm: 0,
                        lambdaTerm: 0,
                        velocityIntegralTerm: 0,
                        x12IntegralTerm: 0,
                        omegaTerm: 0,
                        potentialTerm: 0
                    };
                    if (!particles || particles.length === 0) {
                        return { terms, psiTotal: 0 };
                    }
                    let chaosDerivativeSum = 0;
                    particles.forEach((p) => {
                        const pid = p.id;
                        const vMag = Math.sqrt(p.velocity.x ** 2 + p.velocity.y ** 2 + p.velocity.z ** 2);
                        chaosDerivativeSum += Math.abs(vMag);
                        const vIntPrev = accum.velocityIntegral.get(pid) || 0;
                        const vIntNew = vIntPrev + safeNormalize(vMag, refs.vref) * timestep.dt;
                        accum.velocityIntegral.set(pid, vIntNew);
                        const x12Prev = accum.x12Previous.get(pid);
                        if (x12Prev !== undefined) {
                            const deltaX12 = Math.abs(p.x12 - x12Prev);
                            const x12IntPrev = accum.x12Integral.get(pid) || 0;
                            const x12IntNew = x12IntPrev + deltaX12 * timestep.dt;
                            accum.x12Integral.set(pid, x12IntNew);
                        } else {
                            accum.x12Integral.set(pid, 0);
                        }
                        accum.x12Previous.set(pid, p.x12);
                    });
                    terms.energyTerm = computeEnergyTerm(particles, refs.Eref);
                    terms.lambdaTerm = computeLambdaTerm(isAudioActive ? calculateAudioChaos() : 0, chaosDerivativeSum);
                    terms.velocityIntegralTerm = Array.from(accum.velocityIntegral.values()).reduce((a, b) => a + b, 0);
                    terms.x12IntegralTerm = Array.from(accum.x12Integral.values()).reduce((a, b) => a + b, 0);
                    terms.omegaTerm = computeOmegaTerm(particles, refs.Eref);
                    terms.potentialTerm = computePotentialTerm(particles, refs.Eref);
                    const psiTotal = terms.energyTerm + terms.lambdaTerm + terms.velocityIntegralTerm +
                                   terms.x12IntegralTerm + terms.omegaTerm + terms.potentialTerm;
                    return { terms, psiTotal };
                };
            }

            // Guarded define: entropy trace smoothing and draw
            if (typeof getSmoothedEntropy !== 'function') {
                window.entropyTrace = Array.isArray(window.entropyTrace) ? window.entropyTrace : [];
                window.entropyTraceConfig = window.entropyTraceConfig || { emaAlpha: 0.3 };
                window.entropyEma = window.entropyEma ?? null;
                window.getSmoothedEntropy = function getSmoothedEntropy(current) {
                    if (entropyEma === null || !isFinite(entropyEma)) {
                        entropyEma = current;
                        return current;
                    }
                    entropyEma = entropyTraceConfig.emaAlpha * current + (1 - entropyTraceConfig.emaAlpha) * entropyEma;
                    return entropyEma;
                };
            }

            if (typeof drawEntropyTrace !== 'function') {
                window.drawEntropyTrace = function drawEntropyTrace(entropyValue) {
                    if (!entropyState || !entropyState.traceCtx) return;
                    const ctx = entropyState.traceCtx;
                    const canvas = ctx.canvas;
                    const width = canvas.width || 400;
                    const height = canvas.height || 60;
                    const smoothed = getSmoothedEntropy(entropyValue);
                    if (typeof smoothed === 'number' && isFinite(smoothed)) {
                        entropyTrace.push(smoothed);
                    }
                    while (entropyTrace.length > width) entropyTrace.shift();
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
                    ctx.fillRect(0, 0, width, height);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, height / 2);
                    ctx.lineTo(width, height / 2);
                    ctx.stroke();
                    if (entropyTrace.length > 1) {
                        const valid = entropyTrace.filter(v => typeof v === 'number' && isFinite(v));
                        const min = valid.length ? Math.min(...valid) : 0;
                        const max = valid.length ? Math.max(...valid) : 1;
                        const range = Math.max(max - min, 1e-6);
                        const traceHeight = height * 0.8;
                        const baseline = height / 2;
                        ctx.beginPath();
                        ctx.strokeStyle = '#00ffcc';
                        ctx.lineWidth = 2;
                        let first = true;
                        for (let i = 0; i < entropyTrace.length; i++) {
                            const val = entropyTrace[i];
                            if (typeof val !== 'number' || !isFinite(val)) continue;
                            const norm = (val - min) / range;
                            const y = baseline + (traceHeight / 2) - (norm * traceHeight);
                            const clampedY = Math.max(0, Math.min(height, y));
                            if (first) { ctx.moveTo(i, clampedY); first = false; } else { ctx.lineTo(i, clampedY); }
                        }
                        ctx.stroke();
                    }
                };
            }

            // Guarded define: adaptive state canvas and trace
            if (typeof initAdaptiveStateCanvas !== 'function') {
                window.adaptiveStateCtx = null;
                window.x12History = [];
                window.initAdaptiveStateCanvas = function initAdaptiveStateCanvas() {
                    const canvas = document.getElementById('adaptiveStateCanvas');
                    if (!canvas) return;
                    adaptiveStateCtx = canvas.getContext('2d');
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 120;
                    window.addEventListener('resize', () => {
                        if (!adaptiveStateCtx) return;
                        const c = adaptiveStateCtx.canvas;
                        c.width = c.offsetWidth || 400;
                        c.height = 120;
                    });
                };
            }

            if (typeof updateAdaptiveStateTrace !== 'function') {
                window.updateAdaptiveStateTrace = function updateAdaptiveStateTrace() {
                    if (!adaptiveStateCtx || !Array.isArray(particles)) return;
                    const ctx = adaptiveStateCtx;
                    const c = ctx.canvas;
                    const width = c.width || 400;
                    const height = c.height || 120;
                    while (x12History.length < particles.length) x12History.push([]);
                    if (x12History.length > particles.length) x12History.length = particles.length;
                    particles.forEach((p, i) => {
                        const val = (typeof p.x12 === 'number' && isFinite(p.x12)) ? p.x12 : 0;
                        x12History[i].push(val);
                        while (x12History[i].length > width) x12History[i].shift();
                    });
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
                    ctx.fillRect(0, 0, width, height);
                    const baseline = height / 2;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.beginPath();
                    ctx.moveTo(0, baseline);
                    ctx.lineTo(width, baseline);
                    ctx.stroke();
                    particles.forEach((p, i) => {
                        const colorHex = '#' + p.color.toString(16).padStart(6, '0');
                        ctx.strokeStyle = colorHex;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        let first = true;
                        const hist = x12History[i];
                        for (let x = 0; x < hist.length; x++) {
                            const y = baseline - (hist[x] * (height * 0.45));
                            const clampedY = Math.max(0, Math.min(height, y));
                            if (first) { ctx.moveTo(x, clampedY); first = false; } else { ctx.lineTo(x, clampedY); }
                        }
                        ctx.stroke();
                    });
                };
            }

            // Guarded define: theta std
            if (typeof computeThetaStd !== 'function') {
                window.computeThetaStd = function computeThetaStd(particles) {
                    if (!particles || particles.length === 0) return 0;
                    const thetas = particles.map(p => p.theta || 0);
                    const mean = thetas.reduce((a, b) => a + b, 0) / thetas.length;
                    const variance = thetas.reduce((a, b) => a + (b - mean) ** 2, 0) / thetas.length;
                    return Math.sqrt(variance);
                };
            }

            // Guarded define: dark matter profile canvas and draw
            if (typeof initDmProfileCanvas !== 'function') {
                window.dmProfileCtx = null;
                window.initDmProfileCanvas = function initDmProfileCanvas() {
                    const canvas = document.getElementById('dmProfileCanvas');
                    if (!canvas) return;
                    dmProfileCtx = canvas.getContext('2d');
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 120;
                    window.addEventListener('resize', () => {
                        if (!dmProfileCtx) return;
                        const c = dmProfileCtx.canvas;
                        c.width = c.offsetWidth || 400;
                        c.height = 120;
                    });
                };
            }

            if (typeof drawNfwProfile !== 'function') {
                window.drawNfwProfile = function drawNfwProfile(rho0, rs) {
                    if (!dmProfileCtx) return;
                    const ctx = dmProfileCtx;
                    const c = ctx.canvas;
                    const width = c.width || 400;
                    const height = c.height || 120;
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = 'rgba(10,10,26,0.25)';
                    ctx.fillRect(0, 0, width, height);
                    const samples = 200;
                    const rMin = Math.max(0.1 * rs, 1e-6);
                    const rMax = 10 * rs;
                    const values = [];
                    for (let i = 0; i < samples; i++) {
                        const t = i / (samples - 1);
                        const r = rMin * Math.pow(rMax / rMin, t);
                        const r_rs = r / rs;
                        const rho = r_rs > 0 ? rho0 / (r_rs * Math.pow(1 + r_rs, 2)) : 0;
                        values.push({ r, rho });
                    }
                    const rhoMax = Math.max(...values.map(v => v.rho), 1e-12);
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    values.forEach((v, i) => {
                        const x = (i / (samples - 1)) * width;
                        const y = height - (Math.log(v.rho + 1) / Math.log(rhoMax + 1)) * height;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                };
            }

            // Guarded define: replay validation updater
            if (typeof updateReplayValidation !== 'function') {
                window.updateReplayValidation = function updateReplayValidation(consStats, virial) {
                    if (!determinism || determinism.mode !== 'replay') return;
                    const edriftEl = document.getElementById('replay-edrift');
                    const pmagEl = document.getElementById('replay-pmag');
                    const lmagEl = document.getElementById('replay-lmag');
                    const virialEl = document.getElementById('replay-virial');
                    if (!edriftEl || !pmagEl || !lmagEl || !virialEl) return;
                    edriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
                    const Pmag = Math.sqrt(consStats.P.x ** 2 + consStats.P.y ** 2 + consStats.P.z ** 2);
                    const Lmag = Math.sqrt(consStats.L.x ** 2 + consStats.L.y ** 2 + consStats.L.z ** 2);
                    pmagEl.textContent = Pmag.toExponential(2);
                    lmagEl.textContent = Lmag.toExponential(2);
                    virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
                };
            }

            // Guarded define: psi snapshot for token enrichment
            if (typeof currentPsiSnapshot !== 'function') {
                window.currentPsiSnapshot = function currentPsiSnapshot() {
                    const psiResult = updatePsiNormalized(particles || [], physics, psiAccumulators);
                    return {
                        energyTerm: parseFloat(psiResult.terms.energyTerm.toFixed(6)),
                        lambdaTerm: parseFloat(psiResult.terms.lambdaTerm.toFixed(6)),
                        velocityIntegralTerm: parseFloat(psiResult.terms.velocityIntegralTerm.toFixed(6)),
                        x12IntegralTerm: parseFloat(psiResult.terms.x12IntegralTerm.toFixed(6)),
                        omegaTerm: parseFloat(psiResult.terms.omegaTerm.toFixed(6)),
                        potentialTerm: parseFloat(psiResult.terms.potentialTerm.toFixed(6)),
                        psiTotal: parseFloat(psiResult.psiTotal.toFixed(6))
                    };
                };
            }

            // Guarded patch: inject psiBreakdown into tokens if missing at runtime
            const originalGenerateParticleToken = window.generateParticleToken;
            if (typeof originalGenerateParticleToken === 'function' && !originalGenerateParticleToken.__patched) {
                window.generateParticleToken = function patchedGenerateParticleToken(particle, eventType) {
                    const token = originalGenerateParticleToken.call(this, particle, eventType);
                    if (token && token.psiBreakdown == null && typeof currentPsiSnapshot === 'function') {
                        token.psiBreakdown = currentPsiSnapshot();
                    }
                    return token;
                };
                window.generateParticleToken.__patched = true;
            }

            const originalGenerateAudioFrameToken = window.generateAudioFrameToken;
            if (typeof originalGenerateAudioFrameToken === 'function' && !originalGenerateAudioFrameToken.__patched) {
                window.generateAudioFrameToken = function patchedGenerateAudioFrameToken(frequencyData, rmsEnergy, spectralCentroid, harmonics) {
                    const token = originalGenerateAudioFrameToken.call(this, frequencyData, rmsEnergy, spectralCentroid, harmonics);
                    if (token && token.psiBreakdown == null && typeof currentPsiSnapshot === 'function') {
                        token.psiBreakdown = currentPsiSnapshot();
                    }
                    return token;
                };
                window.generateAudioFrameToken.__patched = true;
            }

            const originalGenerateHarmonicToken = window.generateHarmonicToken;
            if (typeof originalGenerateHarmonicToken === 'function' && !originalGenerateHarmonicToken.__patched) {
                window.generateHarmonicToken = function patchedGenerateHarmonicToken(harmonic, magnitude, index) {
                    const token = originalGenerateHarmonicToken.call(this, harmonic, magnitude, index);
                    if (token && token.psiBreakdown == null && typeof currentPsiSnapshot === 'function') {
                        token.psiBreakdown = currentPsiSnapshot();
                    }
                    return token;
                };
                window.generateHarmonicToken.__patched = true;
            }

            // Wire-ups (safe to call even if already wired elsewhere)
            const originalUpdateAdvancedUI = window.updateAdvancedUI;
            if (typeof originalUpdateAdvancedUI === 'function' && !originalUpdateAdvancedUI.__patched) {
                window.updateAdvancedUI = function patchedUpdateAdvancedUI(consStats, virial, psiResult, syncMetric) {
                    originalUpdateAdvancedUI.call(this, consStats, virial, psiResult, syncMetric);
                    // Ensure replay panel updates during replay
                    updateReplayValidation(consStats, virial);
                    // Ensure œà breakdown panel updates
                    if (typeof updatePsiBreakdown === 'function') updatePsiBreakdown();
                };
                window.updateAdvancedUI.__patched = true;
            }

            // Final sanity: ensure init is called after DOM is ready
            document.addEventListener('DOMContentLoaded', () => {
                if (typeof initAdaptiveStateCanvas === 'function') initAdaptiveStateCanvas();
                if (typeof initDmProfileCanvas === 'function') initDmProfileCanvas();
                if (typeof drawNfwProfile === 'function' && typeof dmParams !== 'undefined') {
                    drawNfwProfile(dmParams.rho0, dmParams.rs);
                }
            });
        })();

        // === 12D CST: Additive completion stubs (guarded) ===

        // Additive: Deterministic replay API (guarded)
        if (typeof startReplay === 'undefined') {
          function startReplay() {
            const frames = determinism.recordedAudioFrames;
            if (!frames || frames.length === 0) {
              alert('No recorded frames available. Start recording first.');
              return;
            }
            determinism.mode = 'replay';
            let localIndex = 0;

            applyDeterministicInit(determinism.seed || 12345);
            isAudioActive = false;

            const baseTs = frames[0].timestamp || 0;
            const tick = () => {
              if (localIndex >= frames.length) {
                stopReplay();
                return;
              }
              const prev = localIndex > 0 ? frames[localIndex - 1] : null;
              stepReplayFrame(frames[localIndex], prev, baseTs);
              localIndex++;
              const nextDelay = localIndex < frames.length
                ? Math.max(50, Math.min(250, ((frames[localIndex].timestamp || 0) - (frames[localIndex - 1].timestamp || 0)) * 1000 || audioConfig.cadence))
                : audioConfig.cadence;
              replayTimer = setTimeout(tick, nextDelay);
            };

            tick();
            updateStatus(`Replay mode enabled - ${frames.length} frames`);
            reflectDeterminismUI();
          }
          // Additive: mark guard
          startReplay.__additive = true;
        }

        if (typeof stopReplay === 'undefined') {
          function stopReplay() {
            determinism.mode = 'live';
            if (typeof replayTimer !== 'undefined' && replayTimer) {
              clearTimeout(replayTimer);
              replayTimer = null;
            }
            updateStatus('Replay mode disabled - back to live mode');
            reflectDeterminismUI();
          }
          stopReplay.__additive = true;
        }

        if (typeof stepReplayFrame === 'undefined') {
          function stepReplayFrame(frame, prevFrame, baseTs) {
            audioEnergy = frame.rmsEnergy || frame.rms || 0;
            spectralCentroid = frame.spectralCentroid || 0;
            frequencyData = (frame.frequencyData || []).map(({ frequency, magnitude }) => ({ frequency, magnitude }));

            // Deterministic token generation path
            generateTokens(frequencyData, audioEnergy, spectralCentroid);

            // Update frequency visualization explicitly
            const freqs = frequencyData.map(d => d.frequency);
            const mags  = frequencyData.map(d => d.magnitude);
            updateFrequencyViz(freqs, mags);

            // Chaos display
            const chaos = calculateAudioChaos();
            const chaosEl = document.getElementById('audio-chaos');
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);
          }
          stepReplayFrame.__additive = true;
        }

        if (typeof applyDeterministicInit === 'undefined') {
          function applyDeterministicInit(seed) {
            setDeterministicSeed(seed);
            deterministicIdCounter = 0;
            // Re-seed deterministic RNG
            deterministicRandom = seed;

            // Deterministic placement/colors for reproducible visuals
            for (let i = 0; i < particles.length; i++) {
              const p = particles[i];
              const jitter = (getRandom() * 2 - 1) * 0.05;
              p.x = 0.1 + i * 0.1 + jitter;
              p.y = i * 0.1 + jitter;
              p.z = i * 0.1 - jitter;

              const baseHue = 180 + Math.floor(getRandom() * 360);
              const color = new THREE.Color();
              color.setHSL(baseHue / 360, 1.0, 0.5); // Fix: Use setHSL instead of HSL string
              p.line.material.color.setHex(color.getHex());
              p.sphere.material.color.setHex(color.getHex());
            }

            // Reset integrals and conservation for clean replay
            if (typeof resetIntegralsAndConservation === 'function') {
              resetIntegralsAndConservation();
            }
          }
          applyDeterministicInit.__additive = true;
        }

        // Additive: Adaptive state trace (guarded)
        if (typeof initAdaptiveStateCanvas === 'undefined') {
          function initAdaptiveStateCanvas() {
            const canvas = document.getElementById('adaptiveStateCanvas');
            if (!canvas) return;
            adaptiveStateCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth || 400;
            canvas.height = 120;

            window.addEventListener('resize', () => {
              if (!adaptiveStateCtx) return;
              const c = adaptiveStateCtx.canvas;
              c.width = c.offsetWidth || 400;
              c.height = 120;
            });
          }
          initAdaptiveStateCanvas.__additive = true;
        }

        if (typeof updateAdaptiveStateTrace === 'undefined') {
          function updateAdaptiveStateTrace() {
            if (!adaptiveStateCtx) return;
            const ctx = adaptiveStateCtx;
            const c = ctx.canvas;
            const width = c.width || 400;
            const height = c.height || 120;

            while (x12History.length < particles.length) x12History.push([]);
            if (x12History.length > particles.length) x12History.length = particles.length;

            particles.forEach((p, i) => {
              const val = (typeof p.x12 === 'number' && isFinite(p.x12)) ? p.x12 : 0;
              x12History[i].push(val);
              while (x12History[i].length > width) x12History[i].shift();
            });

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            ctx.fillRect(0, 0, width, height);

            const baseline = height / 2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.moveTo(0, baseline);
            ctx.lineTo(width, baseline);
            ctx.stroke();

            particles.forEach((p, i) => {
              const colorHex = '#' + p.color.toString(16).padStart(6, '0');
              ctx.strokeStyle = colorHex;
              ctx.lineWidth = 1;
              ctx.beginPath();
              let first = true;
              const hist = x12History[i];
              for (let x = 0; x < hist.length; x++) {
                const y = baseline - (hist[x] * (height * 0.45));
                const clampedY = Math.max(0, Math.min(height, y));
                if (first) { ctx.moveTo(x, clampedY); first = false; } else { ctx.lineTo(x, clampedY); }
              }
              ctx.stroke();
            });
          }
          updateAdaptiveStateTrace.__additive = true;
        }

        // Additive: NFW profile (guarded)
        if (typeof initDmProfileCanvas === 'undefined') {
          function initDmProfileCanvas() {
            const canvas = document.getElementById('dmProfileCanvas');
            if (!canvas) return;
            dmProfileCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth || 400;
            canvas.height = 120;
            window.addEventListener('resize', () => {
              if (!dmProfileCtx) return;
              const c = dmProfileCtx.canvas;
              c.width = c.offsetWidth || 400;
              c.height = 120;
            });
          }
          initDmProfileCanvas.__additive = true;
        }

        if (typeof drawNfwProfile === 'undefined') {
          function drawNfwProfile(rho0, rs) {
            if (!dmProfileCtx) return;
            const ctx = dmProfileCtx;
            const c = ctx.canvas;
            const width = c.width || 400;
            const height = c.height || 120;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(10,10,26,0.25)';
            ctx.fillRect(0, 0, width, height);

            const samples = 200;
            const rMin = Math.max(0.1 * rs, 1e-6);
            const rMax = 10 * rs;
            const values = [];
            for (let i = 0; i < samples; i++) {
              const t = i / (samples - 1);
              const r = rMin * Math.pow(rMax / rMin, t);
              const r_rs = r / rs;
              const rho = r_rs > 0 ? rho0 / (r_rs * Math.pow(1 + r_rs, 2)) : 0;
              values.push({ r, rho });
            }

            const rhoMax = Math.max(...values.map(v => v.rho), 1e-12);
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            values.forEach((v, i) => {
              const x = (i / (samples - 1)) * width;
              const y = height - (Math.log(v.rho + 1) / Math.log(rhoMax + 1)) * height;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            });
            ctx.stroke();
          }
          drawNfwProfile.__additive = true;
        }

        // Additive: Entropy canvas + heart-rate trace (guarded)
        if (typeof initEntropyCanvas === 'undefined') {
          function initEntropyCanvas() {
            const canvas = document.getElementById('entropyCanvas');
            if (canvas) {
              entropyState.ctx = canvas.getContext('2d');
              canvas.width = canvas.offsetWidth || 400;
              canvas.height = 100;

              window.addEventListener('resize', () => {
                if (canvas) {
                  canvas.width = canvas.offsetWidth || 400;
                  canvas.height = 100;
                  if (entropyState.histogram) {
                    drawEntropyHistogram(entropyState.histogram);
                  }
                }
              });
            }

            const traceCanvas = document.getElementById('entropyTraceCanvas');
            if (traceCanvas) {
              entropyState.traceCtx = traceCanvas.getContext('2d');
              traceCanvas.width = traceCanvas.offsetWidth || 400;
              traceCanvas.height = 60;

              window.addEventListener('resize', () => {
                if (traceCanvas) {
                  const oldWidth = traceCanvas.width;
                  traceCanvas.width = traceCanvas.offsetWidth || 400;
                  traceCanvas.height = 60;

                  const newWidth = traceCanvas.width;
                  if (newWidth !== oldWidth && entropyTrace.length > 0) {
                    if (entropyTrace.length > newWidth) {
                      entropyTrace.splice(0, entropyTrace.length - newWidth);
                    }
                    if (entropyState.lastEntropy !== undefined) {
                      drawEntropyTrace(entropyState.lastEntropy);
                    }
                  }
                }
              });
            }
          }
          initEntropyCanvas.__additive = true;
        }

        if (typeof computeEntropyMetrics === 'undefined') {
          function computeEntropyMetrics() {
            const bins = 32;
            const histogram = new Array(bins).fill(0);
            let totalSpeed = 0;

            if (particles.length === 0) {
              return { entropy: 0, histogram, tempProxy: 0 };
            }

            const speeds = particles.map(p => {
              const speed = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
              totalSpeed += speed;
              return speed;
            });

            const maxSpeed = speeds.length > 0 ? Math.max(...speeds, 1) : 1;

            speeds.forEach(speed => {
              const bin = Math.min(bins - 1, Math.floor((speed / maxSpeed) * bins));
              histogram[bin]++;
            });

            const total = particles.length || 1;
            const probs = histogram.map(c => c / total);
            let S = 0;
            probs.forEach(p => { if (p > 0) S -= p * Math.log(p); });

            const tempProxy = totalSpeed / total;
            return { entropy: S, histogram, tempProxy };
          }
          computeEntropyMetrics.__additive = true;
        }

        if (typeof updateEntropy === 'undefined') {
          function updateEntropy() {
            if (particles.length === 0) {
              entropyState.histogram = new Array(entropyState.bins).fill(0);
              entropyState.lastEntropy = 0;
              entropyState.tempProxy = 0;
              entropyTrace.length = 0;

              const entropyEl = document.getElementById('entropy-global');
              const binsEl = document.getElementById('entropy-bins');
              const tempEl = document.getElementById('entropy-temperature');

              if (entropyEl) entropyEl.textContent = '0.000';
              if (binsEl) binsEl.textContent = '[]';
              if (tempEl) tempEl.textContent = '0.000';

              if (entropyState.traceCtx) {
                const ctx = entropyState.traceCtx;
                const canvas = ctx.canvas;
                const width = canvas.width || 400;
                const height = canvas.height || 60;
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
                ctx.fillRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();
              }
              return;
            }

            const { entropy, histogram, tempProxy } = computeEntropyMetrics();
            entropyState.lastEntropy = kB * entropy;
            entropyState.histogram = histogram;
            entropyState.tempProxy = tempProxy;

            const entropyEl = document.getElementById('entropy-global');
            const binsEl = document.getElementById('entropy-bins');
            const tempEl = document.getElementById('entropy-temperature');

            if (entropyEl) entropyEl.textContent = entropyState.lastEntropy.toFixed(3);
            if (binsEl) binsEl.textContent = JSON.stringify(histogram.slice(0, 5));
            if (tempEl) tempEl.textContent = tempProxy.toFixed(3);

            drawEntropyTrace(entropyState.lastEntropy);
          }
          updateEntropy.__additive = true;
        }

        if (typeof drawEntropyTrace === 'undefined') {
          function drawEntropyTrace(entropyValue) {
            if (!entropyState.traceCtx) return;

            const ctx = entropyState.traceCtx;
            const canvas = ctx.canvas;
            const width = canvas.width || 400;
            const height = canvas.height || 60;

            // EMA smoothing
            if (typeof entropyEma === 'undefined' || entropyEma === null || !isFinite(entropyEma)) {
              entropyEma = entropyValue;
            } else {
              const alpha = (entropyTraceConfig && typeof entropyTraceConfig.emaAlpha === 'number') ? entropyTraceConfig.emaAlpha : 0.3;
              entropyEma = alpha * entropyValue + (1 - alpha) * entropyEma;
            }

            const smoothed = entropyEma;
            if (typeof smoothed === 'number' && isFinite(smoothed)) {
              entropyTrace.push(smoothed);
            }
            while (entropyTrace.length > width) entropyTrace.shift();

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();

            if (entropyTrace.length > 1) {
              const valid = entropyTrace.filter(v => typeof v === 'number' && isFinite(v));
              const min = valid.length ? Math.min(...valid) : 0;
              const max = valid.length ? Math.max(...valid) : 1;
              const range = Math.max(max - min, 1e-6);
              const traceHeight = height * 0.8;
              const baseline = height / 2;

              ctx.beginPath();
              ctx.strokeStyle = '#00ffcc';
              ctx.lineWidth = 2;
              let first = true;
              for (let i = 0; i < entropyTrace.length; i++) {
                const val = entropyTrace[i];
                if (typeof val !== 'number' || !isFinite(val)) continue;
                const norm = (val - min) / range;
                const y = baseline + (traceHeight / 2) - (norm * traceHeight);
                const clampedY = Math.max(0, Math.min(height, y));
                if (first) { ctx.moveTo(i, clampedY); first = false; } else { ctx.lineTo(i, clampedY); }
              }
              ctx.stroke();
            } else if (entropyTrace.length === 1) {
              ctx.fillStyle = '#00ffcc';
              ctx.beginPath();
              ctx.arc(0, height / 2, 2, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          drawEntropyTrace.__additive = true;
        }

        if (typeof drawEntropyHistogram === 'undefined') {
          function drawEntropyHistogram(histogram) {
            if (!entropyState.ctx) return;

            const ctx = entropyState.ctx;
            const canvas = ctx.canvas;
            const width = canvas.width;
            const height = canvas.height;

            const hist = histogram || entropyState.histogram || new Array(entropyState.bins).fill(0);

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            ctx.fillRect(0, 0, width, height);

            const barW = width / entropyState.bins;
            const maxCount = Math.max(...hist, 1);

            for (let i = 0; i < entropyState.bins; i++) {
              const barH = (hist[i] / maxCount) * height;
              const hue = (i / entropyState.bins) * 360;
              ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
              ctx.fillRect(i * barW, height - barH, barW - 1, barH);
            }
          }
          drawEntropyHistogram.__additive = true;
        }

        // Additive: Replay validation updater (guarded)
        if (typeof updateReplayValidation === 'undefined') {
          function updateReplayValidation(consStats, virial) {
            if (determinism.mode !== 'replay') return;
            const edriftEl = document.getElementById('replay-edrift');
            const pmagEl = document.getElementById('replay-pmag');
            const lmagEl = document.getElementById('replay-lmag');
            const virialEl = document.getElementById('replay-virial');
            if (!edriftEl || !pmagEl || !lmagEl || !virialEl) return;

            edriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
            const Pmag = Math.sqrt(consStats.P.x**2 + consStats.P.y**2 + consStats.P.z**2);
            const Lmag = Math.sqrt(consStats.L.x**2 + consStats.L.y**2 + consStats.L.z**2);
            pmagEl.textContent = Pmag.toExponential(2);
            lmagEl.textContent = Lmag.toExponential(2);
            virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
          }
          updateReplayValidation.__additive = true;
        }

        // Additive: Token hygiene and buffered flush (guarded)
        if (typeof addToken === 'undefined') {
          function addToken(tokenObj) {
            if (!tokenObj || typeof tokenObj !== 'object') return;
            const now = Date.now();
            if (tokenRateWindow && Array.isArray(tokenRateWindow.timestamps)) {
              tokenRateWindow.timestamps.push(now);
            }
            tokenBuffer.tokens.push(tokenObj);

            const indicator = document.getElementById('tokenIndicator');
            if (indicator) {
              indicator.classList.add('active');
              setTimeout(() => { indicator.classList.remove('active'); }, 100);
            }
          }
          addToken.__additive = true;
        }

        if (typeof flushTokenBuffer === 'undefined') {
          function flushTokenBuffer() {
            if (!tokenBuffer.tokens || tokenBuffer.tokens.length === 0) return;
            tokenBuffer.tokens.forEach(token => {
              tokens.push(token);
              tokenCount++;
            });

            if (typeof updateTokenDisplay === 'function') {
              updateTokenDisplay();
            }

            const countEl = document.getElementById('token-count');
            const countStatusEl = document.getElementById('token-count-status');
            const replEl = document.getElementById('replication-count');
            if (countEl) countEl.textContent = tokens.length;
            if (countStatusEl) countStatusEl.textContent = tokens.length;
            if (replEl) replEl.textContent = replicationCount;

            tokenBuffer.tokens = [];
          }
          flushTokenBuffer.__additive = true;
        }

        if (typeof startTokenBufferFlush === 'undefined') {
          function startTokenBufferFlush() {
            if (tokenBuffer.flushInterval) clearInterval(tokenBuffer.flushInterval);
            tokenBuffer.flushInterval = setInterval(flushTokenBuffer, tokenBuffer.flushRate || 50);

            if (tokenRateUpdateInterval) clearInterval(tokenRateUpdateInterval);
            tokenRateUpdateInterval = setInterval(() => {
              if (typeof updateTokenRate === 'function') updateTokenRate();
            }, 500);
          }
          startTokenBufferFlush.__additive = true;
        }

        if (typeof stopTokenBufferFlush === 'undefined') {
          function stopTokenBufferFlush() {
            if (tokenBuffer.flushInterval) {
              clearInterval(tokenBuffer.flushInterval);
              tokenBuffer.flushInterval = null;
            }
            if (tokenRateUpdateInterval) {
              clearInterval(tokenRateUpdateInterval);
              tokenRateUpdateInterval = null;
            }
            if (typeof flushTokenBuffer === 'function') flushTokenBuffer();
          }
          stopTokenBufferFlush.__additive = true;
        }

        // Additive: Projection mode immediate reproject (guarded patch)
        (function patchProjectionMode() {
          const el = document.getElementById('projection-mode');
          if (!el || el.__patchedProjection) return;
          el.addEventListener('change', (e) => {
            projectionConfig.mode = e.target.value;
            const statusEl = document.getElementById('projection-status');
            if (statusEl) statusEl.textContent = projectionConfig.mode;
            projectionConfig.randomR = null; // forces regen for random embedding
            particles.forEach(p => p.update11DProjection());
            updateStatus(`Projection mode changed to: ${projectionConfig.mode}`);
          });
          el.__patchedProjection = true;
        })();

        // Additive: Wire init if not already
        document.addEventListener('DOMContentLoaded', () => {
          if (typeof initAdaptiveStateCanvas === 'function') initAdaptiveStateCanvas();
          if (typeof initEntropyCanvas === 'function') initEntropyCanvas();
          if (typeof initDmProfileCanvas === 'function') initDmProfileCanvas();
          if (typeof drawNfwProfile === 'function') drawNfwProfile(dmParams.rho0, dmParams.rs);
        });

        // Additive: CST Runtime, Determinism, dt and Token Buffer Fixes (guarded)
        // Insert this block near the end of the <script> before final DOMContentLoaded init.
        // All definitions are guarded to avoid redefinition.

        if (typeof __CST_ADDITIVE_PATCH_1_2__ === 'undefined') {
          // Additive: mark applied
          window.__CST_ADDITIVE_PATCH_1_2__ = true;

          // Additive: deterministic local PRNG state (does NOT mutate determinism.seed)
          window.__cst_detRandomState = window.__cst_detRandomState ?? null;
          function __cst_resetDeterministicRandomState(seed) {
            window.__cst_detRandomState = (typeof seed === 'number') ? (seed >>> 0) : null;
          }

          // Additive: safe getRandom that uses local state in replay without mutating determinism.seed
          if (typeof window.getRandom !== 'function' || !window.getRandom.__cstPatched) {
            const orig_getRandom = typeof window.getRandom === 'function' ? window.getRandom : null;
            window.getRandom = function __cst_getRandom() {
              try {
                if (typeof determinism !== 'undefined' && determinism && determinism.mode === 'replay' && typeof determinism.seed === 'number') {
                  if (window.__cst_detRandomState === null) window.__cst_detRandomState = determinism.seed >>> 0;
                  window.__cst_detRandomState = (window.__cst_detRandomState * 1103515245 + 12345) & 0x7fffffff;
                  return window.__cst_detRandomState / 0x7fffffff;
                }
              } catch (e) {
                console.warn('CST getRandom patch error', e);
              }
              return orig_getRandom ? orig_getRandom() : Math.random();
            };
            window.getRandom.__cstPatched = true;
          }

          // Additive: stable generateUUID for replay using local PRNG state without mutating determinism.seed
          if (typeof window.generateUUID === 'function' && !window.generateUUID.__cstPatched) {
            const orig_generateUUID = window.generateUUID;
            window.generateUUID = function __cst_generateUUID() {
              try {
                if (typeof determinism !== 'undefined' && determinism && determinism.mode === 'replay' && typeof determinism.seed === 'number') {
                  // use local state copy
                  if (window.__cst_detRandomState === null) window.__cst_detRandomState = determinism.seed >>> 0;
                  window.__cst_detRandomState = (window.__cst_detRandomState * 1103515245 + 12345) & 0x7fffffff;
                  const s = window.__cst_detRandomState;
                  // produce hex nibble stream deterministically
                  let ptr = s;
                  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    ptr = (ptr * 1103515245 + 12345) & 0x7fffffff;
                    const r = ptr % 16;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                  });
                }
              } catch (e) {
                console.warn('CST generateUUID patch error', e);
              }
              return orig_generateUUID ? orig_generateUUID() : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
              });
            };
            window.generateUUID.__cstPatched = true;
          }

          // Additive: nextDeterministicId - guarded replacement that avoids mutating seed
          if (typeof window.nextDeterministicId === 'function' && !window.nextDeterministicId.__cstPatched) {
            const orig_nextDeterministicId = window.nextDeterministicId;
            window.nextDeterministicId = function __cst_nextDeterministicId() {
              try {
                if (typeof determinism !== 'undefined' && determinism && determinism.mode === 'replay') {
                  window.deterministicIdCounter = (typeof window.deterministicIdCounter === 'number') ? window.deterministicIdCounter + 1 : 1;
                  return `replay-${determinism.seed || 0}-${window.deterministicIdCounter}`;
                }
              } catch (e) {
                console.warn('CST nextDeterministicId patch error', e);
              }
              return orig_nextDeterministicId ? orig_nextDeterministicId() : (generateUUID ? generateUUID() : 'id-' + Date.now());
            };
            window.nextDeterministicId.__cstPatched = true;
          }

          // Additive: patch LorenzParticle.update to ensure energy uses timestep.dt (guarded)
          if (typeof LorenzParticle === 'function' && LorenzParticle.prototype && !LorenzParticle.prototype.update.__cstPatchedDt) {
            const orig_update = LorenzParticle.prototype.update;
            LorenzParticle.prototype.update = function __cst_update_dt_patch(audioModulation, gravAcceleration) {
              // Call original update to compute dx,dy,dz etc.
              const ret = orig_update.call(this, audioModulation, gravAcceleration);
              try {
                // Recompute/validate energy using timestep.dt (safe fallback)
                const dx = (ret && typeof ret.dx === 'number') ? ret.dx : 0;
                const dy = (ret && typeof ret.dy === 'number') ? ret.dy : 0;
                const dz = (ret && typeof ret.dz === 'number') ? ret.dz : 0;
                const dt = (typeof timestep !== 'undefined' && timestep && typeof timestep.dt === 'number' && isFinite(timestep.dt) && timestep.dt > 0) ? timestep.dt : 0.001;
                const velocityMagnitude = Math.sqrt(dx*dx + dy*dy + dz*dz) / dt;
                // Use mass fallback
                const m = (typeof this.mass === 'number' && isFinite(this.mass) && this.mass > 0) ? this.mass : 1;
                this.energy = 0.5 * m * velocityMagnitude * velocityMagnitude;
              } catch (e) {
                console.warn('CST LorenzParticle.update energy patch failed', e);
              }
              return ret;
            };
            LorenzParticle.prototype.update.__cstPatchedDt = true;
          }

          // Additive: patch computeAdaptiveDt consumer expectation to be robust (no replacement, but safeguard)
          if (typeof computeAdaptiveDt === 'function' && !computeAdaptiveDt.__cstPatched) {
            const orig_computeAdaptiveDt = computeAdaptiveDt;
            computeAdaptiveDt = function __cst_computeAdaptiveDt(particlesArg, physicsArg, timestepConfig) {
              try {
                return orig_computeAdaptiveDt.call(this, particlesArg, physicsArg, timestepConfig);
              } catch (e) {
                console.warn('CST computeAdaptiveDt fallback', e);
                return (timestepConfig && typeof timestepConfig.dtMax === 'number') ? Math.max(0.001, Math.min(0.01, timestepConfig.dtMax)) : 0.005;
              }
            };
            computeAdaptiveDt.__cstPatched = true;
          }

          // Additive: restartAudioProcessingLoop robust implementation (guarded)
          if (typeof restartAudioProcessingLoop === 'function' && !restartAudioProcessingLoop.__cstPatched) {
            restartAudioProcessingLoop = (function(orig) {
              return function __cst_restartAudioProcessingLoop() {
                try {
                  if (audioProcessingInterval) { clearInterval(audioProcessingInterval); audioProcessingInterval = null; }
                  if (isAudioActive && typeof processAudio === 'function') {
                    try { processAudio(); } catch (e) { console.error('processAudio immediate call error', e); }
                    audioProcessingInterval = setInterval(() => {
                      try { processAudio(); } catch (e) { console.error('processAudio interval error', e); }
                    }, Math.max(1, audioConfig.cadence || 100));
                  }
                } catch (e) {
                  console.error('CST restartAudioProcessingLoop error', e);
                }
              };
            })(restartAudioProcessingLoop);
            restartAudioProcessingLoop.__cstPatched = true;
          }

          // Additive: restartReplayLoop robust implementation (guarded)
          if (typeof restartReplayLoop === 'function' && !restartReplayLoop.__cstPatched) {
            restartReplayLoop = (function(orig) {
              return function __cst_restartReplayLoop() {
                try {
                  if (determinism.replayInterval) { clearInterval(determinism.replayInterval); determinism.replayInterval = null; }
                  if (determinism.mode === 'replay' && Array.isArray(determinism.recordedAudioFrames) && determinism.recordedAudioFrames.length > 0) {
                    try { processReplayAudio(); } catch (e) { console.error('processReplayAudio immediate call error', e); }
                    determinism.replayInterval = setInterval(() => {
                      try { processReplayAudio(); } catch (e) { console.error('processReplayAudio interval error', e); }
                    }, Math.max(1, audioConfig.cadence || 100));
                  }
                } catch (e) {
                  console.error('CST restartReplayLoop error', e);
                }
              };
            })(restartReplayLoop);
            restartReplayLoop.__cstPatched = true;
          }

          // Additive: robust flushTokenBuffer with bounds and try/finally (guarded)
          if (typeof flushTokenBuffer === 'function' && !flushTokenBuffer.__cstPatched) {
            const orig_flushTokenBuffer = flushTokenBuffer;
            flushTokenBuffer = function __cst_flushTokenBuffer() {
              try {
                if (!tokenBuffer || !Array.isArray(tokenBuffer.tokens) || tokenBuffer.tokens.length === 0) return;
                // Cap pending buffer to avoid runaway memory
                const MAX_PENDING = 500;
                if (tokenBuffer.tokens.length > MAX_PENDING) {
                  tokenBuffer.tokens.splice(0, tokenBuffer.tokens.length - MAX_PENDING);
                }
                // Append buffered tokens to main tokens array
                tokenBuffer.tokens.forEach(t => {
                  tokens.push(t);
                  tokenCount++;
                });
                // Cap total tokens stored in memory/UI
                const MAX_TOTAL_TOKENS = 5000;
                if (tokens.length > MAX_TOTAL_TOKENS) {
                  tokens.splice(0, tokens.length - MAX_TOTAL_TOKENS);
                }
                // Safe UI update
                if (typeof updateTokenDisplay === 'function') {
                  try { updateTokenDisplay(); } catch (e) { console.error('updateTokenDisplay error', e); }
                }
                const countEl = document.getElementById('token-count');
                const countStatusEl = document.getElementById('token-count-status');
                const replEl = document.getElementById('replication-count');
                if (countEl) countEl.textContent = tokens.length;
                if (countStatusEl) countStatusEl.textContent = tokens.length;
                if (replEl) replEl.textContent = replicationCount;
              } catch (e) {
                console.error('CST flushTokenBuffer error', e);
              } finally {
                // Always clear buffer to avoid reprocessing stale entries
                if (tokenBuffer) tokenBuffer.tokens = [];
              }
            };
            flushTokenBuffer.__cstPatched = true;
          }

          // Additive: startTokenBufferFlush robust start/stop (guarded)
          if (typeof startTokenBufferFlush === 'function' && !startTokenBufferFlush.__cstPatched) {
            startTokenBufferFlush = (function(orig) {
              return function __cst_startTokenBufferFlush() {
                try {
                  if (tokenBuffer.flushInterval) clearInterval(tokenBuffer.flushInterval);
                  tokenBuffer.flushInterval = setInterval(() => {
                    try { flushTokenBuffer(); } catch (e) { console.error('flushTokenBuffer interval error', e); }
                  }, tokenBuffer.flushRate || 50);
                  if (tokenRateUpdateInterval) clearInterval(tokenRateUpdateInterval);
                  tokenRateUpdateInterval = setInterval(() => {
                    try { updateTokenRate(); } catch (e) { console.error('updateTokenRate error', e); }
                  }, 500);
                } catch (e) {
                  console.error('CST startTokenBufferFlush error', e);
                }
              };
            })(startTokenBufferFlush);
            startTokenBufferFlush.__cstPatched = true;
          }

          if (typeof stopTokenBufferFlush === 'function' && !stopTokenBufferFlush.__cstPatched) {
            stopTokenBufferFlush = (function(orig) {
              return function __cst_stopTokenBufferFlush() {
                try {
                  if (tokenBuffer.flushInterval) { clearInterval(tokenBuffer.flushInterval); tokenBuffer.flushInterval = null; }
                  if (tokenRateUpdateInterval) { clearInterval(tokenRateUpdateInterval); tokenRateUpdateInterval = null; }
                  // flush one final time safely
                  try { flushTokenBuffer(); } catch (e) { console.error('final flushTokenBuffer error', e); }
                } catch (e) {
                  console.error('CST stopTokenBufferFlush error', e);
                }
              };
            })(stopTokenBufferFlush);
            stopTokenBufferFlush.__cstPatched = true;
          }

          // Additive: reset deterministic states when setting seed or starting replay processing
          if (typeof setDeterministicSeed === 'function' && !setDeterministicSeed.__cstPatched) {
            const orig_setDeterministicSeed = setDeterministicSeed;
            setDeterministicSeed = function __cst_setDeterministicSeed(seed) {
              try {
                if (typeof orig_setDeterministicSeed === 'function') orig_setDeterministicSeed(seed);
              } catch (e) {
                console.warn('orig setDeterministicSeed error', e);
              }
              try {
                __cst_resetDeterministicRandomState(seed);
                window.deterministicIdCounter = 0;
                window.deterministicRandom = seed;
              } catch (e) {
                console.warn('CST setDeterministicSeed patch error', e);
              }
            };
            setDeterministicSeed.__cstPatched = true;
          }

          if (typeof startReplayProcessing === 'function' && !startReplayProcessing.__cstPatched) {
            const orig_startReplayProcessing = startReplayProcessing;
            startReplayProcessing = function __cst_startReplayProcessing() {
              try {
                __cst_resetDeterministicRandomState(determinism.seed || projectionConfig.randomSeed || 12345);
                window.deterministicIdCounter = 0;
                window.deterministicRandom = determinism.seed || projectionConfig.randomSeed || 12345;
              } catch (e) {
                console.warn('CST startReplayProcessing init error', e);
              }
              return typeof orig_startReplayProcessing === 'function' ? orig_startReplayProcessing() : void 0;
            };
            startReplayProcessing.__cstPatched = true;
          }

          // Additive: ensure token buffer flush starts on DOMContentLoaded
          document.addEventListener('DOMContentLoaded', () => {
            try {
              if (!tokenBuffer.flushInterval) startTokenBufferFlush();
            } catch (e) {
              console.warn('CST DOMContentLoaded startTokenBufferFlush error', e);
            }
          });

          // Additive: cleanup on unload to avoid zombie intervals
          window.addEventListener('beforeunload', () => {
            try {
              if (audioProcessingInterval) { clearInterval(audioProcessingInterval); audioProcessingInterval = null; }
              if (tokenBuffer && tokenBuffer.flushInterval) { clearInterval(tokenBuffer.flushInterval); tokenBuffer.flushInterval = null; }
              if (tokenRateUpdateInterval) { clearInterval(tokenRateUpdateInterval); tokenRateUpdateInterval = null; }
              if (determinism && determinism.replayInterval) { clearInterval(determinism.replayInterval); determinism.replayInterval = null; }
              // Pause animation/rendering loop
              isPaused = true;
              // Attempt clean stops
              if (typeof stopAudio === 'function') try { stopAudio(); } catch (e) { /* ignore */ }
              if (typeof stopTokenBufferFlush === 'function') try { stopTokenBufferFlush(); } catch (e) { /* ignore */ }
              if (typeof stopReplayProcessing === 'function') try { stopReplayProcessing(); } catch (e) { /* ignore */ }
            } catch (e) {
              console.warn('CST beforeunload cleanup error', e);
            }
          });

        } // end guarded patch

        // Additive: X12 Entropy Real-time & Determinism Hardening Patch
        (function() {
          if (typeof window.CST_PATCH_X12_ENTROPY !== 'undefined') return;
          window.CST_PATCH_X12_ENTROPY = true;

          console.log('[CST] Applying X12+Entropy real-time patch...');

          // Additive: Particle integrator initialization helper
          function __cst_initParticleIntegrators(p) {
            if (!p || !p.id) return;
            try {
              if (typeof psiAccumulators !== 'undefined') {
                if (!psiAccumulators.velocityIntegral.has(p.id)) {
                  psiAccumulators.velocityIntegral.set(p.id, 0);
                }
                if (!psiAccumulators.x12Integral.has(p.id)) {
                  psiAccumulators.x12Integral.set(p.id, 0);
                }
                if (!psiAccumulators.x12Previous.has(p.id)) {
                  psiAccumulators.x12Previous.set(p.id, p.x12 || 0);
                }
              }
            } catch (e) {
              console.warn('[CST] Integrator init failed for particle', p.id, e);
            }
          }

          // Additive: Initialize integrators for all existing particles
          try {
            if (typeof particles !== 'undefined' && Array.isArray(particles)) {
              particles.forEach(__cst_initParticleIntegrators);
              console.log('[CST] Initialized integrators for', particles.length, 'existing particles');
            }
          } catch (e) {
            console.warn('[CST] Existing particle integrator init error', e);
          }

          // Additive: Patch LorenzParticle.update11DProjection to init integrators for new particles
          try {
            if (typeof LorenzParticle !== 'undefined' && LorenzParticle.prototype && !LorenzParticle.prototype.__cstIntegratorPatched) {
              const orig_update11D = LorenzParticle.prototype.update11DProjection;
              if (typeof orig_update11D === 'function') {
                LorenzParticle.prototype.update11DProjection = function(...args) {
                  __cst_initParticleIntegrators(this);
                  return orig_update11D.apply(this, args);
                };
                LorenzParticle.prototype.__cstIntegratorPatched = true;
                console.log('[CST] Patched LorenzParticle.update11DProjection for integrator init');
              }
            }
          } catch (e) {
            console.warn('[CST] LorenzParticle integrator patch error', e);
          }

          // Additive: Robust updatePsiNormalized wrapper with safe x12Previous handling
          try {
            if (typeof window.updatePsiNormalized === 'function' && !window.updatePsiNormalized.__cstX12Patched) {
              const orig_updatePsiNormalized = window.updatePsiNormalized;
              window.updatePsiNormalized = function(particles, refs, accum) {
                try {
                  if (!accum || !particles) return orig_updatePsiNormalized(particles, refs, accum);

                  // Additive: Pre-process particles to ensure x12Previous exists
                  particles.forEach(p => {
                    if (!p || !p.id) return;
                    const x12Prev = accum.x12Previous.get(p.id);
                    if (x12Prev === undefined || x12Prev === null) {
                      // First-seen: initialize previous value (no delta this frame)
                      accum.x12Previous.set(p.id, p.x12 || 0);
                      if (!accum.x12Integral.has(p.id)) accum.x12Integral.set(p.id, 0);
                    } else {
                      // Compute delta and accumulate
                      const dt = (typeof timestep !== 'undefined' && timestep.dt) ? timestep.dt : 0.001;
                      const deltaX12 = Math.abs((p.x12 || 0) - x12Prev);
                      const x12IntPrev = accum.x12Integral.get(p.id) || 0;
                      const x12IntNew = x12IntPrev + deltaX12 * dt;
                      accum.x12Integral.set(p.id, x12IntNew);
                      accum.x12Previous.set(p.id, p.x12 || 0);
                    }
                  });

                  // Call original
                  return orig_updatePsiNormalized(particles, refs, accum);
                } catch (e) {
                  console.warn('[CST] updatePsiNormalized wrapper error', e);
                  return orig_updatePsiNormalized(particles, refs, accum);
                }
              };
              window.updatePsiNormalized.__cstX12Patched = true;
              console.log('[CST] Patched updatePsiNormalized for robust x12 accumulation');
            }
          } catch (e) {
            console.warn('[CST] updatePsiNormalized patch error', e);
          }

          // Additive: DPR-aware canvas initialization for entropy trace
          try {
            if (typeof window.initEntropyCanvas === 'function' && !window.initEntropyCanvas.__cstDPRPatched) {
              const orig_initEntropyCanvas = window.initEntropyCanvas;
              window.initEntropyCanvas = function() {
                try {
                  // Call original first
                  if (typeof orig_initEntropyCanvas === 'function') orig_initEntropyCanvas();

                  // Additive: Apply DPR sizing
                  const dpr = window.devicePixelRatio || 1;
                  const canvas = document.getElementById('entropyCanvas');
                  if (canvas) {
                    const cssW = canvas.clientWidth || 400;
                    const cssH = canvas.clientHeight || 100;
                    canvas.width = Math.floor(cssW * dpr);
                    canvas.height = Math.floor(cssH * dpr);
                    const ctx = canvas.getContext('2d');
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                    if (typeof entropyState !== 'undefined') entropyState.ctx = ctx;
                  }

                  const traceCanvas = document.getElementById('entropyTraceCanvas');
                  if (traceCanvas) {
                    const tw = traceCanvas.clientWidth || 400;
                    const th = traceCanvas.clientHeight || 60;
                    traceCanvas.width = Math.floor(tw * dpr);
                    traceCanvas.height = Math.floor(th * dpr);
                    const tctx = traceCanvas.getContext('2d');
                    tctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                    if (typeof entropyState !== 'undefined') entropyState.traceCtx = tctx;
                  }

                  console.log('[CST] Applied DPR-aware canvas sizing (dpr=' + dpr + ')');
                } catch (e) {
                  console.warn('[CST] initEntropyCanvas DPR patch error', e);
                }
              };
              window.initEntropyCanvas.__cstDPRPatched = true;
            }
          } catch (e) {
            console.warn('[CST] initEntropyCanvas DPR patch error', e);
          }

          // Additive: Resilient resize handler for entropy canvases
          try {
            window.addEventListener('resize', function __cst_entropyCanvasResize() {
              try {
                const dpr = window.devicePixelRatio || 1;
                const canvas = document.getElementById('entropyCanvas');
                if (canvas) {
                  const cssW = canvas.clientWidth || 400;
                  const cssH = canvas.clientHeight || 100;
                  canvas.width = Math.floor(cssW * dpr);
                  canvas.height = Math.floor(cssH * dpr);
                  const ctx = canvas.getContext('2d');
                  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                  if (typeof entropyState !== 'undefined') entropyState.ctx = ctx;
                  if (typeof drawEntropyHistogram === 'function') drawEntropyHistogram();
                }

                const traceCanvas = document.getElementById('entropyTraceCanvas');
                if (traceCanvas) {
                  const tw = traceCanvas.clientWidth || 400;
                  const th = traceCanvas.clientHeight || 60;
                  traceCanvas.width = Math.floor(tw * dpr);
                  traceCanvas.height = Math.floor(th * dpr);
                  const tctx = traceCanvas.getContext('2d');
                  tctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                  if (typeof entropyState !== 'undefined') entropyState.traceCtx = tctx;
                  if (typeof entropyState !== 'undefined' && typeof drawEntropyTrace === 'function') {
                    drawEntropyTrace(entropyState.lastEntropy || 0);
                  }
                }
              } catch (e) {
                console.warn('[CST] Entropy canvas resize error', e);
              }
            });
          } catch (e) {
            console.warn('[CST] Resize listener error', e);
          }

          // Additive: Robust drawEntropyTrace with CSS width buffer limit
          try {
            if (typeof window.drawEntropyTrace === 'function' && !window.drawEntropyTrace.__cstCSSWidthPatched) {
              const orig_drawEntropyTrace = window.drawEntropyTrace;
              window.drawEntropyTrace = function(entropyValue) {
                try {
                  if (typeof entropyState === 'undefined' || !entropyState.traceCtx) return;
                  const ctx = entropyState.traceCtx;
                  const canvas = ctx.canvas;
                  const widthCSS = canvas.clientWidth || 400;
                  const heightCSS = canvas.clientHeight || 60;

                  // Additive: Use smoothed value, reject NaN/Inf
                  const smoothed = (typeof getSmoothedEntropy === 'function') ? getSmoothedEntropy(entropyValue) : entropyValue;
                  if (typeof smoothed === 'number' && isFinite(smoothed)) {
                    if (typeof entropyTrace !== 'undefined') entropyTrace.push(smoothed);
                  }

                  // Additive: Buffer length = CSS width
                  if (typeof entropyTrace !== 'undefined') {
                    while (entropyTrace.length > widthCSS) entropyTrace.shift();
                  }

                  // Additive: Auto-scale and draw trace
                  if (typeof entropyTrace !== 'undefined' && entropyTrace.length > 0) {
                    const minVal = Math.min(...entropyTrace);
                    const maxVal = Math.max(...entropyTrace);
                    const range = maxVal - minVal || 1;

                    ctx.clearRect(0, 0, widthCSS, heightCSS);
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    entropyTrace.forEach((val, i) => {
                      const x = i;
                      const y = heightCSS - ((val - minVal) / range) * (heightCSS - 4) - 2;
                      if (i === 0) ctx.moveTo(x, y);
                      else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                  }

                  // Store last entropy for resize redraw
                  if (typeof entropyState !== 'undefined') entropyState.lastEntropy = entropyValue;
                } catch (e) {
                  console.warn('[CST] drawEntropyTrace error', e);
                  // Fallback to original
                  if (typeof orig_drawEntropyTrace === 'function') orig_drawEntropyTrace(entropyValue);
                }
              };
              window.drawEntropyTrace.__cstCSSWidthPatched = true;
              console.log('[CST] Patched drawEntropyTrace for CSS width buffer');
            }
          } catch (e) {
            console.warn('[CST] drawEntropyTrace patch error', e);
          }

          // Additive: Patch updateLorenzParticles to call updatePsiBreakdown after particle updates
          try {
            if (typeof window.updateLorenzParticles === 'function' && !window.updateLorenzParticles.__cstPsiBreakdownPatched) {
              const orig_updateLorenzParticles = window.updateLorenzParticles;
              window.updateLorenzParticles = function(...args) {
                try {
                  const result = orig_updateLorenzParticles.apply(this, args);

                  // Additive: Refresh UI immediately
                  if (typeof updatePsiBreakdown === 'function') updatePsiBreakdown();
                  if (typeof entropyState !== 'undefined' && typeof drawEntropyTrace === 'function') {
                    drawEntropyTrace(entropyState.lastEntropy || 0);
                  }

                  return result;
                } catch (e) {
                  console.warn('[CST] updateLorenzParticles wrapper error', e);
                  return orig_updateLorenzParticles.apply(this, args);
                }
              };
              window.updateLorenzParticles.__cstPsiBreakdownPatched = true;
              console.log('[CST] Patched updateLorenzParticles to call updatePsiBreakdown');
            }
          } catch (e) {
            console.warn('[CST] updateLorenzParticles patch error', e);
          }

          // Additive: Deterministic RNG state (local, non-mutating)
          window.__cst_detRandomState = { seed: 12345, counter: 0 };

          function __cst_resetDeterministicRandomState(seed) {
            window.__cst_detRandomState.seed = seed || 12345;
            window.__cst_detRandomState.counter = 0;
          }

          function __cst_detRandom() {
            const s = window.__cst_detRandomState;
            s.counter++;
            const x = Math.sin(s.seed + s.counter) * 10000;
            return x - Math.floor(x);
          }

          // Additive: Safe getRandom wrapper (uses local state in replay mode)
          try {
            if (typeof window.getRandom === 'function' && !window.getRandom.__cstDetPatched) {
              const orig_getRandom = window.getRandom;
              window.getRandom = function() {
                try {
                  if (typeof determinism !== 'undefined' && determinism.enabled && determinism.isReplaying) {
                    return __cst_detRandom();
                  }
                  return orig_getRandom();
                } catch (e) {
                  console.warn('[CST] getRandom wrapper error', e);
                  return Math.random();
                }
              };
              window.getRandom.__cstDetPatched = true;
            }
          } catch (e) {
            console.warn('[CST] getRandom patch error', e);
          }

          // Additive: Safe generateUUID wrapper (uses local state in replay mode)
          try {
            if (typeof window.generateUUID === 'function' && !window.generateUUID.__cstDetPatched) {
              const orig_generateUUID = window.generateUUID;
              window.generateUUID = function() {
                try {
                  if (typeof determinism !== 'undefined' && determinism.enabled && determinism.isReplaying) {
                    const r = __cst_detRandom;
                    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                      const rnd = Math.floor(r() * 16);
                      const v = c === 'x' ? rnd : (rnd & 0x3 | 0x8);
                      return v.toString(16);
                    });
                  }
                  return orig_generateUUID();
                } catch (e) {
                  console.warn('[CST] generateUUID wrapper error', e);
                  return orig_generateUUID();
                }
              };
              window.generateUUID.__cstDetPatched = true;
            }
          } catch (e) {
            console.warn('[CST] generateUUID patch error', e);
          }

          // Additive: Patch setDeterministicSeed to reset local state
          try {
            if (typeof window.setDeterministicSeed === 'function' && !window.setDeterministicSeed.__cstLocalStatePatched) {
              const orig_setDeterministicSeed = window.setDeterministicSeed;
              window.setDeterministicSeed = function(seed) {
                __cst_resetDeterministicRandomState(seed);
                if (typeof deterministicIdCounter !== 'undefined') {
                  window.deterministicIdCounter = 0;
                }
                return orig_setDeterministicSeed(seed);
              };
              window.setDeterministicSeed.__cstLocalStatePatched = true;
            }
          } catch (e) {
            console.warn('[CST] setDeterministicSeed patch error', e);
          }

          // Additive: Patch startReplayProcessing to reset local state
          try {
            if (typeof window.startReplayProcessing === 'function' && !window.startReplayProcessing.__cstLocalStatePatched) {
              const orig_startReplayProcessing = window.startReplayProcessing;
              window.startReplayProcessing = function(...args) {
                __cst_resetDeterministicRandomState(determinism?.seed || 12345);
                if (typeof deterministicIdCounter !== 'undefined') {
                  window.deterministicIdCounter = 0;
                }
                return orig_startReplayProcessing.apply(this, args);
              };
              window.startReplayProcessing.__cstLocalStatePatched = true;
            }
          } catch (e) {
            console.warn('[CST] startReplayProcessing patch error', e);
          }

          // Additive: Harden flushTokenBuffer with caps
          try {
            if (typeof window.flushTokenBuffer === 'function' && !window.flushTokenBuffer.__cstCappedPatched) {
              const orig_flushTokenBuffer = window.flushTokenBuffer;
              window.flushTokenBuffer = function() {
                const MAX_PENDING = 500;
                const MAX_TOTAL_TOKENS = 5000;
                try {
                  if (typeof tokenBuffer !== 'undefined' && Array.isArray(tokenBuffer.pending)) {
                    // Cap pending tokens
                    if (tokenBuffer.pending.length > MAX_PENDING) {
                      tokenBuffer.pending = tokenBuffer.pending.slice(-MAX_PENDING);
                    }
                  }
                  const result = orig_flushTokenBuffer();

                  // Cap stored tokens
                  if (typeof tokenBuffer !== 'undefined' && Array.isArray(tokenBuffer.tokens)) {
                    if (tokenBuffer.tokens.length > MAX_TOTAL_TOKENS) {
                      tokenBuffer.tokens = tokenBuffer.tokens.slice(-MAX_TOTAL_TOKENS);
                    }
                  }
                  return result;
                } catch (e) {
                  console.warn('[CST] flushTokenBuffer error', e);
                  return orig_flushTokenBuffer();
                } finally {
                  // Always clear pending buffer
                  if (typeof tokenBuffer !== 'undefined' && Array.isArray(tokenBuffer.pending)) {
                    tokenBuffer.pending.length = 0;
                  }
                }
              };
              window.flushTokenBuffer.__cstCappedPatched = true;
            }
          } catch (e) {
            console.warn('[CST] flushTokenBuffer patch error', e);
          }

          // Additive: Ensure token buffer flush starts on DOMContentLoaded
          document.addEventListener('DOMContentLoaded', function __cst_ensureTokenBufferFlush() {
            try {
              if (typeof tokenBuffer !== 'undefined' && !tokenBuffer.flushInterval && typeof startTokenBufferFlush === 'function') {
                startTokenBufferFlush();
                console.log('[CST] Started token buffer flush on DOMContentLoaded');
              }
            } catch (e) {
              console.warn('[CST] Token buffer flush start error', e);
            }
          });

          // Additive: Debug helper
          window.__cst_dumpX12Integrals = function() {
            try {
              if (typeof psiAccumulators === 'undefined') {
                console.log('psiAccumulators not defined');
                return [];
              }
              const data = [];
              psiAccumulators.x12Integral.forEach((val, pid) => {
                data.push({ particleId: pid, x12Integral: val });
              });
              console.table(data);
              return data;
            } catch (e) {
              console.warn('[CST] dumpX12Integrals error', e);
              return [];
            }
          };

          console.log('[CST] X12+Entropy real-time patch applied successfully');
          console.log('[CST] Debug: Run window.__cst_dumpX12Integrals() to inspect œà integrators');

        })();

        // Additive: Comprehensive 12D Cosmic Synapse Theory Feature Completion Patch
        (function() {
          if (typeof window.CST_THEORY_COMPLETE !== 'undefined') return;
          window.CST_THEORY_COMPLETE = true;

          console.log('[CST Theory] Applying comprehensive feature completion patch...');

          // ========================================================================
          // 1. ADAPTIVE STATE TRACE VISUALIZATION
          // Implements: Section 2.9 - Internal State Evolution Dynamics
          // Visualizes x12 and m12 evolution as live strip charts
          // ========================================================================

          // Additive: Create trace buffers for x12 and m12
          const adaptiveStateTraces = {
            x12Buffer: [], // Average x12 over time
            m12Buffer: [], // Average m12 over time
            maxBufferLength: 400 // CSS pixels width of canvas
          };

          // Additive: Draw adaptive state strip chart
          function __cst_drawAdaptiveStateTrace() {
            try {
              if (typeof adaptiveStateCtx === 'undefined' || !adaptiveStateCtx) return;
              if (typeof particles === 'undefined' || particles.length === 0) return;

              const ctx = adaptiveStateCtx;
              const canvas = ctx.canvas;
              const dpr = window.devicePixelRatio || 1;
              const widthCSS = canvas.clientWidth || 400;
              const heightCSS = canvas.clientHeight || 120;

              // Additive: Compute average x12 and m12
              let sumX12 = 0, sumM12 = 0;
              particles.forEach(p => {
                sumX12 += p.x12 || 0;
                sumM12 += p.m12 || 0;
              });
              const avgX12 = sumX12 / particles.length;
              const avgM12 = sumM12 / particles.length;

              // Additive: Push to buffers
              adaptiveStateTraces.x12Buffer.push(avgX12);
              adaptiveStateTraces.m12Buffer.push(avgM12);

              // Additive: Trim buffers to canvas width
              while (adaptiveStateTraces.x12Buffer.length > widthCSS) {
                adaptiveStateTraces.x12Buffer.shift();
              }
              while (adaptiveStateTraces.m12Buffer.length > widthCSS) {
                adaptiveStateTraces.m12Buffer.shift();
              }

              // Additive: Clear canvas
              ctx.clearRect(0, 0, widthCSS, heightCSS);

              // Additive: Draw zero line
              ctx.strokeStyle = '#444';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(0, heightCSS / 2);
              ctx.lineTo(widthCSS, heightCSS / 2);
              ctx.stroke();

              // Additive: Draw x12 trace (cyan)
              if (adaptiveStateTraces.x12Buffer.length > 1) {
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                adaptiveStateTraces.x12Buffer.forEach((val, i) => {
                  const x = i;
                  const y = heightCSS / 2 - val * (heightCSS / 2 - 10);
                  if (i === 0) ctx.moveTo(x, y);
                  else ctx.lineTo(x, y);
                });
                ctx.stroke();
              }

              // Additive: Draw m12 trace (orange)
              if (adaptiveStateTraces.m12Buffer.length > 1) {
                ctx.strokeStyle = '#ff9500';
                ctx.lineWidth = 2;
                ctx.beginPath();
                adaptiveStateTraces.m12Buffer.forEach((val, i) => {
                  const x = i;
                  const y = heightCSS / 2 - val * (heightCSS / 2 - 10);
                  if (i === 0) ctx.moveTo(x, y);
                  else ctx.lineTo(x, y);
                });
                ctx.stroke();
              }

              // Additive: Draw legend
              ctx.font = '11px monospace';
              ctx.fillStyle = '#00d4ff';
              ctx.fillText('x‚ÇÅ‚ÇÇ', 5, 15);
              ctx.fillStyle = '#ff9500';
              ctx.fillText('m‚ÇÅ‚ÇÇ', 35, 15);

            } catch (e) {
              console.warn('[CST Theory] drawAdaptiveStateTrace error', e);
            }
          }

          // Additive: Wire adaptive state trace to updateLorenzParticles
          if (typeof window.updateLorenzParticles === 'function' && !window.updateLorenzParticles.__cstAdaptiveTracePatched) {
            const orig_updateLorenzParticles = window.updateLorenzParticles;
            window.updateLorenzParticles = function(...args) {
              const result = orig_updateLorenzParticles.apply(this, args);
              __cst_drawAdaptiveStateTrace();
              return result;
            };
            window.updateLorenzParticles.__cstAdaptiveTracePatched = true;
            console.log('[CST Theory] Patched updateLorenzParticles for adaptive state trace');
          }

          // ========================================================================
          // 2. CONSERVATION DIAGNOSTICS
          // Implements: Section 2.15 - Comprehensive Runtime Diagnostics
          // Tracks energy, momentum, angular momentum, and virial ratio
          // ========================================================================

          // Additive: Conservation state tracking
          const conservationState = {
            initialEnergy: null,
            initialMomentum: null,
            initialAngularMomentum: null,
            lastUpdate: 0
          };

          // Additive: Compute conservation diagnostics
          function __cst_computeConservationDiagnostics() {
            try {
              if (typeof particles === 'undefined' || particles.length === 0) {
                return {
                  energy: 0,
                  energyError: 0,
                  momentum: { x: 0, y: 0, z: 0 },
                  momentumMag: 0,
                  angularMomentum: { x: 0, y: 0, z: 0 },
                  angularMomentumMag: 0,
                  virialRatio: 0
                };
              }

              let totalKE = 0, totalPE = 0;
              let px = 0, py = 0, pz = 0;
              let lx = 0, ly = 0, lz = 0;

              particles.forEach(p => {
                const m = p.mass || 1;
                const vx = p.vx || 0;
                const vy = p.vy || 0;
                const vz = p.vz || 0;
                const v2 = vx*vx + vy*vy + vz*vz;

                // Kinetic energy
                totalKE += 0.5 * m * v2;

                // Momentum
                px += m * vx;
                py += m * vy;
                pz += m * vz;

                // Angular momentum: L = r √ó p
                const rx = p.x || 0;
                const ry = p.y || 0;
                const rz = p.z || 0;
                lx += m * (ry * vz - rz * vy);
                ly += m * (rz * vx - rx * vz);
                lz += m * (rx * vy - ry * vx);

                // Potential energy (gravitational + dark matter)
                totalPE += (p.Ugrav || 0) + (p.Udm || 0);
              });

              const totalEnergy = totalKE + totalPE;
              const pMag = Math.sqrt(px*px + py*py + pz*pz);
              const lMag = Math.sqrt(lx*lx + ly*ly + lz*lz);

              // Initialize reference values
              if (conservationState.initialEnergy === null && totalKE > 0) {
                conservationState.initialEnergy = totalEnergy;
                conservationState.initialMomentum = pMag;
                conservationState.initialAngularMomentum = lMag;
              }

              // Compute energy error
              const energyError = conservationState.initialEnergy !== null && conservationState.initialEnergy !== 0
                ? Math.abs((totalEnergy - conservationState.initialEnergy) / conservationState.initialEnergy)
                : 0;

              // Virial ratio: 2T/|U|
              const virialRatio = Math.abs(totalPE) > 1e-10 ? (2 * totalKE / Math.abs(totalPE)) : 0;

              return {
                energy: totalEnergy,
                energyError: energyError,
                momentum: { x: px, y: py, z: pz },
                momentumMag: pMag,
                angularMomentum: { x: lx, y: ly, z: lz },
                angularMomentumMag: lMag,
                virialRatio: virialRatio
              };
            } catch (e) {
              console.warn('[CST Theory] Conservation diagnostics error', e);
              return { energy: 0, energyError: 0, momentumMag: 0, angularMomentumMag: 0, virialRatio: 0 };
            }
          }

          // Additive: Update conservation diagnostics display
          function __cst_updateConservationDisplay() {
            try {
              const diag = __cst_computeConservationDiagnostics();

              // Update energy error
              const energyEl = document.getElementById('energy-error');
              if (energyEl) {
                energyEl.textContent = (diag.energyError * 100).toFixed(3) + '%';
                energyEl.style.color = diag.energyError > 0.01 ? '#ff4444' : '#00ff00';
              }

              // Update momentum magnitude
              const momentumEl = document.getElementById('momentum-mag');
              if (momentumEl) {
                momentumEl.textContent = diag.momentumMag.toExponential(3);
              }

              // Update angular momentum magnitude
              const angMomEl = document.getElementById('angular-momentum-mag');
              if (angMomEl) {
                angMomEl.textContent = diag.angularMomentumMag.toExponential(3);
              }

              // Update virial ratio
              const virialEl = document.getElementById('virial-ratio');
              if (virialEl) {
                virialEl.textContent = diag.virialRatio.toFixed(3);
                virialEl.style.color = Math.abs(diag.virialRatio - 1) < 0.2 ? '#00ff00' : '#ffaa00';
              }

              conservationState.lastUpdate = Date.now();
            } catch (e) {
              console.warn('[CST Theory] Conservation display update error', e);
            }
          }

          // Additive: Call conservation diagnostics every 500ms
          setInterval(__cst_updateConservationDisplay, 500);

          // ========================================================================
          // 3. ENTROPY COUPLING TO PARTICLE REPLICATION
          // Implements: Section 2.14 - Emergent Properties
          // High entropy increases replication probability
          // ========================================================================

          // Additive: Entropy-influenced particle creation
          function __cst_getEntropyModulatedThreshold() {
            try {
              if (typeof entropyState === 'undefined') return 1.0;

              const baseThreshold = typeof replicationThreshold !== 'undefined' ? replicationThreshold : 1.0;
              const currentEntropy = entropyState.lastEntropy || 0;

              // Higher entropy -> lower threshold -> more particle creation
              // Map entropy [0, 10] to multiplier [1.0, 0.5]
              const entropyFactor = Math.max(0.5, 1.0 - currentEntropy * 0.05);

              return baseThreshold * entropyFactor;
            } catch (e) {
              console.warn('[CST Theory] Entropy modulation error', e);
              return 1.0;
            }
          }

          // Additive: Patch particle creation to use entropy-modulated threshold
          if (typeof window.addParticle === 'function' && !window.addParticle.__cstEntropyPatched) {
            const orig_addParticle = window.addParticle;
            window.addParticle = function(x, y, z, color, frequency, parent) {
              // Apply entropy-modulated threshold check
              const threshold = __cst_getEntropyModulatedThreshold();
              const shouldCreate = Math.random() < (1.0 / threshold);

              if (shouldCreate || typeof parent !== 'undefined') {
                return orig_addParticle(x, y, z, color, frequency, parent);
              }
              return null;
            };
            window.addParticle.__cstEntropyPatched = true;
            console.log('[CST Theory] Patched addParticle for entropy coupling');
          }

          // ========================================================================
          // 4. REPLAY VALIDATION DIAGNOSTICS
          // Implements: Section 2.13 - Deterministic Replay and Fidelity Checks
          // Validates replay quality with pass/fail indicators
          // ========================================================================

          // Additive: Replay validation state
          const replayValidation = {
            energyErrorThreshold: 0.01, // 1% max error
            momentumThreshold: 1e-6,
            angMomentumThreshold: 1e-6,
            virialErrorThreshold: 0.2
          };

          // Additive: Compute replay validation
          function __cst_validateReplay() {
            try {
              if (typeof determinism === 'undefined' || !determinism.isReplaying) {
                return {
                  energyPass: true,
                  momentumPass: true,
                  angMomentumPass: true,
                  virialPass: true,
                  overallPass: true
                };
              }

              const diag = __cst_computeConservationDiagnostics();

              const energyPass = diag.energyError < replayValidation.energyErrorThreshold;
              const momentumPass = diag.momentumMag < replayValidation.momentumThreshold;
              const angMomentumPass = diag.angularMomentumMag < replayValidation.angMomentumThreshold;
              const virialPass = Math.abs(diag.virialRatio - 1.0) < replayValidation.virialErrorThreshold;
              const overallPass = energyPass && momentumPass && angMomentumPass && virialPass;

              return {
                energyPass,
                momentumPass,
                angMomentumPass,
                virialPass,
                overallPass
              };
            } catch (e) {
              console.warn('[CST Theory] Replay validation error', e);
              return { overallPass: false };
            }
          }

          // Additive: Update replay validation display
          function __cst_updateReplayValidationDisplay() {
            try {
              const validation = __cst_validateReplay();

              const energyPassEl = document.getElementById('replay-energy-pass');
              if (energyPassEl) {
                energyPassEl.textContent = validation.energyPass ? '‚úì PASS' : '‚úó FAIL';
                energyPassEl.style.color = validation.energyPass ? '#00ff00' : '#ff4444';
              }

              const momentumPassEl = document.getElementById('replay-momentum-pass');
              if (momentumPassEl) {
                momentumPassEl.textContent = validation.momentumPass ? '‚úì PASS' : '‚úó FAIL';
                momentumPassEl.style.color = validation.momentumPass ? '#00ff00' : '#ff4444';
              }

              const angMomPassEl = document.getElementById('replay-angmom-pass');
              if (angMomPassEl) {
                angMomPassEl.textContent = validation.angMomentumPass ? '‚úì PASS' : '‚úó FAIL';
                angMomPassEl.style.color = validation.angMomentumPass ? '#00ff00' : '#ff4444';
              }

              const virialPassEl = document.getElementById('replay-virial-pass');
              if (virialPassEl) {
                virialPassEl.textContent = validation.virialPass ? '‚úì PASS' : '‚úó FAIL';
                virialPassEl.style.color = validation.virialPass ? '#00ff00' : '#ff4444';
              }

              const overallPassEl = document.getElementById('replay-overall-pass');
              if (overallPassEl) {
                overallPassEl.textContent = validation.overallPass ? '‚úì PASS' : '‚úó FAIL';
                overallPassEl.style.color = validation.overallPass ? '#00ff00' : '#ff4444';
              }
            } catch (e) {
              console.warn('[CST Theory] Replay validation display error', e);
            }
          }

          // Additive: Update replay validation every second
          setInterval(__cst_updateReplayValidationDisplay, 1000);

          // ========================================================================
          // 5. TOKEN RATE TRACKING
          // Implements: Section 2.11 - Continuous Token Stream
          // Displays tokens/sec metric in real time
          // ========================================================================

          // Additive: Token rate state
          const tokenRateState = {
            tokenCount: 0,
            lastResetTime: Date.now(),
            currentRate: 0
          };

          // Additive: Track token creation
          if (typeof tokenBuffer !== 'undefined' && !tokenBuffer.__cstRatePatched) {
            const originalPush = Array.prototype.push;

            // Override push on tokenBuffer.tokens
            Object.defineProperty(tokenBuffer, 'tokens', {
              get: function() { return this._tokens || []; },
              set: function(val) {
                this._tokens = val;
                // Wrap push to count tokens
                if (this._tokens && !this._tokens.__cstRatePatched) {
                  const tokensArray = this._tokens;
                  tokensArray.__cstRatePatched = true;
                  const wrappedPush = function(...items) {
                    tokenRateState.tokenCount += items.length;
                    return originalPush.apply(this, items);
                  };
                  tokensArray.push = wrappedPush.bind(tokensArray);
                }
              }
            });
            tokenBuffer.__cstRatePatched = true;
          }

          // Additive: Compute and update token rate
          function __cst_updateTokenRate() {
            try {
              const now = Date.now();
              const elapsed = (now - tokenRateState.lastResetTime) / 1000; // seconds

              if (elapsed > 0) {
                tokenRateState.currentRate = tokenRateState.tokenCount / elapsed;
              }

              // Update display
              const tokenRateEl = document.getElementById('token-rate');
              if (tokenRateEl) {
                tokenRateEl.textContent = tokenRateState.currentRate.toFixed(1) + ' tok/s';
              }

              // Reset counter every 5 seconds
              if (elapsed >= 5) {
                tokenRateState.tokenCount = 0;
                tokenRateState.lastResetTime = now;
              }
            } catch (e) {
              console.warn('[CST Theory] Token rate update error', e);
            }
          }

          // Additive: Update token rate every 500ms
          setInterval(__cst_updateTokenRate, 500);

          // ========================================================================
          // 6. JSON EXPORT FUNCTIONS
          // Implements: Section 2.16 - Test Cases and Validation
          // Export token stream and system state as JSON
          // ========================================================================

          // Additive: Export tokens (compact format)
          window.__cst_exportTokensCompact = function() {
            try {
              if (typeof tokenBuffer === 'undefined' || !tokenBuffer.tokens) {
                console.warn('No tokens available');
                return null;
              }

              const compact = tokenBuffer.tokens.map(t => ({
                type: t.type,
                ts: t.timestamp,
                freq: t.frequency,
                mag: t.magnitude,
                x12: t.x12,
                psi: t.psi
              }));

              const json = JSON.stringify(compact, null, 2);
              console.log('[CST Theory] Compact token export (' + compact.length + ' tokens)');
              return json;
            } catch (e) {
              console.warn('[CST Theory] Token export error', e);
              return null;
            }
          };

          // Additive: Export tokens (full format)
          window.__cst_exportTokensFull = function() {
            try {
              if (typeof tokenBuffer === 'undefined' || !tokenBuffer.tokens) {
                console.warn('No tokens available');
                return null;
              }

              const json = JSON.stringify(tokenBuffer.tokens, null, 2);
              console.log('[CST Theory] Full token export (' + tokenBuffer.tokens.length + ' tokens)');
              return json;
            } catch (e) {
              console.warn('[CST Theory] Token export error', e);
              return null;
            }
          };

          // Additive: Export system state snapshot
          window.__cst_exportSystemState = function() {
            try {
              const state = {
                timestamp: Date.now(),
                particles: particles.map(p => ({
                  id: p.id,
                  pos: { x: p.x, y: p.y, z: p.z },
                  vel: { x: p.vx, y: p.vy, z: p.vz },
                  x12: p.x12,
                  m12: p.m12,
                  Ec: p.Ec,
                  omega: p.omega,
                  vi: p.vi,
                  theta: p.theta
                })),
                physics: physics,
                adaptiveState: adaptiveState,
                sync: sync,
                entropy: entropyState.lastEntropy,
                conservation: __cst_computeConservationDiagnostics()
              };

              const json = JSON.stringify(state, null, 2);
              console.log('[CST Theory] System state exported (' + particles.length + ' particles)');
              return json;
            } catch (e) {
              console.warn('[CST Theory] System state export error', e);
              return null;
            }
          };

          // Additive: Download JSON helper
          window.__cst_downloadJSON = function(data, filename) {
            try {
              const blob = new Blob([data], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = filename || 'cst-export.json';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
              console.log('[CST Theory] Downloaded', filename);
            } catch (e) {
              console.warn('[CST Theory] Download error', e);
            }
          };

          // ========================================================================
          // 7. RUNTIME VALIDATION HELPERS
          // Implements: Section 2.15 - Comprehensive Runtime Diagnostics
          // Provides debugging and validation utilities
          // ========================================================================

          // Additive: Validate particle state consistency
          window.__cst_validateParticleStates = function() {
            try {
              if (typeof particles === 'undefined' || particles.length === 0) {
                console.log('[CST Validate] No particles');
                return true;
              }

              let errors = [];
              particles.forEach((p, i) => {
                if (!isFinite(p.x) || !isFinite(p.y) || !isFinite(p.z)) {
                  errors.push('Particle ' + i + ' has invalid position');
                }
                if (!isFinite(p.vx) || !isFinite(p.vy) || !isFinite(p.vz)) {
                  errors.push('Particle ' + i + ' has invalid velocity');
                }
                if (!isFinite(p.x12) || Math.abs(p.x12) > 10) {
                  errors.push('Particle ' + i + ' has invalid x12=' + p.x12);
                }
                if (!isFinite(p.Ec) || p.Ec < 0) {
                  errors.push('Particle ' + i + ' has invalid Ec=' + p.Ec);
                }
              });

              if (errors.length > 0) {
                console.warn('[CST Validate] Found', errors.length, 'errors:');
                errors.forEach(e => console.warn('  -', e));
                return false;
              }

              console.log('[CST Validate] All', particles.length, 'particles valid');
              return true;
            } catch (e) {
              console.warn('[CST Validate] Validation error', e);
              return false;
            }
          };

          // Additive: Dump comprehensive diagnostics
          window.__cst_dumpDiagnostics = function() {
            try {
              console.log('=== CST 12D COSMIC SYNAPSE DIAGNOSTICS ===');
              console.log('Particles:', particles.length);
              console.log('Conservation:', __cst_computeConservationDiagnostics());
              console.log('Replay Validation:', __cst_validateReplay());
              console.log('Token Rate:', tokenRateState.currentRate.toFixed(2), 'tok/s');
              console.log('Entropy:', entropyState.lastEntropy);
              console.log('Adaptive State Traces:', {
                x12BufferLen: adaptiveStateTraces.x12Buffer.length,
                m12BufferLen: adaptiveStateTraces.m12Buffer.length
              });
              console.log('Particle States Valid:', __cst_validateParticleStates());
              console.log('==========================================');
            } catch (e) {
              console.warn('[CST Theory] Diagnostics dump error', e);
            }
          };

          // Additive: Theory feature verification
          console.log('[CST Theory] ‚úì Adaptive State Trace visualization enabled');
          console.log('[CST Theory] ‚úì Conservation diagnostics tracking enabled');
          console.log('[CST Theory] ‚úì Entropy coupling to particle replication enabled');
          console.log('[CST Theory] ‚úì Replay validation diagnostics enabled');
          console.log('[CST Theory] ‚úì Token rate tracking enabled');
          console.log('[CST Theory] ‚úì JSON export functions available');
          console.log('[CST Theory] ‚úì Runtime validation helpers available');
          console.log('[CST Theory] Comprehensive feature patch applied successfully');
          console.log('[CST Theory] Debug: Run window.__cst_dumpDiagnostics() for full system report');

        })();

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            // Added: Check if Three.js is loaded before initializing scene
            if (typeof THREE === 'undefined') {
                console.error('[CST Runtime] ‚ùå THREE is not defined - waiting for library to load');
                // Retry initialization after a delay
                setTimeout(() => {
                    if (typeof THREE !== 'undefined') {
                        console.log('[CST Runtime] ‚úÖ THREE loaded after delay, initializing...');
                        initThree();
                        animate(); // Start animation loop
                    } else {
                        console.error('[CST Runtime] ‚ùå THREE still not available - 3D visualization disabled');
                        updateStatus('‚ö†Ô∏è System ready (3D visualization unavailable) - Click START MICROPHONE');
                    }
                }, 1000);
            } else {
                initThree();
                animate(); // Start animation loop
            }

            initFrequencyCanvas();
            initEntropyCanvas(); // CST v2.0+ additive: Initialize entropy canvas
            initAdaptiveStateCanvas(); // NEW: Initialize adaptive state canvas
            initDmProfileCanvas(); // NEW: Initialize dark matter profile canvas

            // NEW: Initialize enhanced analysis systems
            initializeLearnedProjector(); // Neural network for projection
            initializeAudioSynthesis(); // Phi-harmonic synthesizer
            console.log('[CST Runtime] ‚úÖ Enhanced analysis systems initialized (Neural Network, Audio Synthesis)');

            // Validate all canvas contexts are available (after initialization)
            console.log('[CST Runtime] Validating canvas contexts after initialization...');
            const canvasContexts = {
                'adaptiveStateCtx': adaptiveStateCtx,
                'entropyState.traceCtx': entropyState.traceCtx,
                'dmProfileCtx': dmProfileCtx
            };

            for (const [name, ctx] of Object.entries(canvasContexts)) {
                if (ctx) {
                    console.log(`[CST Runtime] ‚úÖ ${name} canvas context ready`);
                } else {
                    console.warn(`[CST Runtime] ‚ö†Ô∏è  ${name} canvas context not available`);
                }
            }

            initializeUIDisplays(); // CST v2.0: Set all initial display values
            drawNfwProfile(dmParams.rho0, dmParams.rs); // NEW: Draw initial NFW profile
            updatePsi(0);

            // === PERPETUAL OPERATION SYSTEM INITIALIZATION ===
            console.log('[PERPETUAL] Initializing infinite operation systems...');
            startPerpetualTokenGeneration();
            autoRegenerateParticles(); // Ensure we always have particles
            console.log('[PERPETUAL] Systems online - infinite operation enabled');
            console.log('[PERPETUAL] Configuration:', PERPETUAL_CONFIG);

            updateStatus('üé§ System ready - Click START MICROPHONE for continuous audio‚Üítoken generation pipeline');

            // ============================================================================
            // KEYBOARD SHORTCUTS
            // ============================================================================
            document.addEventListener('keydown', (e) => {
                // Ignore if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch(e.key.toLowerCase()) {
                    case 'm':
                        e.preventDefault();
                        toggleMicrophone();
                        break;
                    case 'r':
                        e.preventDefault();
                        resetSystem();
                        break;
                    case 'p':
                    case ' ':
                        e.preventDefault();
                        togglePause();
                        break;
                    case 'a':
                        e.preventDefault();
                        addParticle();
                        break;
                    case 'c':
                        e.preventDefault();
                        changeColor();
                        break;
                    case 'e':
                        e.preventDefault();
                        exportTokens();
                        break;
                    case 'd':
                        e.preventDefault();
                        if (window.runCST_Diagnostics) {
                            window.runCST_Diagnostics();
                        }
                        break;
                    case 'h':
                    case '?':
                        e.preventDefault();
                        alert('Keyboard Shortcuts:\n\nM - Toggle Microphone\nR - Reset System\nP/Space - Pause/Play\nA - Add Particle\nC - Change Color\nE - Export Tokens\nD - Run Diagnostics\nH/? - Show this help');
                        break;
                }
            });

            console.log('[CST Keyboard] ‚úÖ Keyboard shortcuts enabled (press H for help)');
        });

        // ==================================================================================
        // ADDITIVE PATCH: INFINITE TOKEN GENERATION (removes all hard caps)
        // Implements: Section 3.1 - Token Generation (continuous and infinite)
        // Reference: 12D Cosmic Synapse Theory Paper
        // ==================================================================================

        (function infiniteTokenCapRemoval() {
            console.log('[CST Infinite Token Patch] Removing all token caps for unlimited generation');

            // Override flushTokenBuffer to remove MAX_PENDING and MAX_TOTAL_TOKENS caps
            if (typeof flushTokenBuffer === 'function' && !flushTokenBuffer.__cstInfinite) {
                const orig_flushTokenBuffer = flushTokenBuffer;

                window.flushTokenBuffer = function __cst_flushTokenBuffer_infinite() {
                    try {
                        if (!tokenBuffer || !Array.isArray(tokenBuffer.tokens) || tokenBuffer.tokens.length === 0) return;

                        // ‚úÖ REMOVED: MAX_PENDING cap - buffer processes ALL pending tokens
                        // ‚úÖ REMOVED: MAX_TOTAL_TOKENS cap - tokens array grows indefinitely

                        // Append ALL buffered tokens to main store without any caps
                        for (let i = 0; i < tokenBuffer.tokens.length; i++) {
                            tokens.push(tokenBuffer.tokens[i]);
                            tokenCount++;
                        }

                        // UI updates (display bounded by audioConfig.tokenDisplayLimit only for performance)
                        if (typeof updateTokenDisplay === 'function') {
                            try {
                                updateTokenDisplay();
                            } catch (e) {
                                console.error('[CST] updateTokenDisplay error', e);
                            }
                        }

                        // Update UI counters to show true unlimited count
                        const countEl = document.getElementById('token-count');
                        const countStatusEl = document.getElementById('token-count-status');
                        const replEl = document.getElementById('replication-count');

                        if (countEl) countEl.textContent = tokens.length;
                        if (countStatusEl) countStatusEl.textContent = tokens.length;
                        if (replEl) replEl.textContent = replicationCount;

                    } catch (e) {
                        console.error('[CST] flushTokenBuffer infinite-cap error', e);
                    } finally {
                        // Always clear buffer to avoid reprocessing stale entries
                        if (tokenBuffer) tokenBuffer.tokens = [];
                    }
                };

                window.flushTokenBuffer.__cstInfinite = true;
                console.log('[CST Infinite Token Patch] ‚úÖ Token caps removed - infinite generation enabled');
            }
        })();

        // ==================================================================================
        // ADDITIVE PATCH: OPTIONAL INDEXEDDB PERSISTENCE FOR INFINITE RUNS
        // Implements: Section 3.1 - Token Storage (disk-backed for multi-hour sessions)
        // Reference: 12D Cosmic Synapse Theory Paper
        // ==================================================================================

        (function optionalIndexedDBPersistence() {
            // Token database for optional persistent storage
            window.tokenDB = {
                db: null,
                enabled: false, // Set to true to enable persistent storage
                batchSize: 100,
                pendingBatch: []
            };

            function initTokenDB() {
                const req = indexedDB.open('CST_Tokens_v2', 1);

                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('tokens')) {
                        const store = db.createObjectStore('tokens', { keyPath: 'id' });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log('[CST DB] Created tokens object store');
                    }
                };

                req.onsuccess = (e) => {
                    tokenDB.db = e.target.result;
                    console.log('[CST DB] IndexedDB initialized and ready');
                };

                req.onerror = (e) => {
                    console.warn('[CST DB] IndexedDB init error', e);
                };
            }

            function persistTokensToDB(batch) {
                if (!tokenDB.enabled || !tokenDB.db || !Array.isArray(batch) || batch.length === 0) return;

                try {
                    const tx = tokenDB.db.transaction('tokens', 'readwrite');
                    const store = tx.objectStore('tokens');

                    for (let i = 0; i < batch.length; i++) {
                        store.put(batch[i]);
                    }

                    tx.oncomplete = () => {
                        console.log(`[CST DB] Persisted ${batch.length} tokens to IndexedDB`);
                    };

                    tx.onerror = (e) => {
                        console.warn('[CST DB] Token write error', e);
                    };
                } catch (e) {
                    console.warn('[CST DB] Persist error', e);
                }
            }

            // Hook persistence into flush (additive enhancement)
            if (typeof window.flushTokenBuffer === 'function' && !window.flushTokenBuffer.__cstDBPersist) {
                const orig = window.flushTokenBuffer;

                window.flushTokenBuffer = function __cst_flushTokenBuffer_db() {
                    // Capture pending tokens before flush
                    const pending = tokenBuffer && tokenBuffer.tokens ? tokenBuffer.tokens.slice() : [];

                    // Persist before we clear buffer (if enabled)
                    if (tokenDB.enabled && pending.length > 0) {
                        tokenDB.pendingBatch.push(...pending);

                        // Batch writes for efficiency (write every 100 tokens)
                        if (tokenDB.pendingBatch.length >= tokenDB.batchSize) {
                            const batch = tokenDB.pendingBatch.splice(0, tokenDB.batchSize);
                            persistTokensToDB(batch);
                        }
                    }

                    // Continue original infinite-cap flush behavior
                    return orig.call(this);
                };

                window.flushTokenBuffer.__cstDBPersist = true;
                console.log('[CST DB] ‚úÖ IndexedDB persistence hook installed');
            }

            // Initialize IndexedDB (database ready but disabled by default)
            initTokenDB();

            // Expose control function for enabling/disabling persistence
            window.enableTokenPersistence = function(enable) {
                tokenDB.enabled = !!enable;
                console.log(`[CST DB] Token persistence ${tokenDB.enabled ? 'ENABLED' : 'DISABLED'}`);
            };

            console.log('[CST DB] Persistence available - call enableTokenPersistence(true) to activate');
        })();

        // ==================================================================================
        // VALIDATION PATCH: Ensure all canvases and metrics update correctly
        // Implements: Runtime fidelity checks for all visualizations
        // ==================================================================================

        (function validateRuntimeFidelity() {
            console.log('[CST Validation] Checking runtime fidelity for all panels...');

            const requiredElements = {
                // Token display
                'token-count': 'Token Count',
                'token-count-status': 'Token Count Status',
                'replication-count': 'Replication Count',

                // œà Breakdown (Section 2.5)
                'psi-energy-term': 'œà Energy Term (œÜE/c¬≤)',
                'psi-lambda-term': 'œà Lambda Term (Œª)',
                'psi-velint-term': 'œà Velocity Integral (‚à´||v||dt)',
                'psi-x12int-term': 'œà X12 Integral (‚à´|Œîx12|dt)',
                'psi-omega-term': 'œà Omega Term (Œ©)',
                'psi-potential-term': 'œà Potential Term (U‚ÇÅ‚ÇÅD)',
                'psi-total-normalized': 'œà Total Normalized',

                // Synchronization (Section 2.8)
                'sync-order-r': 'Kuramoto Order Parameter r',
                'sync-mean-theta': 'Mean Phase Œ∏',
                'sync-std-theta': 'Phase Std Dev',

                // Entropy (Section 2.12)
                'entropy-global': 'Global Entropy S',
                'entropy-bins': 'Entropy Bins',
                'entropy-temperature': 'Temperature Proxy',

                // Conservation (Section 2.13)
                'energy-drift': 'Energy Drift',
                'momentum-magnitude': 'Momentum Magnitude',
                'angular-momentum-magnitude': 'Angular Momentum Magnitude',
                'virial-ratio': 'Virial Ratio'
            };

            const requiredCanvases = {
                'adaptiveStateCanvas': 'Adaptive State Strip Chart (Section 2.9-2.10)',
                'entropyTraceCanvas': 'Entropy Heart-Rate Trace (Section 2.12)',
                'dmProfileCanvas': 'NFW Density Profile (Section 2.7)',
                'frequencyCanvas': 'Audio Frequency Spectrum'
            };

            let allValid = true;

            // Validate display elements
            for (const [id, name] of Object.entries(requiredElements)) {
                const el = document.getElementById(id);
                if (!el) {
                    console.warn(`[CST Validation] ‚ö†Ô∏è  Missing element: ${name} (${id})`);
                    allValid = false;
                } else {
                    console.log(`[CST Validation] ‚úÖ ${name}`);
                }
            }

            // Validate canvases
            for (const [id, name] of Object.entries(requiredCanvases)) {
                const canvas = document.getElementById(id);
                if (!canvas) {
                    console.warn(`[CST Validation] ‚ö†Ô∏è  Missing canvas: ${name} (${id})`);
                    allValid = false;
                } else {
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        console.log(`[CST Validation] ‚úÖ ${name} (rendering context ready)`);
                    } else {
                        console.warn(`[CST Validation] ‚ö†Ô∏è  Canvas context unavailable: ${name}`);
                    }
                }
            }

            if (allValid) {
                console.log('[CST Validation] ‚úÖ All required UI elements present and ready');
            } else {
                console.warn('[CST Validation] ‚ö†Ô∏è  Some UI elements missing - check console warnings');
            }

            // Validate update functions exist
            const requiredFunctions = [
                'updatePsiBreakdown',
                'updateSynchronizationMetrics',
                'updateEntropy',
                'updateConservationDiagnostics',
                'updateAdaptiveStateTrace',
                'drawEntropyTrace',
                'drawNfwProfile'
            ];

            for (const funcName of requiredFunctions) {
                if (typeof window[funcName] === 'function') {
                    console.log(`[CST Validation] ‚úÖ Function ready: ${funcName}`);
                } else {
                    console.warn(`[CST Validation] ‚ö†Ô∏è  Missing function: ${funcName}`);
                }
            }
        })();

        // ==================================================================================
        // ADDITIVE ENHANCEMENT: Display both x12 AND m12 in adaptive state canvas
        // Implements: Section 2.9-2.10 - Internal State Evolution & Memory Update
        // Reference: Paper spec requires "live strip chart showing x12 and m12 values"
        // ==================================================================================

        (function enhanceAdaptiveStateVisualization() {
            console.log('[CST Adaptive State] Enhancing visualization to show both x12 and m12');

            // Add m12 history tracking alongside x12
            if (typeof window.m12History === 'undefined') {
                window.m12History = [];
            }

            // Enhanced updateAdaptiveStateTrace to show both x12 (solid) and m12 (dashed)
            if (typeof updateAdaptiveStateTrace === 'function' && !updateAdaptiveStateTrace.__cstEnhanced) {
                const orig_updateAdaptiveStateTrace = updateAdaptiveStateTrace;

                window.updateAdaptiveStateTrace = function __cst_updateAdaptiveStateTrace_enhanced() {
                    if (!adaptiveStateCtx || !Array.isArray(particles)) return;

                    const ctx = adaptiveStateCtx;
                    const c = ctx.canvas;
                    const width = c.width || 400;
                    const height = c.height || 120;

                    // Extend histories to number of particles
                    while (x12History.length < particles.length) x12History.push([]);
                    while (m12History.length < particles.length) m12History.push([]);

                    // Trim if particles removed
                    if (x12History.length > particles.length) x12History.length = particles.length;
                    if (m12History.length > particles.length) m12History.length = particles.length;

                    // Append current x12 and m12 to each particle's history
                    particles.forEach((p, i) => {
                        const x12Val = (typeof p.x12 === 'number' && isFinite(p.x12)) ? p.x12 : 0;
                        const m12Val = (typeof p.m12 === 'number' && isFinite(p.m12)) ? p.m12 : 0;

                        x12History[i].push(x12Val);
                        m12History[i].push(m12Val);

                        while (x12History[i].length > width) x12History[i].shift();
                        while (m12History[i].length > width) m12History[i].shift();
                    });

                    // Draw background
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
                    ctx.fillRect(0, 0, width, height);

                    // Draw baseline at y=0 centered
                    const baseline = height / 2;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, baseline);
                    ctx.lineTo(width, baseline);
                    ctx.stroke();

                    // Draw grid lines at ¬±0.5
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx.beginPath();
                    ctx.moveTo(0, baseline - (height * 0.45 * 0.5));
                    ctx.lineTo(width, baseline - (height * 0.45 * 0.5));
                    ctx.moveTo(0, baseline + (height * 0.45 * 0.5));
                    ctx.lineTo(width, baseline + (height * 0.45 * 0.5));
                    ctx.stroke();

                    // Draw each particle's traces: x12 (solid) and m12 (dashed)
                    particles.forEach((p, i) => {
                        const colorHex = '#' + p.color.toString(16).padStart(6, '0');

                        // Draw x12 trace (solid line, thicker)
                        ctx.strokeStyle = colorHex;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([]);
                        ctx.globalAlpha = 0.9;
                        ctx.beginPath();
                        let first = true;
                        const x12Hist = x12History[i];
                        for (let x = 0; x < x12Hist.length; x++) {
                            // x12 in [-1,1] mapped to vertical extent
                            const y = baseline - (x12Hist[x] * (height * 0.45));
                            const clampedY = Math.max(0, Math.min(height, y));
                            if (first) {
                                ctx.moveTo(x, clampedY);
                                first = false;
                            } else {
                                ctx.lineTo(x, clampedY);
                            }
                        }
                        ctx.stroke();

                        // Draw m12 trace (dashed line, thinner, slightly transparent)
                        ctx.strokeStyle = colorHex;
                        ctx.lineWidth = 1.5;
                        ctx.setLineDash([4, 4]);
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        first = true;
                        const m12Hist = m12History[i];
                        for (let x = 0; x < m12Hist.length; x++) {
                            // m12 in [-1,1] mapped to vertical extent
                            const y = baseline - (m12Hist[x] * (height * 0.45));
                            const clampedY = Math.max(0, Math.min(height, y));
                            if (first) {
                                ctx.moveTo(x, clampedY);
                                first = false;
                            } else {
                                ctx.lineTo(x, clampedY);
                            }
                        }
                        ctx.stroke();

                        // Reset line dash and alpha
                        ctx.setLineDash([]);
                        ctx.globalAlpha = 1.0;
                    });

                    // Draw legend in top-left corner
                    ctx.font = '10px monospace';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillText('x‚ÇÅ‚ÇÇ (solid)', 5, 12);
                    ctx.fillText('m‚ÇÅ‚ÇÇ (dash)', 5, 24);
                };

                window.updateAdaptiveStateTrace.__cstEnhanced = true;
                console.log('[CST Adaptive State] ‚úÖ Enhanced to display both x12 (solid) and m12 (dashed)');
            }
        })();

        // ==================================================================================
        // RUNTIME VALIDATION & ERROR HANDLING ENHANCEMENT
        // Ensures all functions work correctly and provides debugging information
        // ==================================================================================

        (function runtimeValidationAndEnhancement() {
            console.log('[CST Runtime] Starting comprehensive runtime validation...');

            // Validate all UI button functions are callable
            const uiFunctions = {
                'toggleMicrophone': toggleMicrophone,
                'resetSystem': resetSystem,
                'togglePause': togglePause,
                'changeColor': changeColor,
                'addParticle': addParticle,
                'setDeterministicSeed': setDeterministicSeed,
                'toggleRecording': toggleRecording,
                'toggleReplay': toggleReplay,
                'exportTokens': exportTokens,
                'clearTokens': clearTokens
            };

            let allFunctionsValid = true;
            for (const [name, func] of Object.entries(uiFunctions)) {
                if (typeof func === 'function') {
                    console.log(`[CST Runtime] ‚úÖ ${name}() is callable`);
                } else {
                    console.error(`[CST Runtime] ‚ùå ${name}() is NOT a function!`);
                    allFunctionsValid = false;
                }
            }

            // Validate update functions exist and are callable
            const updateFunctions = {
                'updateAdaptiveStates': updateAdaptiveStates,
                'updateEntropy': updateEntropy,
                'updatePsiBreakdown': updatePsiBreakdown,
                'updateSynchronizationMetrics': updateSynchronizationMetrics,
                'updateAdaptiveStateTrace': updateAdaptiveStateTrace,
                'drawEntropyTrace': drawEntropyTrace,
                'drawNfwProfile': drawNfwProfile,
                'computeDarkMatterPotential': computeDarkMatterPotential,
                'updatePhases': updatePhases,
                'computeSynapticStrength': computeSynapticStrength
            };

            for (const [name, func] of Object.entries(updateFunctions)) {
                if (typeof func === 'function') {
                    console.log(`[CST Runtime] ‚úÖ ${name}() exists`);
                } else {
                    console.error(`[CST Runtime] ‚ùå ${name}() does NOT exist!`);
                    allFunctionsValid = false;
                }
            }

            // Add global error handler for better debugging
            window.addEventListener('error', (event) => {
                console.error('[CST Runtime Error]', {
                    message: event.message,
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    error: event.error
                });
            });

            // Add unhandled promise rejection handler
            window.addEventListener('unhandledrejection', (event) => {
                console.error('[CST Unhandled Promise Rejection]', {
                    reason: event.reason,
                    promise: event.promise
                });
            });

            // Enhanced logging wrapper for critical functions
            function wrapWithLogging(funcName, originalFunc) {
                return function(...args) {
                    console.log(`[CST Call] ${funcName}() called with`, args.length, 'arguments');
                    try {
                        const result = originalFunc.apply(this, args);
                        console.log(`[CST Call] ${funcName}() completed successfully`);
                        return result;
                    } catch (error) {
                        console.error(`[CST Call] ${funcName}() FAILED:`, error);
                        throw error;
                    }
                };
            }

            // Wrap UI functions with logging (optional, can be enabled for debugging)
            if (window.location.search.includes('debug=true')) {
                console.log('[CST Runtime] Debug mode enabled - wrapping functions with logging');
                window.toggleMicrophone = wrapWithLogging('toggleMicrophone', toggleMicrophone);
                window.resetSystem = wrapWithLogging('resetSystem', resetSystem);
                window.togglePause = wrapWithLogging('togglePause', togglePause);
                window.toggleRecording = wrapWithLogging('toggleRecording', toggleRecording);
                window.toggleReplay = wrapWithLogging('toggleReplay', toggleReplay);
            }

            // Validate critical global objects
            const criticalObjects = [
                { name: 'particles', obj: particles, expectedType: 'object' },
                { name: 'tokens', obj: tokens, expectedType: 'object' },
                { name: 'physics', obj: physics, expectedType: 'object' },
                { name: 'determinism', obj: determinism, expectedType: 'object' },
                { name: 'audioConfig', obj: audioConfig, expectedType: 'object' },
                { name: 'entropyState', obj: entropyState, expectedType: 'object' },
                { name: 'psiAccumulators', obj: psiAccumulators, expectedType: 'object' }
            ];

            for (const { name, obj, expectedType } of criticalObjects) {
                if (typeof obj === expectedType) {
                    console.log(`[CST Runtime] ‚úÖ ${name} initialized correctly`);
                } else {
                    console.error(`[CST Runtime] ‚ùå ${name} is ${typeof obj}, expected ${expectedType}`);
                    allFunctionsValid = false;
                }
            }

            // Validate Three.js scene is set up (deferred to allow initialization)
            // Note: Three.js initialization happens in DOMContentLoaded, which may not be
            // complete when this validation runs. We defer the check slightly.
            setTimeout(() => {
                if (scene && camera && renderer) {
                    console.log('[CST Runtime] ‚úÖ Three.js scene initialized (deferred check)');
                } else {
                    console.error('[CST Runtime] ‚ùå Three.js scene not properly initialized (deferred check)');
                }
            }, 100); // 100ms delay to allow Three.js initialization

            // Note: Canvas context validation moved to DOMContentLoaded event
            // (after canvas initialization completes) to avoid false warnings

            // Final validation summary
            if (allFunctionsValid) {
                console.log('[CST Runtime] ‚úÖ All critical functions validated successfully');
            } else {
                console.error('[CST Runtime] ‚ùå Some validation checks failed - see errors above');
            }

            // Export diagnostic function to window
            window.runCST_Diagnostics = function() {
                console.group('üîç CST System Diagnostics');
                console.log('Particles:', particles.length);
                console.log('Tokens:', tokens.length);
                console.log('Token Rate:', tokenGenerationRate, 'tokens/sec');
                console.log('Audio Active:', isAudioActive);
                console.log('Paused:', isPaused);
                console.log('Determinism Mode:', determinism.mode);
                console.log('Recording Frames:', determinism.recordedAudioFrames.length);
                console.log('Conservation E0:', conservationStats.E0);
                console.log('Entropy:', entropyState.lastEntropy);
                console.log('Adaptive State Histories:', x12History.length, m12History.length);

                // Canvas context validation
                console.log('Canvas Contexts:');
                console.log('  adaptiveStateCtx:', adaptiveStateCtx ? '‚úÖ Ready' : '‚ùå Not available');
                console.log('  entropyState.traceCtx:', entropyState.traceCtx ? '‚úÖ Ready' : '‚ùå Not available');
                console.log('  dmProfileCtx:', dmProfileCtx ? '‚úÖ Ready' : '‚ùå Not available');

                console.groupEnd();
                return {
                    particles: particles.length,
                    tokens: tokens.length,
                    tokenRate: tokenGenerationRate,
                    audioActive: isAudioActive,
                    paused: isPaused,
                    mode: determinism.mode,
                    recordingFrames: determinism.recordedAudioFrames.length,
                    entropy: entropyState.lastEntropy,
                    conservationE0: conservationStats.E0,
                    canvasContexts: {
                        adaptiveStateCtx: !!adaptiveStateCtx,
                        entropyTraceCtx: !!entropyState.traceCtx,
                        dmProfileCtx: !!dmProfileCtx
                    }
                };
            };

            console.log('[CST Runtime] ‚úÖ Runtime validation complete');
            console.log('[CST Runtime] üí° Run runCST_Diagnostics() in console for system status');
        })();

        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üåå 12D COSMIC SYNAPSE THEORY - FULL SPEC IMPLEMENTATION v2.1 üåå');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('‚úÖ Infinite Token Generation (no caps)');
        console.log('‚úÖ Adaptive State Evolution (dx12/dt, dm12/dt)');
        console.log('‚úÖ Global Entropy with Heart-Rate Trace');
        console.log('‚úÖ œà Function Breakdown (6 terms)');
        console.log('‚úÖ Replay & Determinism');
        console.log('‚úÖ Dark Matter NFW Profile');
        console.log('‚úÖ Kuramoto Synchronization');
        console.log('‚úÖ Conservation Checks');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üìñ Reference: 12D_Cosmic_Synapse_Theory.pdf');
        console.log('üé§ Ready for audio input - tokens will generate infinitely');
        console.log('üíæ Optional: Call enableTokenPersistence(true) for disk storage');
        console.log('üí° Run runCST_Diagnostics() for system status');
        console.log('üêõ Add ?debug=true to URL for detailed function call logging');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    </script>

    <!-- ============================================================================ -->
    <!-- 12D CST ENHANCEMENTS v2.0 - PDF-TO-LIVE IMPLEMENTATION                       -->
    <!-- ============================================================================ -->
    <!-- This module provides comprehensive enhancements based on                      -->
    <!-- "The Cosmic Synapse Madsens theory.pdf" including:                            -->
    <!--   ‚Ä¢ Critical bug fixes (memory viz, color rendering, œà calculations)          -->
    <!--   ‚Ä¢ Emergence detection & hierarchical structure (PDF 4.6-4.7)                -->
    <!--   ‚Ä¢ Observational cosmology comparison (Planck/CMB data)                      -->
    <!--   ‚Ä¢ Adaptive audio-visual linkages with feedback                              -->
    <!--   ‚Ä¢ Particle genealogy tracking system                                        -->
    <!--   ‚Ä¢ Performance optimizations & export features                               -->
    <!-- ============================================================================ -->
    <script src="cst-enhancements-v2.js"></script>

</body>
</html>
