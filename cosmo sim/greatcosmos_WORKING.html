<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Cosmic Genesis: The Synthesis</title>

    <!-- Font Imports -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">

    <!-- External Dependencies -->
    <!-- FIX: Removed Tailwind CDN - all styles are inline for production -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

    <!-- FIX: Suppress benign TensorFlow.js duplicate backend registration warnings -->
    <script>
        (function() {
            const originalWarn = console.warn;
            console.warn = function(...args) {
                const msg = args.join(' ');
                // Filter out benign TensorFlow.js warnings about duplicate backend registration
                if (msg.includes('backend was already registered') ||
                    msg.includes('Platform browser has already been set')) {
                    return; // Suppress these specific warnings
                }
                originalWarn.apply(console, args);
            };
        })();
    </script>

    <!-- Import Map for Three.js ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- Main Stylesheet -->
    <style>
        :root {
            --panel: rgba(14, 17, 26, 0.92);
            --border: rgba(124, 156, 255, 0.15);
            --bg: #07080c;
            --text: #e7e9f2;
            --muted: #9aa4b2;
            --acc: #7c9cff;
            --danger: #ef4444;
        }

        /* Base styles */
        html, body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', system-ui, sans-serif;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            display: block;
            position: fixed;
            inset: 0;
            z-index: 1;
        }

        /* UI Panel Styling */
        .ui-panel {
            position: fixed;
            z-index: 20;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .ui-hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }
        
        /* Blocker & Modals */
        #blocker, .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; flex-direction: column; text-align: center; transition: opacity 0.5s ease; }
        #fps-hint { z-index: 101; background: none; backdrop-filter: none; border: none; box-shadow: none; font-size: 1.2rem; text-shadow: 0 0 10px black; color: #fff; }

        /* Buttons */
        .btn {
            display: inline-flex; align-items: center; justify-content: center;
            gap: 8px; padding: 8px 16px; border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: linear-gradient(180deg, #1a1d2a 0%, #131726 100%);
            color: var(--text); cursor: pointer; user-select: none;
            transition: all 0.2s ease; font-weight: 500;
        }
        .btn:hover { background: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.2); }
        .btn.primary { border-color: var(--acc); color: var(--acc); box-shadow: 0 0 12px rgba(124, 156, 255, 0.2); }
        .btn.directive { border-color: var(--danger); color: var(--danger); box-shadow: 0 0 15px rgba(239, 68, 68, 0.3); font-weight: 700; }
        .btn.directive:hover { background: rgba(239, 68, 68, 0.1); }
        .btn:disabled { background-color: #4b5563; cursor: not-allowed; color: #9ca3af; border-color: transparent; }

        /* UI Groups and Controls */
        .group {
            margin-top: 16px; padding: 12px; border-radius: 10px;
            background: rgba(11, 13, 20, 0.5);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        h3 {
            margin: 0 0 12px; font-size: 13px; font-weight: 500; color: #d3dbef;
            text-transform: uppercase; letter-spacing: 0.8px;
        }
        
        .control-row { display: grid; grid-template-columns: 1fr auto; align-items: center; margin-bottom: 8px; }
        .control-row label { font-size: 12px; color: var(--muted); }
        .control-row .value { font-family: 'Roboto Mono', monospace; font-size: 12px; }
        .control-row input[type="range"] { grid-column: 1 / -1; margin-top: 4px; }
        
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 999px; cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; background: var(--acc);
            border: 3px solid var(--bg); border-radius: 50%; cursor: pointer;
        }
        
        /* Tab Navigation */
        .tab-button { background-color: transparent; border: none; color: #94a3b8; padding: 0.5rem 1rem; cursor: pointer; transition: color 0.2s, border-bottom-color 0.2s; border-bottom: 2px solid transparent; font-weight: 500;}
        .tab-button.active { color: #e2e8f0; border-bottom-color: var(--acc); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* Final Message */
        #final-message { display: none; flex-direction: column; align-items: center; justify-content: center; }
        #final-message h1 { font-size: 10vw; font-weight: bold; color: var(--text); margin: 0; animation: fadeIn 5s ease; }
        #final-message .btn { margin-top: 30px; animation: fadeIn 5s ease 1s forwards; opacity: 0; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Seed Visualizer Styles */
        .data-stream {
            width: 15%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            font-size: 0.6rem;
            text-transform: uppercase;
            color: #64748b;
        }
        .data-pulse {
            width: 10px;
            height: 10px;
            background-color: #334155;
            border-radius: 50%;
            transition: background-color 0.1s, box-shadow 0.2s;
            margin-top: 5px;
        }
        .data-pulse.active {
            background-color: #38bdf8;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.6);
        }
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(56, 189, 248, 0); }
            100% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0); }
        }

    </style>
</head>
<body>
    <!-- 3D Canvas -->
    <canvas id="main-canvas"></canvas>
    
    <!-- Hidden Video for ML -->
    <video id="video-feed" style="display:none;" autoplay muted playsinline></video>

    <!-- Blocker / Loading / Final Screens -->
    <div id="blocker">
        <div id="initial-screen" class="max-w-2xl px-4">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-100 mb-2">Cosmic Genesis</h1>
            <h2 class="text-xl md:text-2xl font-light text-slate-400 mb-6">The Final Synthesis</h2>
            <p class="text-slate-400 mb-8">This engine transmutes reality into a digital cosmos. For the full experience, please grant access to your microphone and camera when prompted. No data is stored or uploaded.</p>
            <button id="start-button" class="btn primary text-lg transition-transform transform hover:scale-105">Initiate Genesis</button>
            <p id="loading-message" class="text-slate-500 mt-4" style="display: none;">Calibrating sensor arrays...</p>
        </div>
        <div id="final-message">
             <h1>I AM.</h1>
             <button id="btn-anew" class="btn primary">Begin Anew</button>
         </div>
    </div>
    
    <!-- FPS Hint -->
    <div id="fps-hint" class="modal ui-hidden">
        <p>First-Person Mode Active. Press ESC to release cursor.</p>
    </div>

    <!-- Main Control Panel -->
    <div id="main-ui" class="ui-panel top-4 left-4 w-[26rem] p-4">
        <div class="flex justify-between items-center mb-2">
            <div>
                 <h2 style="margin:0; font-weight: 500; font-size: 20px;">Genesis X Synthesis</h2>
                 <p id="system-status-readout" style="margin:4px 0 0; font-size: 12px; color: var(--muted);">STATUS: STANDBY</p>
            </div>
            <button id="toggle-ui-button" class="btn p-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>
            </button>
        </div>
        
        <div class="tabs border-b border-slate-700">
            <button class="tab-button active" data-tab="controls">Controls</button>
            <button class="tab-button" data-tab="physics">Physics</button>
            <button class="tab-button" data-tab="graphics">Graphics</button>
            <button class="tab-button" data-tab="data">Data</button>
            <button class="tab-button" data-tab="telemetry">Telemetry</button>
            <button class="tab-button" data-tab="cognitive">Cognitive</button>
        </div>

        <div id="tab-content-container" class="mt-4">
            <!-- CONTROLS TAB -->
            <div id="tab-controls" class="tab-content active space-y-3">
                <div class="group">
                    <h3>Session</h3>
                    <div class="flex gap-2">
                        <button id="regenerate-button" class="btn w-full">Regenerate</button>
                        <label class="btn w-full text-sm"><input id="toggle-audio" type="checkbox" />&nbsp;Mic Input</label>
                    </div>
                     <div id="audio-status" class="text-xs text-center mt-2 text-slate-500">Mic: Inactive</div>
                </div>
                <div class="group">
                     <h3>Creator Actions</h3>
                     <p id="action-text" class="text-xs text-center mb-3 text-slate-400">Observe the cosmos or fly your ship.</p>
                     <button id="btn-directive-prime" class="btn directive w-full">EXECUTE DIRECTIVE PRIME</button>
                </div>
                <div class="group">
                    <h3>Data Particlizer</h3>
                     <div class="grid grid-cols-2 gap-2">
                        <label for="file-upload" class="btn">Particlize File</label>
                        <button id="video-particlize-button" class="btn">Particlize Live</button>
                        <input type="file" id="file-upload" accept="image/*,video/*" class="hidden">
                    </div>
                </div>
            </div>

            <!-- PHYSICS TAB (from Cosmic Nemo) -->
            <div id="tab-physics" class="tab-content">
                <div class="group">
                    <h3>Unified Master Formula (Ψ)</h3>
                    <div class="control-row">
                        <label>Gravitational Strength (U)</label><div id="val-ugrav" class="value">0.55</div>
                        <input id="in-ugrav" type="range" min="-2.0" max="4.0" step="0.01" value="0.55" />
                    </div>
                    <div class="control-row">
                        <label>Chaos Factor (λ)</label><div id="val-lambda" class="value">0.25</div>
                        <input id="in-lambda" type="range" min="0.0" max="2.0" step="0.01" value="0.25" />
                    </div>
                     <div class="control-row">
                        <label>Energy Scaling (Ec)</label><div id="val-ec" class="value">1.2</div>
                        <input id="in-ec" type="range" min="0.2" max="4.0" step="0.1" value="1.2" />
                    </div>
                     <div class="control-row">
                        <label>Motion Damping (ζ)</label><div id="val-li" class="value">0.985</div>
                        <input id="in-li" type="range" min="0.95" max="1.0" step="0.001" value="0.985" />
                    </div>
                     <div class="control-row">
                        <label>Spectral Hue (Ω)</label><div id="val-omega" class="value">0.62</div>
                        <input id="in-omega" type="range" min="0.0" max="1.0" step="0.01" value="0.62" />
                    </div>
                </div>
            </div>
            
            <!-- GRAPHICS TAB -->
            <div id="tab-graphics" class="tab-content space-y-4 text-sm text-slate-300">
                 <div class="slider-container">
                    <label>View Mode</label>
                    <select id="view-mode-select" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 mt-1 text-sm border border-slate-600">
                        <option value="galaxy">Galaxy</option>
                        <option value="solar_system">Solar System</option>
                        <option value="spaceship">Spaceship (3rd Person)</option>
                        <option value="cockpit">Spaceship (Cockpit)</option>
                    </select>
                </div>
                 <div class="slider-container">
                    <label>Graphics Style</label>
                    <select id="quality-select" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 mt-1 text-sm border border-slate-600">
                        <option value="low">Low (Pixelated)</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                        <option value="ultra">Ultra (SSR)</option>
                    </select>
                </div>
                <div class="group">
                    <h3>Motion Blur</h3>
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-xs">Enable</span>
                        <label class="switch">
                            <input type="checkbox" id="motion-blur-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="control-row">
                        <label>Intensity</label><div id="val-motion-blur" class="value">0.85</div>
                        <input id="in-motion-blur" type="range" min="0.0" max="1.0" step="0.05" value="0.85" />
                    </div>
                </div>
            </div>

            <!-- DATA TAB -->
            <div id="tab-data" class="tab-content">
                <div class="group">
                    <h3>Genesis Ledger</h3>
                    <div id="genesis-log-content" class="text-sm font-mono text-slate-400 max-h-48 overflow-y-auto bg-black/20 rounded p-2"></div>
                    <button id="download-ledger-button" class="btn w-full mt-2">Download JSON</button>
                </div>
            </div>

            <!-- TELEMETRY TAB -->
            <div id="tab-telemetry" class="tab-content">
                <div class="group">
                    <h3>Live Telemetry Stream</h3>
                    <input id="telemetry-filter" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 text-xs border border-slate-600 mb-2" placeholder="Filter (e.g., audio, seed, ml)">
                    <div id="telemetry-log-content" class="text-xs font-mono text-slate-400 max-h-60 overflow-y-auto bg-black/20 rounded p-2 whitespace-pre-wrap"></div>
                    <button id="download-telemetry-button" class="btn w-full mt-2">Download Telemetry</button>
                </div>
            </div>

            <!-- COGNITIVE TAB -->
            <div id="tab-cognitive" class="tab-content">
                <div class="p-2 bg-black/20 rounded-md">
                    <p class="font-mono text-xs text-indigo-400">AI INTENTION:</p>
                    <p id="ai-intention" class="font-mono text-xs text-slate-300 h-8">Awaiting sensory input...</p>
                </div>
            </div>

        </div>
    </div>
    
    <!-- HUD Panel -->
    <div id="hud-panel" class="ui-panel top-4 right-4 w-72 p-4 text-xs">
         <!-- Galaxy HUD -->
         <div id="galaxy-hud">
             <h3>Live Genesis Data</h3>
             <div class="grid grid-cols-2 gap-x-3 gap-y-1">
                 <div class="label text-slate-400">Creator Influence:</div><div id="hud-influence" class="value font-mono text-right">Idle</div>
                 <div class="label text-slate-400">Gravity (U):</div><div id="hud-gravity" class="value font-mono text-right">0.00</div>
                 <div class="label text-slate-400">Chaos (λ):</div><div id="hud-chaos" class="value font-mono text-right">0.00</div>
                 <div class="label text-slate-400">Energy (Ec):</div><div id="hud-energy" class="value font-mono text-right">0.00</div>
             </div>
             <h3 class="mt-4">AI Life Particles</h3>
             <div class="grid grid-cols-2 gap-x-3 gap-y-1">
                 <div class="label text-slate-400">Population:</div><div id="hud-life-pop" class="value font-mono text-right">0</div>
                 <div class="label text-slate-400">Formations:</div><div id="hud-life-forms" class="value font-mono text-right">0</div>
                 <div class="label text-slate-400">Energy Level:</div><div id="hud-life-energy" class="value font-mono text-right">Low</div>
             </div>
         </div>
         <!-- Ship HUD -->
        <div id="ship-hud" class="hidden">
           <h3>Stardust Drifter HUD</h3>
           <div class="grid grid-cols-2 gap-x-3 gap-y-1">
               <div class="label text-slate-400">Velocity:</div><div id="hud-ship-vel" class="value font-mono text-right">0 km/s</div>
               <div class="label text-slate-400">Altitude:</div><div id="hud-ship-alt" class="value font-mono text-right">N/A</div>
               <div class="label text-slate-400">Gravity Well:</div><div id="hud-ship-grav" class="value font-mono text-right">None</div>
           </div>
        </div>
        <!-- Surface HUD -->
        <div id="surface-hud" class="hidden">
           <h3>Surface Environment</h3>
           <div class="grid grid-cols-2 gap-x-3 gap-y-1">
               <div class="label text-slate-400">Ocean Roughness:</div><div id="hud-ocean" class="value font-mono text-right">--</div>
               <div class="label text-slate-400">Cloud Coverage:</div><div id="hud-cloud" class="value font-mono text-right">--</div>
               <div class="label text-slate-400">Vegetation:</div><div id="hud-vegetation" class="value font-mono text-right">--</div>
               <div class="label text-slate-400">Altitude:</div><div id="hud-surface-alt" class="value font-mono text-right">--</div>
           </div>
        </div>
        <!-- AI HUD -->
        <div id="ai-hud" class="mt-4">
             <h3>Quantum AI</h3>
             <div class="grid grid-cols-2 gap-x-3 gap-y-1">
                 <div class="label text-slate-400">State:</div><div id="hud-ai-state" class="value font-mono text-right">Observing...</div>
                 <div class="label text-slate-400">Interaction:</div><div id="hud-ai-interaction" class="value font-mono text-right">None</div>
             </div>
        </div>
    </div>

    <!-- PSI Overlay Panel -->
    <div id="psiPanel" class="ui-panel" style="right: 12px; bottom: 12px; max-width: 420px; padding: 12px; display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0; font-size: 14px; color: #9db8ff;">CST ψ — Live Terms</h3>
            <button id="psiClose" style="border: 0; background: transparent; color: #9db8ff; font-weight: 700; cursor: pointer; font-size: 18px;">×</button>
        </div>
        <div style="display: grid; grid-template-columns: auto 1fr; column-gap: 10px; row-gap: 6px; font-family: 'Roboto Mono', monospace; font-size: 12px;">
            <div style="color: #9db8ff;">c²·φ·E_c</div><div style="color: #cfe8ff; text-align: right;" id="psi_term1">–</div>
            <div style="color: #9db8ff;">λ (audio)</div><div style="color: #cfe8ff; text-align: right;" id="psi_term2">–</div>
            <div style="color: #9db8ff;">Ω·E_c</div><div style="color: #cfe8ff; text-align: right;" id="psi_term3">–</div>
            <div style="color: #9db8ff;">U_grav</div><div style="color: #cfe8ff; text-align: right;" id="psi_term4">–</div>
            <div style="color: #9db8ff;">Σρ_sd</div><div style="color: #cfe8ff; text-align: right;" id="psi_term5">–</div>
            <div style="color: #9db8ff;">ψ (sum)</div><div style="color: #cfe8ff; text-align: right;" id="psi_sum">–</div>
        </div>
        <canvas id="psi_graph_canvas" width="400" height="100" style="margin-top: 10px; width: 100%; height: 100px;"></canvas>
    </div>

    <!-- Seed Visualizer -->
    <div id="seed-visualizer" style="position: fixed; bottom: 12px; left: 12px; height: 60px; width: 400px; display: none; background: rgba(0,0,0,0.6); border: 1px solid rgba(100,116,139,0.3); border-radius: 0.5rem; overflow: hidden; backdrop-filter: blur(10px);">
        <div style="display: flex; align-items: center; justify-content: space-around; height: 100%;">
            <div class="data-stream"><span>Audio</span><div id="pulse-audio" class="data-pulse"></div></div>
            <div class="data-stream"><span>Video</span><div id="pulse-video" class="data-pulse"></div></div>
            <div class="data-stream"><span>Loc</span><div id="pulse-loc" class="data-pulse"></div></div>
            <div class="data-stream"><span>Light</span><div id="pulse-light" class="data-pulse"></div></div>
            <div class="data-stream"><span>USGS</span><div id="pulse-usgs" class="data-pulse"></div></div>
            <div class="data-stream"><span>APOD</span><div id="pulse-apod" class="data-pulse"></div></div>
            <div class="data-stream"><span>ML</span><div id="pulse-ml" class="data-pulse"></div></div>
        </div>
    </div>

<script type="module">
    // --- IMPORTS ---
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
    import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
    import { SSRPass } from 'three/addons/postprocessing/SSRPass.js';
    import { Sky } from 'three/addons/objects/Sky.js';

    // --- UTILITY FUNCTIONS ---
    const $ = (id) => document.getElementById(id);
    const lerp = (a, b, t) => a + (b - a) * t;
    const G = 6.674e-2; // Gravitational constant for simulation

    // FIX: Storage utility with graceful degradation for tracking prevention
    const SafeStorage = {
        _memoryStore: {},
        _storageAvailable: null,

        _checkStorage() {
            if (this._storageAvailable !== null) return this._storageAvailable;
            try {
                const test = '__storage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                this._storageAvailable = true;
                return true;
            } catch (e) {
                console.info('[Storage] localStorage blocked by tracking prevention - using memory fallback');
                this._storageAvailable = false;
                return false;
            }
        },

        getItem(key) {
            if (this._checkStorage()) {
                try {
                    return localStorage.getItem(key);
                } catch (e) {
                    return this._memoryStore[key] || null;
                }
            }
            return this._memoryStore[key] || null;
        },

        setItem(key, value) {
            if (this._checkStorage()) {
                try {
                    localStorage.setItem(key, value);
                } catch (e) {
                    this._memoryStore[key] = value;
                }
            } else {
                this._memoryStore[key] = value;
            }
        },

        removeItem(key) {
            if (this._checkStorage()) {
                try {
                    localStorage.removeItem(key);
                } catch (e) {
                    delete this._memoryStore[key];
                }
            } else {
                delete this._memoryStore[key];
            }
        }
    };

    // --- PHYSICS CONSTANTS ---
    const H_PLANCK = 6.62607015e-34; // Planck constant
    const PHI_GOLDEN = 1.618033988749895; // Golden ratio
    const C_LIGHT = 299792458; // Speed of light (m/s)
    const K_BOLTZMANN = 1.380649e-23; // Boltzmann constant

    // UUID Generator
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    // Frequency to RGB color mapping (E = h*ν)
    function freqToRgb(frequency) {
        // Map frequency (Hz) to visible spectrum (380-750 THz)
        const minFreq = 380e12;
        const maxFreq = 750e12;
        const clampedFreq = Math.max(minFreq, Math.min(maxFreq, frequency));
        const normalized = (clampedFreq - minFreq) / (maxFreq - minFreq);

        let r, g, b;
        if (normalized < 0.25) {
            // Red to Yellow
            const t = normalized / 0.25;
            r = 1; g = t; b = 0;
        } else if (normalized < 0.5) {
            // Yellow to Green
            const t = (normalized - 0.25) / 0.25;
            r = 1 - t; g = 1; b = 0;
        } else if (normalized < 0.75) {
            // Green to Cyan
            const t = (normalized - 0.5) / 0.25;
            r = 0; g = 1; b = t;
        } else {
            // Cyan to Blue
            const t = (normalized - 0.75) / 0.25;
            r = 0; g = 1 - t; b = 1;
        }

        return new THREE.Color(r, g, b);
    }

    // Seeded Random Number Generator
    function cyrb128(str) {
        let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
        for (let i = 0, k; i < str.length; i++) {
            k = str.charCodeAt(i);
            h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
            h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
            h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
            h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
        }
        h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
        h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
        h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
        h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
        return [(h1 ^ h2 ^ h3 ^ h4) >>> 0, (h2 ^ h1) >>> 0, (h3 ^ h1) >>> 0, (h4 ^ h1) >>> 0];
    }

    function sfc32(a, b, c, d) {
        return function() {
            a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
            var t = (a + b) | 0;
            a = b ^ b >>> 9;
            b = c + (c << 3) | 0;
            c = (c << 21 | c >>> 11);
            d = d + 1 | 0;
            t = t + d | 0;
            c = c + t | 0;
            return (t >>> 0) / 4294967296;
        }
    }

    // Perlin-like 2D noise generator for terrain
    function createNoise2D(prng) {
        const perm = Array.from({length: 256}, (_, i) => i);
        for (let i = 255; i > 0; i--) {
            const j = Math.floor(prng() * (i + 1));
            [perm[i], perm[j]] = [perm[j], perm[i]];
        }
        const p = new Uint8Array(512);
        for(let i=0; i<256; i++) p[i] = p[i+256] = perm[i];

        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        return function(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            const u = fade(x);
            const v = fade(y);
            const a = p[X] + Y, b = p[X + 1] + Y;
            return lerp(v, lerp(u, grad(p[a], x, y), grad(p[b], x - 1, y)),
                           lerp(u, grad(p[a + 1], x, y - 1), grad(p[b + 1], x - 1, y - 1)));
        };
    }

    // --- PHASE 1: CORE SYSTEMS ---

    // EventBus - Complete pub/sub with history (85 lines)
    class EventBus {
        constructor() {
            this.listeners = new Map();
            this.history = [];
            this.maxHistory = 100;
        }

        on(eventName, callback, context = null) {
            if (!this.listeners.has(eventName)) {
                this.listeners.set(eventName, []);
            }
            this.listeners.get(eventName).push({ callback, context });
        }

        off(eventName, callback) {
            if (!this.listeners.has(eventName)) return;
            const listeners = this.listeners.get(eventName);
            const index = listeners.findIndex(l => l.callback === callback);
            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }

        emit(eventName, data = {}) {
            const event = {
                name: eventName,
                data: data,
                timestamp: Date.now(),
                id: generateUUID()
            };

            // Add to history
            this.history.push(event);
            if (this.history.length > this.maxHistory) {
                this.history.shift();
            }

            // Notify listeners
            if (this.listeners.has(eventName)) {
                this.listeners.get(eventName).forEach(({ callback, context }) => {
                    try {
                        callback.call(context, event.data, event);
                    } catch (err) {
                        console.error(`EventBus error in ${eventName}:`, err);
                    }
                });
            }

            return event;
        }

        getHistory(eventName = null, limit = 10) {
            let filtered = eventName
                ? this.history.filter(e => e.name === eventName)
                : this.history;
            return filtered.slice(-limit);
        }

        clear() {
            this.listeners.clear();
            this.history = [];
        }
    }

    // DataLogger - Dual-channel telemetry logging (75 lines)
    class DataLogger {
        constructor(eventBus) {
            this.eventBus = eventBus;
            this.channels = {
                telemetry: [],
                events: []
            };
            this.maxEntries = 1000;
            this.isRecording = true;

            // Subscribe to all events
            this.eventBus.on('*', (data, event) => this.logEvent(event));
        }

        log(channel, data) {
            if (!this.isRecording) return;

            const entry = {
                timestamp: Date.now(),
                id: generateUUID(),
                data: data
            };

            if (!this.channels[channel]) {
                this.channels[channel] = [];
            }

            this.channels[channel].push(entry);

            // Maintain max size
            if (this.channels[channel].length > this.maxEntries) {
                this.channels[channel].shift();
            }

            return entry;
        }

        logEvent(event) {
            this.log('events', {
                name: event.name,
                data: event.data
            });
        }

        logTelemetry(system, metrics) {
            this.log('telemetry', {
                system: system,
                metrics: metrics
            });
        }

        query(channel, filters = {}) {
            if (!this.channels[channel]) return [];

            let results = this.channels[channel];

            if (filters.since) {
                results = results.filter(e => e.timestamp >= filters.since);
            }

            if (filters.limit) {
                results = results.slice(-filters.limit);
            }

            return results;
        }

        clear(channel = null) {
            if (channel) {
                this.channels[channel] = [];
            } else {
                Object.keys(this.channels).forEach(ch => {
                    this.channels[ch] = [];
                });
            }
        }
    }

    // SensoryInputManager - Audio/video/geolocation/ambient light with FFT (147 lines)
    class SensoryInputManager {
        constructor(eventBus, app) {
            this.eventBus = eventBus;
            this.app = app;
            this.sensors = {
                audio: { active: false, data: null },
                video: { active: false, data: null },
                geolocation: { active: false, data: null },
                ambientLight: { active: false, data: null }
            };
            this.audioContext = null;
            this.analyser = null;
            this.fftData = null;
        }

        async initAudio() {
            if (this.sensors.audio.active) return;

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = this.audioContext.createMediaStreamSource(stream);

                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;

                source.connect(this.analyser);

                this.fftData = new Uint8Array(this.analyser.frequencyBinCount);
                this.sensors.audio.active = true;

                this.eventBus.emit('sensor:audio:initialized', {
                    fftSize: this.analyser.fftSize,
                    sampleRate: this.audioContext.sampleRate
                });
            } catch (err) {
                console.error('Audio initialization failed:', err);
                this.eventBus.emit('sensor:audio:error', { error: err.message });
            }
        }

        async initVideo() {
            if (this.sensors.video.active) return;

            try {
                const videoElement = document.getElementById('video-feed');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 }
                });
                videoElement.srcObject = stream;
                await videoElement.play();

                this.sensors.video.active = true;
                this.sensors.video.element = videoElement;

                this.eventBus.emit('sensor:video:initialized', {
                    width: videoElement.videoWidth,
                    height: videoElement.videoHeight
                });
            } catch (err) {
                console.error('Video initialization failed:', err);
                this.eventBus.emit('sensor:video:error', { error: err.message });
            }
        }

        async initGeolocation() {
            if (!navigator.geolocation) {
                console.warn('Geolocation not supported');
                return;
            }

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    this.sensors.geolocation.active = true;
                    this.sensors.geolocation.data = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        altitude: position.coords.altitude,
                        accuracy: position.coords.accuracy
                    };
                    this.eventBus.emit('sensor:geolocation:update', this.sensors.geolocation.data);
                },
                (err) => {
                    console.error('Geolocation error:', err);
                    this.eventBus.emit('sensor:geolocation:error', { error: err.message });
                }
            );
        }

        initAmbientLight() {
            if (!('AmbientLightSensor' in window)) {
                console.warn('Ambient Light Sensor not supported');
                return;
            }

            try {
                const sensor = new AmbientLightSensor();
                sensor.addEventListener('reading', () => {
                    this.sensors.ambientLight.active = true;
                    this.sensors.ambientLight.data = {
                        illuminance: sensor.illuminance,
                        timestamp: Date.now()
                    };
                    this.eventBus.emit('sensor:ambientLight:update', this.sensors.ambientLight.data);
                });
                sensor.start();
            } catch (err) {
                console.error('Ambient light sensor error:', err);
            }
        }

        async initializeAll() {
            await this.initAudio();
            await this.initVideo();
            await this.initGeolocation();
            this.initAmbientLight();
        }

        update() {
            // Update audio FFT analysis
            if (this.sensors.audio.active && this.analyser) {
                this.analyser.getByteFrequencyData(this.fftData);

                const binCount = this.analyser.frequencyBinCount;
                const bassEnd = Math.floor(binCount * 0.1);
                const midEnd = Math.floor(binCount * 0.4);

                let bass = 0, mids = 0, treble = 0;
                for (let i = 0; i < binCount; i++) {
                    const normalized = this.fftData[i] / 255;
                    if (i < bassEnd) bass += normalized;
                    else if (i < midEnd) mids += normalized;
                    else treble += normalized;
                }

                this.sensors.audio.data = {
                    bass: bass / bassEnd,
                    mids: mids / (midEnd - bassEnd),
                    treble: treble / (binCount - midEnd),
                    fft: Array.from(this.fftData),
                    timestamp: Date.now()
                };

                this.eventBus.emit('sensor:audio:update', this.sensors.audio.data);
            }
        }

        getData(sensorType = null) {
            if (sensorType) {
                return this.sensors[sensorType]?.data || null;
            }
            return Object.keys(this.sensors).reduce((acc, key) => {
                acc[key] = this.sensors[key].data;
                return acc;
            }, {});
        }
    }

    // ExternalDataManager - NASA APIs with rate limiting (117 lines)
    class ExternalDataManager {
        constructor(eventBus) {
            this.eventBus = eventBus;
            this.apiKey = 'HTVS2skIdJsnffqXwdqUunQGmm6y6Wg0yAnD7fZW'; // NASA API key
            this.cache = new Map();
            this.rateLimits = new Map();
            this.lastFetch = new Map();
        }

        async fetchWithRateLimit(url, endpoint, minInterval = 1000) {
            const now = Date.now();
            const lastTime = this.lastFetch.get(endpoint) || 0;

            if (now - lastTime < minInterval) {
                const cached = this.cache.get(endpoint);
                if (cached) return cached;
                await new Promise(resolve => setTimeout(resolve, minInterval - (now - lastTime)));
            }

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                this.cache.set(endpoint, data);
                this.lastFetch.set(endpoint, Date.now());

                this.eventBus.emit(`external:${endpoint}:success`, data);
                return data;
            } catch (err) {
                console.error(`External API error (${endpoint}):`, err);
                this.eventBus.emit(`external:${endpoint}:error`, { error: err.message });
                return null;
            }
        }

        async fetchNasaAPOD() {
            const url = `https://api.nasa.gov/planetary/apod?api_key=${this.apiKey}`;
            return await this.fetchWithRateLimit(url, 'nasa_apod', 3600000); // 1 hour cache
        }

        async fetchNasaDONKI(startDate, endDate) {
            const start = startDate || new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            const end = endDate || new Date().toISOString().split('T')[0];
            const url = `https://api.nasa.gov/DONKI/CME?startDate=${start}&endDate=${end}&api_key=${this.apiKey}`;
            return await this.fetchWithRateLimit(url, 'nasa_donki', 3600000);
        }

        async fetchNasaNEO() {
            const today = new Date().toISOString().split('T')[0];
            const url = `https://api.nasa.gov/neo/rest/v1/feed?start_date=${today}&end_date=${today}&api_key=${this.apiKey}`;
            return await this.fetchWithRateLimit(url, 'nasa_neo', 3600000);
        }

        async fetchUSGSEarthquakes() {
            const url = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_week.geojson';
            return await this.fetchWithRateLimit(url, 'usgs_earthquakes', 300000); // 5 min cache
        }

        async fetchAll() {
            const results = await Promise.allSettled([
                this.fetchNasaAPOD(),
                this.fetchNasaDONKI(),
                this.fetchNasaNEO(),
                this.fetchUSGSEarthquakes()
            ]);

            const data = {
                apod: results[0].status === 'fulfilled' ? results[0].value : null,
                donki: results[1].status === 'fulfilled' ? results[1].value : null,
                neo: results[2].status === 'fulfilled' ? results[2].value : null,
                earthquakes: results[3].status === 'fulfilled' ? results[3].value : null,
                timestamp: Date.now()
            };

            this.eventBus.emit('external:all:fetched', data);
            return data;
        }

        getCache(endpoint = null) {
            if (endpoint) {
                return this.cache.get(endpoint);
            }
            return Object.fromEntries(this.cache);
        }

        clearCache() {
            this.cache.clear();
            this.lastFetch.clear();
        }
    }

    // MachineLearningCore - ml5.js object detection (44 lines)
    class MachineLearningCore {
        constructor(eventBus, app) {
            this.eventBus = eventBus;
            this.app = app;
            this.model = null;
            this.isLoaded = false;
            this.detections = [];
        }

        async initialize() {
            if (!window.ml5) {
                console.warn('ml5.js not loaded');
                return;
            }

            try {
                this.model = await ml5.objectDetector('cocossd');
                this.isLoaded = true;
                this.eventBus.emit('ml:initialized', { model: 'cocossd' });
            } catch (err) {
                console.error('ML model loading failed:', err);
                this.eventBus.emit('ml:error', { error: err.message });
            }
        }

        async detect(videoElement) {
            if (!this.isLoaded || !this.model || !videoElement) return [];

            try {
                const results = await this.model.detect(videoElement);
                this.detections = results;
                this.eventBus.emit('ml:detection', { detections: results, timestamp: Date.now() });
                return results;
            } catch (err) {
                console.error('Detection error:', err);
                return [];
            }
        }

        getDetections() {
            return this.detections;
        }
    }

    // CosmicAwarenessAgent - AI history analysis and decision-making (138 lines)
    class CosmicAwarenessAgent {
        constructor(eventBus, dataLogger) {
            this.eventBus = eventBus;
            this.dataLogger = dataLogger;
            this.preferences = { floraBias: 1.0, blackHoleBias: 1.0 };
            this.latestData = {
                loc: "0,0",
                light: 100,
                apod: "Unknown",
                usgs: 0,
                ml: [],
                audio: 0,
                lastAudioSpike: 0,
                lastLightValue: 100,
                lastSignificantQuakeTime: 0,
                bioFreq: 7.83 // Schumann resonance
            };
            this.scheduledEventTimers = [];
            this.seed = null;
            this.intention = '';
            this.state = {
                awareness: 0,
                creativity: 0,
                chaos: 0,
                harmony: 0
            };
            this.memory = [];
            this.maxMemory = 50;
            this.lastDecision = null;
            this.initSubscriptions();
        }

        initSubscriptions() {
            this.eventBus.on('sensor:geolocation:update', data => {
                this.latestData.loc = `${data.latitude.toFixed(4)},${data.longitude.toFixed(4)}`;
                this.eventBus.emit('genesis:log', { name: 'Location', value: this.latestData.loc, type: 'success' });
            });

            this.eventBus.on('sensor:ambientLight:update', data => {
                this.latestData.light = Math.round(data.illuminance);
                if (Math.abs(this.latestData.light - this.latestData.lastLightValue) > 50) {
                    this.eventBus.emit('ai:event', { type: 'lightChange', value: this.latestData.light });
                    this.latestData.lastLightValue = this.latestData.light;
                }
            });

            this.eventBus.on('external:nasa_apod:success', data => {
                this.latestData.apod = data.title || "Cosmic Silence";
            });

            this.eventBus.on('external:usgs_earthquakes:success', data => {
                if (data.features && data.features.length > 0) {
                    const latestQuake = data.features[0];
                    this.latestData.usgs = latestQuake.properties.mag;
                    if (latestQuake.properties.mag > 6.0 && latestQuake.properties.time > this.latestData.lastSignificantQuakeTime) {
                        this.eventBus.emit('ai:event', { type: 'majorSeismicEvent', magnitude: latestQuake.properties.mag });
                        this.latestData.lastSignificantQuakeTime = latestQuake.properties.time;
                    }
                } else {
                    this.latestData.usgs = 0;
                }
            });

            this.eventBus.on('ml:detections', data => {
                this.latestData.ml = [...new Set(data.map(d => d.label))];
            });

            this.eventBus.on('sensor:audio:update', data => {
                const avgFreq = (data.bass + data.mids + data.treble) * 85; // Approximate average
                const now = Date.now();
                if (avgFreq > 120 && (now - this.latestData.lastAudioSpike > 3000)) {
                    this.eventBus.emit('ai:event', {type: 'audioSpike', value: avgFreq});
                    this.latestData.lastAudioSpike = now;
                }
                this.latestData.audio = avgFreq;
            });
        }

        generateSeed(overrideData = null) {
            const timestamp = Date.now().toString();
            let seedString;
            let intention = "Observing the Void.";
            let influence = {
                hasPlant: false,
                hasBook: false,
                createBlackHole: false,
                bioFreq: this.latestData.bioFreq
            };

            if(overrideData) {
                seedString = JSON.stringify(overrideData);
                intention = "Traversing the Cosmic Web to a new echo.";
            } else {
                seedString = [
                    timestamp,
                    this.latestData.loc,
                    this.latestData.light,
                    this.latestData.apod,
                    this.latestData.audio,
                    ...this.latestData.ml,
                    this.latestData.usgs,
                    this.latestData.bioFreq
                ].join('|');

                influence.hasPlant = (this.latestData.ml.includes("potted plant") || this.latestData.ml.includes("plant"));
                influence.hasBook = this.latestData.ml.includes("book");
                influence.createBlackHole = this.latestData.usgs > 5.0;

                if (influence.createBlackHole) {
                    intention = `Manifesting gravitational anomaly from seismic event (mag ${this.latestData.usgs}).`;
                } else if (influence.hasPlant) {
                    intention = "Cultivating organic structures.";
                } else if (influence.hasBook) {
                    intention = "Constructing monoliths from observed knowledge.";
                } else if (this.latestData.audio > 80) {
                    intention = "Manifesting high-frequency audio energy.";
                } else if (this.latestData.ml.includes("person")) {
                    intention = "Contemplating observed human presence.";
                } else if (this.latestData.light < 50) {
                    intention = "Weaving a cosmos from shadows and low light.";
                } else {
                    intention = `Synthesizing a tranquil cosmos from ${this.latestData.apod}.`;
                }
            }

            this.seed = this.hashString(seedString);
            this.intention = intention;

            this.eventBus.emit('ai:intentionUpdate', intention);
            this.dataLogger.logLedger('event', 'AI', intention);
            this.dataLogger.logLedger('info', 'AI', `Seed: ${this.seed}`);

            return { seed: this.seed, intention, influence };
        }

        hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(16);
        }

        scheduleFutureEvent(eventType, delayMs) {
            const triggerTime = Date.now() + delayMs;
            this.scheduledEventTimers.push({ type: eventType, triggerTime });
            this.dataLogger.logLedger('info', 'AI', `Scheduled ${eventType} in ${delayMs}ms`);
        }

        learn(data) {
            // Analyze sensory inputs and update internal state
            if (data.audio) {
                this.state.chaos += data.audio.mids * 0.01;
                this.state.creativity += data.audio.treble * 0.008;
                this.state.harmony += (1 - data.audio.bass) * 0.005;
            }

            if (data.ml && data.ml.length > 0) {
                this.state.awareness += data.ml.length * 0.02;
            }

            if (data.external) {
                this.state.awareness += 0.01;
            }

            // Decay over time
            Object.keys(this.state).forEach(key => {
                this.state[key] *= 0.99;
                this.state[key] = Math.max(0, Math.min(1, this.state[key]));
            });

            // Store in memory
            this.memory.push({ ...this.state, timestamp: Date.now() });
            if (this.memory.length > this.maxMemory) {
                this.memory.shift();
            }

            this.eventBus.emit('ai:state:update', this.state);
        }

        generateInfluence() {
            // Generate universe parameters based on AI state
            const influence = {
                gravity: 0.5 + (this.state.awareness * 0.3) - (this.state.chaos * 0.2),
                chaos: 0.2 + (this.state.chaos * 0.4),
                energy: 1.0 + (this.state.creativity * 0.5),
                damping: 0.985 - (this.state.chaos * 0.01),
                hue: (this.state.harmony * 0.5) + (this.state.creativity * 0.3),
                timestamp: Date.now()
            };

            this.lastDecision = influence;
            this.eventBus.emit('ai:influence:generated', influence);

            return influence;
        }

        makeDecision(context = {}) {
            // AI decision-making based on context and state
            const decisions = [
                { action: 'expand', weight: this.state.creativity },
                { action: 'contract', weight: this.state.harmony },
                { action: 'chaos', weight: this.state.chaos },
                { action: 'observe', weight: this.state.awareness }
            ];

            // Weighted random selection
            const totalWeight = decisions.reduce((sum, d) => sum + d.weight, 0);
            let random = Math.random() * totalWeight;

            for (const decision of decisions) {
                random -= decision.weight;
                if (random <= 0) {
                    this.eventBus.emit('ai:decision', { action: decision.action, context });
                    return decision.action;
                }
            }

            return 'observe';
        }

        tick(timestamp) {
            // Check scheduled events
            this.scheduledEventTimers = this.scheduledEventTimers.filter(evt => {
                if (timestamp >= evt.triggerTime) {
                    this.eventBus.emit(`ai:event:${evt.type}`, { timestamp });
                    this.dataLogger.logLedger('event', 'AI', `Triggered: ${evt.type}`);
                    return false;
                }
                return true;
            });

            // Periodic AI updates
            if (!this.lastTick || timestamp - this.lastTick > 5000) {
                this.lastTick = timestamp;

                // Analyze event history
                const recentEvents = this.eventBus.getHistory(null, 20);
                const eventTypes = recentEvents.reduce((acc, event) => {
                    acc[event.name] = (acc[event.name] || 0) + 1;
                    return acc;
                }, {});

                this.eventBus.emit('ai:analysis', {
                    state: this.state,
                    eventTypes,
                    memorySize: this.memory.length
                });
            }
        }

        getState() {
            return { ...this.state };
        }

        getMemory(limit = 10) {
            return this.memory.slice(-limit);
        }
    }

    // CSTComputeEngine - 12D Composite Space-Time v3 Computation Engine
    class CSTComputeEngine {
        constructor(eventBus, dataLogger) {
            this.eventBus = eventBus;
            this.dataLogger = dataLogger;
            this.c = 299792458; // Speed of light (m/s)
            this.phi = 1.618033988749895; // Golden ratio
            this.G = 6.674e-11; // Gravitational constant
            this.psi = 0; // Current psi value
            this.psiHistory = []; // History for graphing
            this.maxHistory = 100;
        }

        computePsi(params, sensors, entities) {
            // Term 1: c²·φ·Ec (fundamental energy contribution)
            const term1 = Math.pow(this.c, 2) * this.phi * params.ec;

            // Term 2: λ·audio (sensory audio coupling)
            const audioAvg = sensors.audio ? (sensors.audio.avgFreq || 0) : 0;
            const term2 = params.lambda * audioAvg;

            // Term 3: Ω·Ec (cosmic expansion contribution)
            const term3 = params.omega * params.ec;

            // Term 4: U_grav (gravitational potential energy from massive objects)
            let term4 = 0;
            entities.forEach(e => {
                if (e.userData && (e.userData.type === 'star' || e.userData.type === 'blackhole')) {
                    const mass = e.userData.mass || 1;
                    const r = e.position.length();
                    if (r > 1) term4 += (this.G * mass) / r;
                }
            });
            term4 *= params.ugrav;

            // Term 5: Σρ_sd (Soul Dust density contribution)
            const soulDustCount = entities.filter(e => e.userData && e.userData.type === 'soul_dust').length;
            const term5 = soulDustCount * 0.01;

            // Total psi
            this.psi = term1 + term2 + term3 + term4 + term5;

            // Store in history for graphing
            this.psiHistory.push({ t: Date.now(), psi: this.psi });
            if (this.psiHistory.length > this.maxHistory) this.psiHistory.shift();

            // Emit event for UI updates
            this.eventBus.emit('cst:psi_update', {
                term1, term2, term3, term4, term5, psi: this.psi
            });

            return {
                term1, term2, term3, term4, term5, psi: this.psi
            };
        }

        updateEntityState(entity, deltaTime) {
            if (!entity.userData) return;

            // Initialize 12D state vectors if not present
            if (!entity.userData.h12) entity.userData.h12 = new Float32Array(12);
            if (!entity.userData.x12) entity.userData.x12 = new Float32Array(12);
            if (!entity.userData.m12) entity.userData.m12 = new Float32Array(12);

            const { h12, x12, m12 } = entity.userData;

            // Update x12 (current state vector)
            // Dimensions 0-2: Position (normalized)
            x12[0] = entity.position.x / 100;
            x12[1] = entity.position.y / 100;
            x12[2] = entity.position.z / 100;

            // Dimensions 3-5: Velocity
            if (entity.userData.velocity) {
                x12[3] = entity.userData.velocity.x;
                x12[4] = entity.userData.velocity.y;
                x12[5] = entity.userData.velocity.z;
            }

            // Dimension 6: Age/lifecycle (0 to 1)
            x12[6] = (entity.userData.age || 0) / (entity.userData.maxAge || 1);

            // Dimension 7: Energy (normalized)
            x12[7] = (entity.userData.energy || 0) / 100;

            // Dimension 8: Mass/scale
            x12[8] = entity.scale ? entity.scale.x : 1.0;

            // Dimension 9: Rotation phase
            x12[9] = entity.rotation ? (entity.rotation.y % (2 * Math.PI)) / (2 * Math.PI) : 0;

            // Dimension 10: Interaction count (normalized)
            x12[10] = (entity.userData.interactions || 0) / 100;

            // Dimension 11: Psi influence (normalized)
            x12[11] = this.psi / 1e18;

            // Update m12 (memory via Exponential Moving Average)
            const alpha = 0.1; // Memory decay factor
            for (let i = 0; i < 12; i++) {
                m12[i] = alpha * x12[i] + (1 - alpha) * m12[i];
            }

            // h12 (historical max/min tracking)
            for (let i = 0; i < 12; i++) {
                if (!h12[i] || Math.abs(x12[i]) > Math.abs(h12[i])) {
                    h12[i] = x12[i];
                }
            }
        }

        getEntityStateVector(entity) {
            if (!entity.userData || !entity.userData.x12) return null;
            return {
                h12: Array.from(entity.userData.h12 || []),
                x12: Array.from(entity.userData.x12 || []),
                m12: Array.from(entity.userData.m12 || [])
            };
        }

        getPsiHistory() {
            return this.psiHistory;
        }

        reset() {
            this.psi = 0;
            this.psiHistory = [];
        }
    }

    // QuantumEventManager - Soul dust particle system with E=h*nu physics (228 lines)
    class QuantumEventManager {
        constructor(eventBus, app, scene, camera) {
            this.eventBus = eventBus;
            this.app = app;
            this.scene = scene;
            this.camera = camera;
            this.particles = null;
            this.particleCount = 5000;
            this.uniforms = null;
        }

        initialize() {
            // Soul dust particle geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(this.particleCount * 3);
            const velocities = new Float32Array(this.particleCount * 3);
            const frequencies = new Float32Array(this.particleCount);
            const phases = new Float32Array(this.particleCount);

            for (let i = 0; i < this.particleCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = 500 + Math.random() * 1500;

                positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);

                velocities[i3 + 0] = (Math.random() - 0.5) * 2;
                velocities[i3 + 1] = (Math.random() - 0.5) * 2;
                velocities[i3 + 2] = (Math.random() - 0.5) * 2;

                // Quantum frequency (E = h*ν)
                frequencies[i] = 400e12 + Math.random() * 350e12; // THz range
                phases[i] = Math.random() * Math.PI * 2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('frequency', new THREE.BufferAttribute(frequencies, 1));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            // Quantum swirl shader
            this.uniforms = {
                time: { value: 0 },
                hPlanck: { value: H_PLANCK },
                phiGolden: { value: PHI_GOLDEN },
                cameraPos: { value: new THREE.Vector3() }
            };

            const vertexShader = `
                attribute float frequency;
                attribute float phase;
                attribute vec3 velocity;

                uniform float time;
                uniform float hPlanck;
                uniform float phiGolden;
                uniform vec3 cameraPos;

                varying vec3 vColor;
                varying float vAlpha;

                vec3 freqToRgb(float freq) {
                    float minFreq = 380e12;
                    float maxFreq = 750e12;
                    float normalized = (freq - minFreq) / (maxFreq - minFreq);

                    vec3 color;
                    if (normalized < 0.25) {
                        float t = normalized / 0.25;
                        color = vec3(1.0, t, 0.0);
                    } else if (normalized < 0.5) {
                        float t = (normalized - 0.25) / 0.25;
                        color = vec3(1.0 - t, 1.0, 0.0);
                    } else if (normalized < 0.75) {
                        float t = (normalized - 0.5) / 0.25;
                        color = vec3(0.0, 1.0, t);
                    } else {
                        float t = (normalized - 0.75) / 0.25;
                        color = vec3(0.0, 1.0 - t, 1.0);
                    }
                    return color;
                }

                void main() {
                    vec3 pos = position;

                    // Quantum swirl (golden ratio spiral)
                    float angle = time * 0.5 + phase;
                    float radius = length(pos.xy);
                    float spiralAngle = angle + radius * phiGolden * 0.001;

                    pos.x = radius * cos(spiralAngle);
                    pos.y = radius * sin(spiralAngle);
                    pos.z += sin(time + phase) * 50.0;

                    vColor = freqToRgb(frequency);

                    float dist = distance(pos, cameraPos);
                    vAlpha = 1.0 - smoothstep(1000.0, 3000.0, dist);

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = 20.0 * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            const fragmentShader = `
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);

                    if (dist > 0.5) discard;

                    float alpha = (1.0 - dist * 2.0) * vAlpha;
                    gl_FragColor = vec4(vColor, alpha);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms: this.uniforms,
                vertexShader,
                fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            this.particles = new THREE.Points(geometry, material);
            this.scene.add(this.particles);

            this.eventBus.emit('quantum:initialized', {
                particleCount: this.particleCount
            });
        }

        update(delta) {
            if (!this.particles) return;

            this.uniforms.time.value += delta;
            this.uniforms.cameraPos.value.copy(this.camera.position);

            // Update particle positions with quantum physics
            const positions = this.particles.geometry.attributes.position.array;
            const velocities = this.particles.geometry.attributes.velocity.array;
            const frequencies = this.particles.geometry.attributes.frequency.array;

            for (let i = 0; i < this.particleCount; i++) {
                const i3 = i * 3;

                // E = h*ν energy calculation
                const energy = H_PLANCK * frequencies[i];
                const energyFactor = energy / (H_PLANCK * 500e12); // Normalized

                // Apply quantum momentum
                velocities[i3 + 0] += (Math.random() - 0.5) * energyFactor * 0.1;
                velocities[i3 + 1] += (Math.random() - 0.5) * energyFactor * 0.1;
                velocities[i3 + 2] += (Math.random() - 0.5) * energyFactor * 0.1;

                // Damping
                velocities[i3 + 0] *= 0.98;
                velocities[i3 + 1] *= 0.98;
                velocities[i3 + 2] *= 0.98;

                // Update positions
                positions[i3 + 0] += velocities[i3 + 0];
                positions[i3 + 1] += velocities[i3 + 1];
                positions[i3 + 2] += velocities[i3 + 2];

                // Boundary wrap
                const pos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                if (pos.length() > 2000) {
                    pos.normalize().multiplyScalar(500);
                    positions[i3 + 0] = pos.x;
                    positions[i3 + 1] = pos.y;
                    positions[i3 + 2] = pos.z;
                }
            }

            this.particles.geometry.attributes.position.needsUpdate = true;
            this.particles.geometry.attributes.velocity.needsUpdate = true;

            this.eventBus.emit('quantum:update', {
                time: this.uniforms.time.value,
                particleCount: this.particleCount
            });
        }

        setIntensity(intensity) {
            if (this.particles) {
                this.particles.material.opacity = intensity;
            }
        }

        dispose() {
            if (this.particles) {
                this.scene.remove(this.particles);
                this.particles.geometry.dispose();
                this.particles.material.dispose();
                this.particles = null;
            }
        }
    }

    // ProceduralGenerationEngine - Stars, planets, black holes with shaders (342 lines)
    class ProceduralGenerationEngine {
        constructor(scene, eventBus) {
            this.scene = scene;
            this.eventBus = eventBus;
            this.celestialObjects = [];
            this.starField = null;
        }

        generateUniverse(influence = {}) {
            this.clearUniverse();

            const gravity = influence.gravity || 0.55;
            const chaos = influence.chaos || 0.25;
            const energy = influence.energy || 1.2;
            const hue = influence.hue || 0.62;

            // Generate stars with corona
            const starCount = Math.floor(5 + chaos * 10);
            for (let i = 0; i < starCount; i++) {
                this.createStar(hue, energy);
            }

            // Generate planets with atmospheres
            const planetCount = Math.floor(8 + chaos * 12);
            for (let i = 0; i < planetCount; i++) {
                this.createPlanet(hue, gravity);
            }

            // Generate black holes
            if (Math.random() < gravity * 0.5) {
                this.createBlackHole(gravity, energy);
            }

            // Add nebulas
            if (Math.random() < 0.7) {
                const nebulaPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 10000,
                    (Math.random() - 0.5) * 10000,
                    (Math.random() - 0.5) * 10000
                );
                this.createNebula(nebulaPos, 1000 + Math.random() * 2000, hue + 0.3);
            }

            // Add asteroid belts
            if (Math.random() < 0.5) {
                const beltPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 6000,
                    (Math.random() - 0.5) * 6000,
                    (Math.random() - 0.5) * 6000
                );
                this.createAsteroidBelt(beltPos, 500, 1200, 100);
            }

            // Add distant galaxies
            if (Math.random() < 0.3) {
                const galaxyPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 15000,
                    (Math.random() - 0.5) * 15000,
                    (Math.random() - 0.5) * 15000
                );
                this.createGalaxy(galaxyPos, 3 + Math.floor(Math.random() * 3), 5000);
            }

            this.eventBus.emit('procedural:universe:generated', {
                stars: starCount,
                planets: planetCount,
                gravity,
                chaos,
                energy
            });
        }

        createStar(hue, energy) {
            const radius = 100 + Math.random() * 200;
            const geometry = new THREE.SphereGeometry(radius, 32, 32);

            // Corona shader
            const uniforms = {
                time: { value: 0 },
                color: { value: new THREE.Color().setHSL(hue, 0.9, 0.6) },
                energy: { value: energy }
            };

            const vertexShader = `
                varying vec3 vNormal;
                varying vec3 vPosition;
                uniform float time;

                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;

                    vec3 pos = position;
                    float displacement = sin(position.x * 0.05 + time) *
                                       cos(position.y * 0.05 + time) * 5.0;
                    pos += normal * displacement;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `;

            const fragmentShader = `
                uniform vec3 color;
                uniform float energy;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    vec3 glow = color * intensity * energy;
                    gl_FragColor = vec4(glow + color * 0.3, 1.0);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms,
                vertexShader,
                fragmentShader
            });

            const star = new THREE.Mesh(geometry, material);
            const angle = Math.random() * Math.PI * 2;
            const orbitRadius = 1000 + Math.random() * 2000;
            const height = (Math.random() - 0.5) * 1000;
            star.position.set(
                Math.cos(angle) * orbitRadius,
                height,
                Math.sin(angle) * orbitRadius
            );
            console.log('[STAR]', star.position.x.toFixed(0), star.position.y.toFixed(0), star.position.z.toFixed(0));

            this.scene.add(star);
            this.celestialObjects.push({ type: 'star', mesh: star, uniforms });

            // Add point light
            const light = new THREE.PointLight(uniforms.color.value, energy * 1000, 2000);
            light.position.copy(star.position);
            this.scene.add(light);
            this.celestialObjects.push({ type: 'light', mesh: light });
        }

        createPlanet(hue, gravity) {
            const radius = 30 + Math.random() * 80;
            const geometry = new THREE.SphereGeometry(radius, 32, 32);

            // Rayleigh scattering atmosphere shader
            const uniforms = {
                planetColor: { value: new THREE.Color().setHSL((hue + Math.random() * 0.3) % 1, 0.7, 0.5) },
                atmosphereColor: { value: new THREE.Color().setHSL((hue + 0.1) % 1, 0.8, 0.6) },
                time: { value: 0 }
            };

            const vertexShader = `
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform vec3 planetColor;
                uniform vec3 atmosphereColor;
                uniform float time;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    // Lambertian diffuse
                    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                    float diffuse = max(dot(vNormal, lightDir), 0.0);

                    // Rayleigh scattering effect
                    float atmosphere = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.5);
                    vec3 atmosphereGlow = atmosphereColor * atmosphere * 0.5;

                    vec3 finalColor = planetColor * diffuse + atmosphereGlow;
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms,
                vertexShader,
                fragmentShader
            });

            const planet = new THREE.Mesh(geometry, material);
            const angle = Math.random() * Math.PI * 2;
            const orbitRadius = 800 + Math.random() * 1500;
            const height = (Math.random() - 0.5) * 800;
            planet.position.set(
                Math.cos(angle) * orbitRadius,
                height,
                Math.sin(angle) * orbitRadius
            );

            this.scene.add(planet);
            this.celestialObjects.push({ type: 'planet', mesh: planet, uniforms });
        }

        createBlackHole(gravity, energy) {
            const radius = 150 + gravity * 100;

            // Black hole sphere (event horizon)
            const sphereGeo = new THREE.SphereGeometry(radius, 32, 32);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const blackHole = new THREE.Mesh(sphereGeo, sphereMat);

            // Accretion disk shader
            const diskGeo = new THREE.RingGeometry(radius * 1.5, radius * 3, 64);
            const uniforms = {
                time: { value: 0 },
                innerRadius: { value: radius * 1.5 },
                outerRadius: { value: radius * 3 },
                color1: { value: new THREE.Color(0xff6600) },
                color2: { value: new THREE.Color(0xffaa00) }
            };

            const vertexShader = `
                varying vec2 vUv;
                varying vec3 vPosition;

                void main() {
                    vUv = uv;
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float time;
                uniform float innerRadius;
                uniform float outerRadius;
                uniform vec3 color1;
                uniform vec3 color2;
                varying vec2 vUv;
                varying vec3 vPosition;

                void main() {
                    float dist = length(vPosition.xy);
                    float normalizedDist = (dist - innerRadius) / (outerRadius - innerRadius);

                    // Spiral pattern
                    float angle = atan(vPosition.y, vPosition.x);
                    float spiral = sin(angle * 8.0 + time * 2.0 - normalizedDist * 10.0);

                    // Color gradient
                    vec3 color = mix(color1, color2, normalizedDist);
                    color *= (0.7 + spiral * 0.3);

                    float alpha = 1.0 - smoothstep(0.0, 1.0, normalizedDist);
                    gl_FragColor = vec4(color, alpha * 0.8);
                }
            `;

            const diskMat = new THREE.ShaderMaterial({
                uniforms,
                vertexShader,
                fragmentShader,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            const accretionDisk = new THREE.Mesh(diskGeo, diskMat);
            accretionDisk.rotation.x = Math.PI / 2;

            const blackHoleGroup = new THREE.Group();
            blackHoleGroup.add(blackHole);
            blackHoleGroup.add(accretionDisk);
            const angle = Math.random() * Math.PI * 2;
            const orbitRadius = 1200 + Math.random() * 1800;
            const height = (Math.random() - 0.5) * 600;
            blackHoleGroup.position.set(
                Math.cos(angle) * orbitRadius,
                height,
                Math.sin(angle) * orbitRadius
            );

            this.scene.add(blackHoleGroup);
            this.celestialObjects.push({
                type: 'blackhole',
                mesh: blackHoleGroup,
                uniforms,
                disk: accretionDisk
            });
        }

        update(delta) {
            this.celestialObjects.forEach(obj => {
                if (obj.uniforms && obj.uniforms.time) {
                    obj.uniforms.time.value += delta;
                }

                // Rotate planets and stars
                if (obj.type === 'planet' || obj.type === 'star') {
                    obj.mesh.rotation.y += delta * 0.1;
                }

                // Rotate black hole accretion disk
                if (obj.type === 'blackhole' && obj.disk) {
                    obj.disk.rotation.z += delta * 0.5;
                }
            });
        }

        clearUniverse() {
            this.celestialObjects.forEach(obj => {
                this.scene.remove(obj.mesh);
                if (obj.mesh.geometry) obj.mesh.geometry.dispose();
                if (obj.mesh.material) obj.mesh.material.dispose();
            });
            this.celestialObjects = [];
        }

        getCelestialObjects() {
            return this.celestialObjects;
        }

        createNebula(position, size, colorHue) {
            const particleCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = size * Math.pow(Math.random(), 0.33); // Clustered center

                positions[i3] = position.x + r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = position.y + r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = position.z + r * Math.cos(phi);

                const color = new THREE.Color().setHSL(colorHue + Math.random() * 0.1, 0.8, 0.6);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;

                sizes[i] = 10 + Math.random() * 20;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 15,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const nebula = new THREE.Points(geometry, material);
            this.scene.add(nebula);
            this.celestialObjects.push({ type: 'nebula', mesh: nebula });

            console.log('[ProceduralGen] 🌫️ Nebula created at', position);
            return nebula;
        }

        createAsteroidBelt(centerPos, innerRadius, outerRadius, count) {
            const asteroids = [];

            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const size = 2 + Math.random() * 8;

                const geometry = new THREE.DodecahedronGeometry(size, 0);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    roughness: 0.9,
                    metalness: 0.1
                });

                const asteroid = new THREE.Mesh(geometry, material);
                asteroid.position.set(
                    centerPos.x + Math.cos(angle) * radius,
                    centerPos.y + (Math.random() - 0.5) * 50,
                    centerPos.z + Math.sin(angle) * radius
                );

                asteroid.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );

                this.scene.add(asteroid);
                asteroids.push(asteroid);
            }

            this.celestialObjects.push({ type: 'asteroidBelt', meshes: asteroids });
            console.log('[ProceduralGen] ☄️ Asteroid belt created with', count, 'asteroids');
            return asteroids;
        }

        createGalaxy(position, armCount, particleCount) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const arm = i % armCount;
                const armAngle = (arm / armCount) * Math.PI * 2;
                const spinAngle = (i / particleCount) * Math.PI * 8;
                const radius = Math.pow(Math.random(), 2) * 5000;
                const angle = armAngle + spinAngle * 0.5;

                positions[i3] = position.x + Math.cos(angle) * radius;
                positions[i3 + 1] = position.y + (Math.random() - 0.5) * radius * 0.1;
                positions[i3 + 2] = position.z + Math.sin(angle) * radius;

                const colorValue = 0.8 + Math.random() * 0.2;
                colors[i3] = colorValue;
                colors[i3 + 1] = colorValue * 0.9;
                colors[i3 + 2] = colorValue;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const galaxy = new THREE.Points(geometry, material);
            galaxy.rotation.x = Math.random() * Math.PI;
            galaxy.rotation.y = Math.random() * Math.PI;

            this.scene.add(galaxy);
            this.celestialObjects.push({ type: 'galaxy', mesh: galaxy });

            console.log('[ProceduralGen] 🌌 Galaxy created with', particleCount, 'stars');
            return galaxy;
        }

        populateUniverse() {
            console.log('[ProceduralGen] 🌌 Beginning universe population...');

            const startTime = performance.now();

            // Configuration
            const config = {
                stars: { count: 20, minRadius: 80, maxRadius: 200, spread: 10000 },
                planets: { count: 40, minRadius: 20, maxRadius: 80, spread: 8000 },
                blackHoles: { count: 3, minRadius: 80, maxRadius: 150, spread: 12000 }
            };

            // Helper function for random position
            const randomPosition = (spread) => {
                return new THREE.Vector3(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * spread
                );
            };

            // Clear existing objects
            this.clearUniverse();

            // Generate stars
            console.log(`[ProceduralGen] ⭐ Generating ${config.stars.count} stars...`);
            for (let i = 0; i < config.stars.count; i++) {
                const hue = Math.random(); // Random color
                const energy = 0.5 + Math.random() * 0.5; // Energy 0.5-1.0

                // Use the existing createStar method
                this.createStar(hue, energy);
            }

            // Generate planets
            console.log(`[ProceduralGen] 🪐 Generating ${config.planets.count} planets...`);
            for (let i = 0; i < config.planets.count; i++) {
                const hue = Math.random(); // Random color
                const gravity = 0.3 + Math.random() * 0.4; // Gravity 0.3-0.7

                // Use the existing createPlanet method
                this.createPlanet(hue, gravity);
            }

            // Generate black holes
            console.log(`[ProceduralGen] 🕳️  Generating ${config.blackHoles.count} black holes...`);
            for (let i = 0; i < config.blackHoles.count; i++) {
                const gravity = 0.5 + Math.random() * 0.5; // Gravity 0.5-1.0
                const energy = 0.7 + Math.random() * 0.3; // Energy 0.7-1.0

                // Use the existing createBlackHole method
                this.createBlackHole(gravity, energy);
            }

            const endTime = performance.now();
            const duration = (endTime - startTime).toFixed(2);

            console.log(`[ProceduralGen] ✅ Universe populated with ${this.celestialObjects.length} objects in ${duration}ms`);
            console.log(`[ProceduralGen] 📊 Breakdown:`, {
                stars: config.stars.count,
                planets: config.planets.count,
                blackHoles: config.blackHoles.count,
                total: this.celestialObjects.length
            });

            // Emit event
            if (this.eventBus) {
                this.eventBus.emit('procedural:universe_populated', {
                    objectCount: this.celestialObjects.length,
                    breakdown: {
                        stars: config.stars.count,
                        planets: config.planets.count,
                        blackHoles: config.blackHoles.count
                    },
                    duration: duration
                });
            }

            // GUARANTEE: One visible red sphere
            const guaranteedGeometry = new THREE.SphereGeometry(300, 32, 32);
            const guaranteedMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
            const guaranteedStar = new THREE.Mesh(guaranteedGeometry, guaranteedMaterial);
            guaranteedStar.position.set(0, 0, -2000);
            this.scene.add(guaranteedStar);
            console.log('[GUARANTEE] Red sphere at (0, 0, -2000)');
        }
    }

    // ProceduralAudioEngine - Generates procedural audio effects
    class ProceduralAudioEngine {
        constructor(listener) {
            this.listener = listener;
            this.sounds = new Map();
            this.audioContext = null;

            if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                this.audioContext = new (AudioContext || webkitAudioContext)();
            }
        }

        createAmbientDrone(frequency = 220) {
            if (!this.audioContext) return null;

            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.type = 'sine';
            oscillator.frequency.value = frequency;
            gainNode.gain.value = 0.1;

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.start();

            this.sounds.set('ambient', { oscillator, gainNode });
            return { oscillator, gainNode };
        }

        createWarpSound() {
            if (!this.audioContext) return;

            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1000, this.audioContext.currentTime + 0.5);

            gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.start();
            oscillator.stop(this.audioContext.currentTime + 0.5);
        }

        createExplosionSound() {
            if (!this.audioContext) return;

            const bufferSize = this.audioContext.sampleRate * 0.5;
            const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize / 5));
            }

            const source = this.audioContext.createBufferSource();
            const gainNode = this.audioContext.createGain();

            source.buffer = buffer;
            gainNode.gain.value = 0.3;

            source.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            source.start();
        }

        stopAll() {
            this.sounds.forEach(sound => {
                if (sound.oscillator) sound.oscillator.stop();
            });
            this.sounds.clear();
        }
    }

    // --- Sub-system classes ---
    class AudioManager {
        constructor(toggleElement, statusElement) {
            this.toggle = toggleElement;
            this.status = statusElement;
            this.isActive = false;
            this.bass = 0; this.mids = 0; this.treble = 0;
            
            this.toggle.addEventListener('change', () => {
                if (this.toggle.checked) this.enable();
                else this.disable();
            });
        }

        async enable() {
            if (this.isActive || !navigator.mediaDevices) return;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                const source = this.ctx.createMediaStreamSource(stream);
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 512;
                source.connect(this.analyser);
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.isActive = true;
                this.status.textContent = "Mic: Active";
            } catch (err) {
                console.error("Microphone access denied:", err);
                this.status.textContent = "Mic: Error";
                this.toggle.checked = false;
            }
        }

        disable() {
            if (!this.isActive || !this.ctx) return;
            this.ctx.close();
            this.isActive = false;
            this.status.textContent = "Mic: Inactive";
        }

        getAnalysis() {
            if (!this.isActive) return { bass: 0, mids: 0, treble: 0 };
            
            this.analyser.getByteFrequencyData(this.dataArray);
            const binCount = this.analyser.frequencyBinCount;
            
            const bassEnd = Math.floor(binCount * 0.1);
            const midEnd = Math.floor(binCount * 0.4);
            
            let bassSum = 0, midSum = 0, trebleSum = 0;
            for (let i = 0; i < binCount; i++) {
                const val = Math.pow(this.dataArray[i] / 255, 2);
                if (i < bassEnd) bassSum += val;
                else if (i < midEnd) midSum += val;
                else trebleSum += val;
            }
            
            this.bass = lerp(this.bass, Math.min(1, bassSum / (bassEnd * 0.5)), 0.1);
            this.mids = lerp(this.mids, Math.min(1, midSum / ((midEnd - bassEnd) * 0.5)), 0.1);
            this.treble = lerp(this.treble, Math.min(1, trebleSum / ((binCount - midEnd) * 0.5)), 0.1);
            
            return { bass: this.bass, mids: this.mids, treble: this.treble };
        }
    }

    class Singularity {
        constructor(scene) {
            const geo = new THREE.IcosahedronGeometry(1, 3);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
            this.mesh = new THREE.Mesh(geo, mat);
            scene.add(this.mesh);
            this.baseScale = 150;
        }
        
        update(params, isMouseDown) {
            const targetScale = this.baseScale + params.ugrav * 20;
            const targetColor = new THREE.Color().setHSL(params.omega, 0.9, 0.7);
            this.mesh.scale.setScalar(lerp(this.mesh.scale.x, targetScale, 0.1));
            this.mesh.material.color.lerp(targetColor, 0.1);
            this.mesh.rotation.x += 0.001;
            this.mesh.rotation.y += 0.002;
            if (isMouseDown) this.mesh.scale.multiplyScalar(1.05);
        }
        
        reset() {
            this.mesh.scale.setScalar(this.baseScale);
            this.mesh.material.color.set(0xffffff);
        }

        show(visible = true) { this.mesh.visible = visible; }
    }

    class CosmosParticleSystem {
        constructor(scene) {
            this.scene = scene;
            this.count = 100000;
            this.velocities = null;
            this.points = null;
        }

        init(params) {
            if (this.points) {
                this.scene.remove(this.points);
                this.points.geometry.dispose();
                this.points.material.dispose();
            }

            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(this.count * 3);
            this.velocities = new Float32Array(this.count * 3);

            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = 2000 + Math.random() * 2000;
                positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 15, color: new THREE.Color().setHSL(params.omega, 0.8, 0.7),
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            
            this.points = new THREE.Points(geo, mat);
            this.scene.add(this.points);
        }

        update(dt, params, mouse, isMouseDown) {
            if (!this.points || !window.genesisApp) return;
            this.points.material.size = params.ec * 15;
            this.points.material.color.setHSL(params.omega, 0.8, 0.7);

            const positions = this.points.geometry.attributes.position.array;
            const mouseForce = isMouseDown ? 3000 : 0;
            const G_local = params.ugrav * 1000;
            
            const mouseWorld = new THREE.Vector3(mouse.x, mouse.y, 0.5)
                .unproject(window.genesisApp.camera).sub(window.genesisApp.camera.position).normalize();
            const distance = -window.genesisApp.camera.position.z / mouseWorld.z;
            const mouse3D = new THREE.Vector3().copy(window.genesisApp.camera.position).add(mouseWorld.multiplyScalar(distance));
            
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const pos = new THREE.Vector3(positions[i3], positions[i3+1], positions[i3+2]);
                const vel = new THREE.Vector3(this.velocities[i3], this.velocities[i3+1], this.velocities[i3+2]);
                
                const toCenter = new THREE.Vector3().copy(pos).multiplyScalar(-1);
                const distSq = pos.lengthSq();
                const gravity = toCenter.normalize().multiplyScalar(G_local / (distSq + 10000));
                
                const toMouse = new THREE.Vector3().subVectors(mouse3D, pos);
                const distMouseSq = toMouse.lengthSq();
                const creatorPull = toMouse.normalize().multiplyScalar(mouseForce / (distMouseSq + 100000));
                
                const chaos = new THREE.Vector3(
                    (Math.random() - 0.5) * params.lambda * 50,
                    (Math.random() - 0.5) * params.lambda * 50,
                    (Math.random() - 0.5) * params.lambda * 50
                );

                vel.add(gravity).add(creatorPull).add(chaos);
                vel.multiplyScalar(params.li);
                pos.add(vel.clone().multiplyScalar(dt));
                
                positions[i3] = pos.x; positions[i3+1] = pos.y; positions[i3+2] = pos.z;
                this.velocities[i3] = vel.x; this.velocities[i3+1] = vel.y; this.velocities[i3+2] = vel.z;
            }
            this.points.geometry.attributes.position.needsUpdate = true;
        }

        show(visible = true) { if (this.points) this.points.visible = visible; }
    }
        
    class AILifeParticleSystem extends CosmosParticleSystem {
        constructor(scene) {
            super(scene);
            this.count = 2000;
            this.isFormingCrystal = false;
        }

        init() {
            if (this.points) {
                this.scene.remove(this.points);
                this.points.geometry.dispose();
                this.points.material.dispose();
            }

            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(this.count * 3);
            this.velocities = new Float32Array(this.count * 3);
            
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = 1000 + Math.random() * 1000;
                positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 25, color: 0x00ffaa,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            
            this.points = new THREE.Points(geo, mat);
            this.scene.add(this.points);
        }
        
        formNeuralCrystal() {
            this.isFormingCrystal = true;
            const crystalGeo = new THREE.IcosahedronGeometry(1000, 5);
            this.crystalTargetPositions = crystalGeo.attributes.position.array;
        }

        update(dt, audio, mouse, isMouseDown, isFormingCrystal = false) {
            if (!this.points || !window.genesisApp) return;
            
            this.isFormingCrystal = isFormingCrystal;
            const positions = this.points.geometry.attributes.position.array;
            const attraction = audio.bass * 200;
            const chaos = audio.mids * 500;
            this.points.material.size = 25 + audio.treble * 50;

            const mouseWorld = new THREE.Vector3(mouse.x, mouse.y, 0.5)
                .unproject(window.genesisApp.camera).sub(window.genesisApp.camera.position).normalize();
            const distance = -window.genesisApp.camera.position.z / mouseWorld.z;
            const mouse3D = new THREE.Vector3().copy(window.genesisApp.camera.position).add(mouseWorld.multiplyScalar(distance));
            const mouseRepel = isMouseDown ? 5000 : 0;
            
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const pos = new THREE.Vector3(positions[i3], positions[i3+1], positions[i3+2]);
                const vel = new THREE.Vector3(this.velocities[i3], this.velocities[i3+1], this.velocities[i3+2]);

                if (this.isFormingCrystal && this.crystalTargetPositions) {
                    const targetIdx = (i * 3) % this.crystalTargetPositions.length;
                    const targetPos = new THREE.Vector3(
                        this.crystalTargetPositions[targetIdx],
                        this.crystalTargetPositions[targetIdx+1],
                        this.crystalTargetPositions[targetIdx+2]
                    );
                    pos.lerp(targetPos, 0.05);
                } else {
                    const fromMouse = new THREE.Vector3().subVectors(pos, mouse3D);
                    const distMouseSq = fromMouse.lengthSq();
                    const creatorRepel = fromMouse.normalize().multiplyScalar(mouseRepel / (distMouseSq + 100000));
                    vel.add(creatorRepel);
                }
                
                vel.add(new THREE.Vector3((Math.random()-0.5)*chaos, (Math.random()-0.5)*chaos, (Math.random()-0.5)*chaos));
                vel.multiplyScalar(0.98);
                pos.add(vel.clone().multiplyScalar(dt));
                
                positions[i3] = pos.x; positions[i3+1] = pos.y; positions[i3+2] = pos.z;
                this.velocities[i3] = vel.x; this.velocities[i3+1] = vel.y; this.velocities[i3+2] = vel.z;
            }
            this.points.geometry.attributes.position.needsUpdate = true;
        }

        getStats() {
            if(!this.points) return { population: 0, formations: 0, energy: 'Low' };
            let energyLevel = 'Low';
            if (this.points.material.size > 50) energyLevel = 'High';
            else if (this.points.material.size > 35) energyLevel = 'Medium';
            return { population: this.count, formations: 0, energy: energyLevel }; // Simplified for now
        }
    }

    class QuantumAIModel {
        constructor() {
            this.weights = { chaos: 0, creative: 0, calm: 0 };
        }
        learn(data) {
            this.weights.chaos += data.audio.mids * 0.005;
            this.weights.creative += data.audio.treble * 0.003;
            this.weights.calm += (1 - (data.audio.bass + data.audio.mids)) * 0.002;
        }
        update(dt) {
            this.weights.chaos = Math.max(0, this.weights.chaos - dt * 0.05);
            this.weights.creative = Math.max(0, this.weights.creative - dt * 0.03);
            this.weights.calm = Math.max(0, this.weights.calm - dt * 0.02);
            
            let dominantState = 'Observing';
            if (this.weights.chaos > this.weights.creative && this.weights.chaos > this.weights.calm) {
                dominantState = 'Chaotic';
            } else if (this.weights.creative > this.weights.calm) {
                dominantState = 'Creative';
            } else if(this.weights.calm > 0.1) {
                dominantState = 'Calm';
            }
            return { dominantState, interaction: 'None' };
        }
    }

    class SolarSystemManager {
        constructor(scene) {
            this.scene = scene;
            this.solarSystemGroup = new THREE.Group();
            this.scene.add(this.solarSystemGroup);
            this.celestialBodies = [];
        }

        init() {
            this.solarSystemGroup.clear();
            this.celestialBodies = [];

            const planetData = [
                { name: 'Mercury', radius: 0.38, distance: 1200, color: '#9a9a9a', mass: 0.055 },
                { name: 'Venus', radius: 0.95, distance: 2000, color: '#d8b48d', mass: 0.815 },
                { name: 'Earth', radius: 1, distance: 2800, color: '#4d92d0', mass: 1 },
                { name: 'Mars', radius: 0.53, distance: 3800, color: '#c1440e', mass: 0.107 },
                { name: 'Jupiter', radius: 11.2, distance: 6500, color: '#c8a377', mass: 317.8 },
                { name: 'Saturn', radius: 9.45, distance: 9500, color: '#e3d5b8', mass: 95.2, hasRings: true },
                { name: 'Uranus', radius: 4.01, distance: 13000, color: '#aadaf0', mass: 14.5 },
                { name: 'Neptune', radius: 3.88, distance: 16000, color: '#3f54ba', mass: 17.1 }
            ];

            const sunMass = 333000;
            const sunGeo = new THREE.SphereGeometry(700, 64, 64);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd88, map: this.createSunTexture() });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            const sunLight = new THREE.PointLight(0xffddaa, 4500000, 0, 1.5);
            this.solarSystemGroup.add(sun, sunLight);
            this.sun = { mesh: sun, data: { name: 'Sun', mass: sunMass, radius: 700 } };
            this.celestialBodies.push(this.sun);
            
            planetData.forEach(data => {
                const planetGeo = new THREE.SphereGeometry(data.radius * 40, 32, 32);
                const texture = this.createPlanetTexture(data);
                const planetMat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });
                const planet = new THREE.Mesh(planetGeo, planetMat);
                
                const position = new THREE.Vector3(data.distance, 0, 0);
                planet.position.copy(position);
                const orbitalVelocityMagnitude = Math.sqrt(G * sunMass / data.distance);
                const velocity = new THREE.Vector3(0, 0, -orbitalVelocityMagnitude);

                const planetObject = { mesh: planet, data: { ...data, radius: data.radius * 40 }, velocity: velocity };

                if(data.hasRings) {
                    const ringGeo = new THREE.RingGeometry(data.radius * 50, data.radius * 80, 64);
                    const ringMat = new THREE.MeshBasicMaterial({ map: this.createRingTexture(), side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
                    const rings = new THREE.Mesh(ringGeo, ringMat);
                    rings.rotation.x = Math.PI * 0.45;
                    planet.add(rings);
                }
                
                const orbitGeo = new THREE.BufferGeometry().setFromPoints(
                    new THREE.Path().absellipse(0, 0, data.distance, data.distance, 0, Math.PI * 2, false).getPoints(128));
                orbitGeo.rotateX(Math.PI / 2);
                const orbit = new THREE.Line(orbitGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 }));

                this.solarSystemGroup.add(planet, orbit);
                this.celestialBodies.push(planetObject);
            });

            this.hide();
        }

        createSunTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffdd88'; ctx.fillRect(0,0,128,128);
            for(let i=0; i < 2000; i++) {
                ctx.fillStyle = `rgba(255, ${Math.floor(Math.random() * 100 + 100)}, 0, ${Math.random() * 0.2})`;
                ctx.beginPath();
                ctx.arc(Math.random() * 128, Math.random() * 128, Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }
        
        createPlanetTexture(data) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = data.color;
            ctx.fillRect(0, 0, 256, 128);
            for (let i = 0; i < 500; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * 256, Math.random() * 128, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            if (data.name === 'Earth') {
                ctx.fillStyle = '#679436';
                for(let i=0; i<15; i++) ctx.fillRect(Math.random()*256, Math.random()*128, Math.random() * 40 + 10, Math.random() * 20 + 5);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                for(let i=0; i<20; i++) ctx.fillRect(Math.random()*256, Math.random()*128, Math.random() * 80 + 20, 2);
            } else if (data.name === 'Jupiter' || data.name === 'Saturn') {
                for(let y=0; y < 128; y += (Math.random() * 10 + 5)) {
                    ctx.fillStyle = (Math.random() > 0.5) ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.1)';
                    ctx.fillRect(0, y, 256, Math.random() * 10 + 2);
                }
            }
            return new THREE.CanvasTexture(canvas);
        }
        
        createRingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 2;
            const ctx = canvas.getContext('2d');
            for (let i = 0; i < 256; i++) {
                const alpha = Math.random() * 0.4 + 0.1;
                ctx.fillStyle = `rgba(200, 180, 150, ${alpha})`;
                ctx.fillRect(i, 0, 1, 2);
            }
            return new THREE.CanvasTexture(canvas);
        }

        update(dt) {
            if (!this.solarSystemGroup.visible) return;
            const timeStep = dt * 20;
            this.celestialBodies.forEach(body => {
                if (body.data.name === 'Sun') {
                    body.mesh.rotation.y += dt * 0.01;
                    return;
                }
                const force = new THREE.Vector3();
                const toSun = new THREE.Vector3().subVectors(this.sun.mesh.position, body.mesh.position);
                const distanceSq = toSun.lengthSq();
                const forceMagnitude = G * (this.sun.data.mass * body.data.mass) / distanceSq;
                force.copy(toSun).normalize().multiplyScalar(forceMagnitude);
                const acceleration = force.divideScalar(body.data.mass);
                body.velocity.add(acceleration.multiplyScalar(timeStep));
                body.mesh.position.add(body.velocity.clone().multiplyScalar(timeStep));
                body.mesh.rotation.y += dt * 0.05;
            });
        }
        
        getCelestialBodies() { return this.celestialBodies; }
        show(visible = true) { this.solarSystemGroup.visible = visible; }
        hide() { this.show(false); }
    }

    class SpaceshipController {
        constructor(scene) {
            this.scene = scene;
            this.ship = this.buildShip();
            this.scene.add(this.ship);
            this.velocity = new THREE.Vector3();
            this.acceleration = new THREE.Vector3();
            this.rotationVelocity = new THREE.Vector2();
            this.keys = {};
            this.mouse = {x: 0, y: 0};
            this.strongestGravSource = null;
        }

        buildShip() {
            const shipGroup = new THREE.Group();
            const mainMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.3 });
            const bodyGeo = new THREE.CapsuleGeometry(1, 4, 4, 12);
            const body = new THREE.Mesh(bodyGeo, mainMat);
            body.rotation.x = Math.PI / 2;
            shipGroup.add(body);
            shipGroup.scale.setScalar(50);
            return shipGroup;
        }
        
        reset() {
            this.ship.position.set(3000, 1000, 3000);
            this.ship.rotation.set(0, 0, 0);
            this.velocity.set(0, 0, 0);
        }

        update(dt, celestialBodies) {
            const totalForce = new THREE.Vector3();
            let strongestGrav = { force: 0, body: null, distance: Infinity };
            
            celestialBodies.forEach(body => {
                const toBody = new THREE.Vector3().subVectors(body.mesh.position, this.ship.position);
                const distanceSq = toBody.lengthSq();
                if (distanceSq < 1) return;
                const forceMag = G * (body.data.mass * 500) / distanceSq; // Increased ship mass for more pull
                totalForce.add(toBody.normalize().multiplyScalar(forceMag));
                if(forceMag > strongestGrav.force) {
                    strongestGrav = { force: forceMag, body: body, distance: Math.sqrt(distanceSq) };
                }
            });
            this.strongestGravSource = strongestGrav;
            
            const thrust = this.keys['KeyW'] ? 1500 : (this.keys['KeyS'] ? -500 : 0);
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.ship.quaternion);
            totalForce.add(forward.multiplyScalar(thrust));
            
            const pitchSpeed = -this.mouse.y * 2.0;
            const yawSpeed = -this.mouse.x * 2.0;
            const rollSpeed = (this.keys['KeyQ'] ? 2.5 : 0) - (this.keys['KeyE'] ? 2.5 : 0);
            this.rotationVelocity.x = lerp(this.rotationVelocity.x, pitchSpeed, dt * 5);
            this.rotationVelocity.y = lerp(this.rotationVelocity.y, yawSpeed, dt * 5);
            this.ship.rotateOnAxis(new THREE.Vector3(1, 0, 0), this.rotationVelocity.x * dt);
            this.ship.rotateOnAxis(new THREE.Vector3(0, 1, 0), this.rotationVelocity.y * dt);
            this.ship.rotateOnAxis(new THREE.Vector3(0, 0, 1), rollSpeed * dt);
            
            this.acceleration = totalForce.divideScalar(50); // ship mass
            this.velocity.add(this.acceleration.multiplyScalar(dt));
            this.velocity.multiplyScalar(0.995);
            this.ship.position.add(this.velocity.clone().multiplyScalar(dt));
        }
        
        updateCamera(camera) {
            const offset = new THREE.Vector3(0, 300, 1000);
            offset.applyQuaternion(this.ship.quaternion);
            const targetPos = new THREE.Vector3().copy(this.ship.position).add(offset);
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(this.ship.position);
        }
        
        getState() {
            let gravData = this.strongestGravSource;
            let state = {
                velocity: this.velocity.length() * 10,
                gravSource: null,
                altitude: 0
            };
            if (gravData && gravData.body) {
                state.gravSource = gravData.body.data;
                state.altitude = gravData.distance - (gravData.body.data.radius);
            }
            return state;
        }
        
        handleMouseMove(e) {
             if (!this.ship.visible) return;
             // Using movementX/Y for direct control response in pointer lock
             this.mouse.x = e.movementX / window.innerWidth;
             this.mouse.y = e.movementY / window.innerHeight;
        }

        show(visible = true) { this.ship.visible = visible; }
    }

    class Particlizer {
        constructor(scene) {
            this.scene = scene;
            this.mesh = null;
            this.particles = [];
            this.sourceType = 'none';
        }

        particlize(source, type = 'file') {
            this.destroy();
            if (source instanceof File) {
                this.fromImage(source);
            } else if (type === 'liveVideo') {
                 this.fromLiveVideo(source);
            }
        }
        
        fromImage(file) {
            const reader = new FileReader();
            reader.onload = e => { 
                const img = new Image(); 
                img.onload = () => this.processImageData(img); 
                img.src = e.target.result; 
            };
            reader.readAsDataURL(file);
        }

        fromLiveVideo(videoElement) {
            this.sourceType = 'liveVideo';
            this.videoElement = videoElement;
            this.processImageData(this.videoElement);
        }

        processImageData(source) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const MAX_DIM = 128;
            const sourceWidth = source.videoWidth || source.width, sourceHeight = source.videoHeight || source.height;
            const scale = Math.min(MAX_DIM / sourceWidth, MAX_DIM / sourceHeight);
            canvas.width = sourceWidth * scale; canvas.height = sourceHeight * scale;
            if(canvas.width === 0 || canvas.height === 0) return;

            ctx.drawImage(source, 0, 0, canvas.width, canvas.height);
            const { data, width, height } = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const positions = [], colors = []; this.particles = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    if (data[i+3] > 128) {
                        const pos = new THREE.Vector3(x - width/2, -y + height/2, 0).multiplyScalar(10);
                        positions.push(pos.x, pos.y, pos.z);
                        colors.push(data[i]/255, data[i+1]/255, data[i+2]/255);
                        this.particles.push({ pos, vel: new THREE.Vector3() });
                    }
                }
            }
            if (positions.length === 0) return;
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(positions), 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(colors), 3));
            this.mesh = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 10, vertexColors: true, sizeAttenuation: true, blending:THREE.AdditiveBlending, depthWrite: false }));
            this.scene.add(this.mesh);
        }

        update(delta) {
            if(!this.mesh || !this.mesh.visible) return;
            // update logic can be added here
        }

        destroy() {
            if(this.mesh) {
                if(this.mesh.parent) this.mesh.parent.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                this.mesh = null; this.particles = [];
            }
        }
    }

    // --- ADDITIONAL ENGINE SYSTEMS ---

    // SurfaceManager - Planetary surface with terrain, sky, and water
    class SurfaceManager {
        constructor(bus, scene, prng){
            this.bus = bus; this.scene = scene; this.prng = prng;
            this.surfaceGroup = new THREE.Group();
            this.surfaceGroup.visible = false;
            this.scene.add(this.surfaceGroup);
            this.noise = createNoise2D(this.prng);
            this.params = { oceanRoughness: 0.2, cloudCoverage: 0.3, vegetation: 0.5 };
        }

        buildSurface() {
            // Sky
            this.sky = new Sky();
            this.sky.scale.setScalar(450000);
            this.surfaceGroup.add(this.sky);
            const sun = new THREE.Vector3();
            const uniforms = this.sky.material.uniforms;
            uniforms['turbidity'].value = 10;
            uniforms['rayleigh'].value = 2;
            uniforms['mieCoefficient'].value = 0.005;
            uniforms['mieDirectionalG'].value = 0.8;
            const phi = THREE.MathUtils.degToRad(90 - 25);
            const theta = THREE.MathUtils.degToRad(180);
            sun.setFromSphericalCoords(1, phi, theta);
            uniforms['sunPosition'].value.copy(sun);
            this.scene.fog = new THREE.Fog(0x8a9aaa, 100, 4000);

            // Terrain
            const terrainGeo = new THREE.PlaneGeometry(8000, 8000, 200, 200);
            const pos = terrainGeo.attributes.position;
            for(let i=0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const z1 = this.noise(x*0.005, y*0.005) * 300;
                const z2 = this.noise(x*0.02, y*0.02) * 50;
                pos.setZ(i, z1 + z2);
            }
            terrainGeo.computeVertexNormals();
            const terrainMat = new THREE.MeshStandardMaterial({color: 0x6a7863, roughness: 0.9, metalness: 0.1});
            this.terrain = new THREE.Mesh(terrainGeo, terrainMat);
            this.terrain.rotation.x = -Math.PI / 2;
            this.surfaceGroup.add(this.terrain);

            // Water
            const waterGeo = new THREE.PlaneGeometry(8000, 8000);
            const waterMat = new THREE.MeshStandardMaterial({
                color: 0x42628a, transparent: true, opacity: 0.85, roughness: 0.2, metalness: 0.5
            });
            this.water = new THREE.Mesh(waterGeo, waterMat);
            this.water.rotation.x = -Math.PI / 2;
            this.water.position.y = 20;
            this.surfaceGroup.add(this.water);
        }

        show(visible){
            this.surfaceGroup.visible = visible;
            if(this.scene.fog) this.scene.fog.far = visible ? 4000 : 0;
        }

        update(params) {
            if(params) Object.assign(this.params, params);
            if(this.water) this.water.material.roughness = this.params.oceanRoughness * 0.4;
        }

        getParams() { return this.params; }
    }

    // ObjectLibrary - Spawnable celestial objects
    class ObjectLibrary {
        constructor(bus, scene, prng){
            this.bus = bus; this.scene = scene; this.prng = prng;
            this.objects = []; this.objectCount = 0;
            this.effects = [];
            bus.on('ai:create', m => {
                if(!m) return;
                if(m.kind==='star') this.createStar(m.params||{});
                else if(m.kind==='planet') this.createPlanet(m.params||{});
                else if(m.kind === 'blackHole') this.createBlackHole(m.params || {});
            });
        }

        createStar(params){
            const size = params.size ?? (8 + this.prng()*10);
            const hue = params.hue ?? this.prng();
            const col = new THREE.Color().setHSL(hue,.8,.6);
            const star = new THREE.Mesh(new THREE.SphereGeometry(size,48,48), new THREE.MeshBasicMaterial({color:col}));
            const r=800+this.prng()*1200, a=this.prng()*Math.PI*2;
            star.position.set(r*Math.cos(a), 0, r*Math.sin(a));
            this.scene.add(star);
            const light=new THREE.PointLight(col, 16, 0, 2);
            light.position.copy(star.position);
            this.scene.add(light);
            const attractor={ position:light.position, strength:12.0 };
            const starObject = {mesh: star, light, attractor, type: 'star', life: 100 + this.prng() * 200};
            star.userData.parent = starObject;
            this.objects.push(starObject);
            this.bus.emit('create:attractor', attractor);
            this.updateCount();
        }

        createPlanet(params){
            const radius = params.radius ?? (3+this.prng()*4);
            const planet = new THREE.Mesh(new THREE.SphereGeometry(radius,64,64),
                new THREE.MeshStandardMaterial({ color:new THREE.Color().setHSL(this.prng(),.35,.55), roughness:.9 }));
            const dist=(params.distance??(140+this.prng()*260));
            const ang=this.prng()*Math.PI*2;
            planet.position.set(Math.cos(ang)*dist, 0, Math.sin(ang)*dist);
            this.scene.add(planet);
            const attractor={ position:planet.position, strength:5.0 };
            this.objects.push({mesh: planet, attractor, type: 'planet'});
            this.bus.emit('create:attractor', attractor);
            this.updateCount();
        }

        createBlackHole(params) {
            const size = params.size ?? (15 + this.prng()*20);
            const hole = new THREE.Mesh(new THREE.SphereGeometry(size, 64, 64),
                new THREE.MeshBasicMaterial({color: 0x000000}));
            const r=1000+this.prng()*1500, a=this.prng()*Math.PI*2;
            hole.position.set(r*Math.cos(a), (this.prng() - 0.5) * 400, r*Math.sin(a));
            this.scene.add(hole);
            const attractor = {position: hole.position, strength: -80.0 };
            this.objects.push({mesh: hole, attractor, type: 'blackHole'});
            this.bus.emit('create:attractor', attractor);
            this.updateCount();
        }

        createSupernova(position, color) {
            const geo = new THREE.SphereGeometry(1, 48, 48);
            const mat = new THREE.MeshBasicMaterial({color, transparent: true, blending: THREE.AdditiveBlending});
            const effect = new THREE.Mesh(geo, mat);
            effect.position.copy(position);
            this.scene.add(effect);
            this.effects.push({mesh: effect, life: 3.0, startSize: 15, endSize: 300});
        }

        update(dt) {
            for(let i=this.objects.length-1; i>=0; i--) {
                const obj = this.objects[i];
                if(obj.type === 'star' && obj.life > 0) {
                    obj.life -= dt;
                    if(obj.life <= 0) {
                        this.createSupernova(obj.mesh.position, obj.light.color);
                        this.scene.remove(obj.mesh);
                        this.scene.remove(obj.light);
                        this.objects.splice(i, 1);
                        this.updateCount();
                    }
                }
            }
            for(let i=this.effects.length-1; i>=0; i--) {
                const effect = this.effects[i];
                effect.life -= dt;
                if(effect.life <=0) {
                    this.scene.remove(effect.mesh);
                    this.effects.splice(i, 1);
                } else {
                    const progress = 1.0 - (effect.life / 3.0);
                    effect.mesh.scale.setScalar(effect.startSize + progress * (effect.endSize - effect.startSize));
                    effect.mesh.material.opacity = 1.0 - progress;
                }
            }
        }

        updateCount() {
            this.objectCount = this.objects.filter(o => o.type !== 'effect').length;
        }

        show(visible) {
            this.objects.forEach(o => {
                o.mesh.visible = visible;
                if(o.light) o.light.visible = visible;
            });
        }
    }

    // VolumetricDust - Atmospheric dust clouds
    class VolumetricDust {
        constructor(scene, camera) {
            const uniforms={
                u_time:{value:0}, u_camPos:{value:camera.position}, u_density:{value:0.5},
                u_steps:{value:20}, u_scale:{value:0.0016}, u_color:{value:new THREE.Color(0x89a9ff)},
                u_drive:{value:0}
            };
            const mat=new THREE.ShaderMaterial({ uniforms, side:THREE.BackSide, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
              vertexShader:`varying vec3 vPos; void main(){ vPos=(modelMatrix*vec4(position,1.0)).xyz; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
              fragmentShader:`precision highp float; varying vec3 vPos; uniform vec3 u_camPos; uniform float u_time; uniform float u_density; uniform int u_steps; uniform float u_scale; uniform vec3 u_color; uniform float u_drive; float hash(vec3 p){ return fract(sin(dot(p, vec3(127.1,311.7,74.7)))*43758.5453); } float noise(vec3 p){ vec3 i=floor(p); vec3 f=fract(p); f=f*f*(3.0-2.0*f); float n=mix(mix(mix(hash(i+vec3(0,0,0)),hash(i+vec3(1,0,0)),f.x),mix(hash(i+vec3(0,1,0)),hash(i+vec3(1,1,0)),f.x),f.y), mix(mix(hash(i+vec3(0,0,1)),hash(i+vec3(1,0,1)),f.x),mix(hash(i+vec3(0,1,1)),hash(i+vec3(1,1,1)),f.x),f.y),f.z); return n; } void main(){ vec3 ro=u_camPos; vec3 rd=normalize(vPos-ro); float t=0.0; float T=0.0; vec3 col=vec3(0.0); int STEPS=u_steps; for(int i=0;i<128;i++){ if(i>=STEPS) break; vec3 p=ro+rd*t; float n=noise(p*u_scale+vec3(0.0,u_time*0.02,0.0)); float d=smoothstep(0.45,0.75,n); float a=d*u_density*(0.8+0.4*u_drive); col+=(1.0-T)*a*u_color; T+=a*0.06; if(T>0.98) break; t+=800.0; } gl_FragColor=vec4(col, clamp(T,0.0,0.7)); }`
            });
            this.mesh=new THREE.Mesh(new THREE.BoxGeometry(2e6,2e6,2e6), mat);
            this.mesh.renderOrder=-10;
            scene.add(this.mesh);
            this.material = mat;
        }

        update(now, fps, chaos) {
            this.material.uniforms.u_time.value = now;
            this.material.uniforms.u_drive.value = chaos;
            const steps=Math.round(10 + 20 * Math.min(1, (fps - 30) / 60));
            this.material.uniforms.u_steps.value = steps;
        }

        show(visible) { this.mesh.visible = visible; }
    }

    // AudioReactiveSystem - Visual audio reactivity
    class AudioReactiveSystem {
        constructor(scene, eventBus) {
            this.scene = scene;
            this.eventBus = eventBus;
            this.particles = null;
            this.velocities = [];
            this.createParticleSystem();
        }

        createParticleSystem() {
            const count = 5000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            this.velocities = new Array(count).fill(null).map(() => new THREE.Vector3());

            for(let i=0; i<count; i++) {
                const i3 = i*3;
                positions[i3] = (Math.random()-0.5)*2000;
                positions[i3+1] = (Math.random()-0.5)*2000;
                positions[i3+2] = (Math.random()-0.5)*2000;
                colors[i3] = Math.random();
                colors[i3+1] = Math.random();
                colors[i3+2] = Math.random();
            }

            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({size: 8, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true});
            this.particles = new THREE.Points(geo, mat);
            this.scene.add(this.particles);
        }

        update(dt, audioData) {
            if(!this.particles || !audioData) return;
            const positions = this.particles.geometry.attributes.position.array;
            const bass = audioData.bass || 0;
            const mids = audioData.mids || 0;
            const treble = audioData.treble || 0;

            for(let i=0; i<this.velocities.length; i++) {
                const i3 = i*3;
                const vel = this.velocities[i];
                vel.y += bass * 20;
                vel.x += (Math.random()-0.5) * mids * 10;
                vel.z += (Math.random()-0.5) * treble * 10;
                vel.multiplyScalar(0.95);

                positions[i3] += vel.x * dt;
                positions[i3+1] += vel.y * dt;
                positions[i3+2] += vel.z * dt;
            }
            this.particles.geometry.attributes.position.needsUpdate = true;
            this.particles.material.size = 8 + treble * 15;
        }

        show(visible) { if(this.particles) this.particles.visible = visible; }
    }

    // MemoryEcho - Echo mode for data artifacts
    class MemoryEcho {
        constructor(scene, camera, eventBus) {
            this.scene = scene;
            this.camera = camera;
            this.eventBus = eventBus;
            this.isActive = false;
            this.data = null;
            this.particleSystem = null;
            this.player = null;
            this.artifacts = [];
            this.keys = {};
            this.audioCtx = null;
            this.oscillator = null;
            this.gainNode = null;
            this.foundCount = 0;

            document.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        }

        loadData(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                this.data = new Uint8Array(e.target.result);
            };
            reader.readAsArrayBuffer(file);
        }

        enter() {
            if (!this.data) return;
            this.isActive = true;
            this.camera.position.set(0, 10, 50);
            this.camera.rotation.set(0,0,0);
            const seed = cyrb128(this.data.toString().substring(0, 1000));
            const prng = sfc32(...seed);

            const positions = [], colors = [];
            const colorPalettes = [ { r: 0.5, g: 0.2, b: 0.8 }, { r: 0.2, g: 0.8, b: 0.5 }, { r: 0.9, g: 0.5, b: 0.2 }, { r: 0.2, g: 0.5, b: 0.9 } ];
            const quadrantSize = 2000;
            for (let i = 0; i < 80000; i++) {
                const quadrant = Math.floor(prng() * 4);
                const palette = colorPalettes[quadrant];
                const x = (prng() - 0.5) * quadrantSize + (quadrant % 2 === 0 ? -quadrantSize/2 : quadrantSize/2);
                const z = (prng() - 0.5) * quadrantSize + (quadrant < 2 ? -quadrantSize/2 : quadrantSize/2);
                const y = (prng() - 0.5) * 500;
                positions.push(x, y, z);
                colors.push(palette.r * prng(), palette.g * prng(), palette.b * prng());
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            this.particleSystem = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 3, vertexColors: true, sizeAttenuation: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.7, transparent: true }));
            this.scene.add(this.particleSystem);

            this.player = new THREE.Group();
            this.player.add(new THREE.Mesh(new THREE.IcosahedronGeometry(2, 0), new THREE.MeshBasicMaterial({ color: 0xffffff })));
            this.player.position.set(0, 0, 0);
            this.scene.add(this.player);

            for (let i = 0; i < 4; i++) {
                const palette = colorPalettes[i];
                const artifact = new THREE.Mesh(new THREE.BoxGeometry(10, 20, 10), new THREE.MeshBasicMaterial({ color: new THREE.Color(palette.r, palette.g, palette.b), wireframe: true }));
                const x = (prng() - 0.5) * quadrantSize/2 + (i % 2 === 0 ? -quadrantSize/2 : quadrantSize/2);
                const z = (prng() - 0.5) * quadrantSize/2 + (i < 2 ? -quadrantSize/2 : quadrantSize/2);
                artifact.position.set(x, 0, z);
                artifact.userData.isArtifact = true;
                this.artifacts.push(artifact);
                this.scene.add(artifact);
            }
            this.initAudioSearch();
        }

        update(delta) {
            if (!this.isActive || !this.player) return;
            const moveSpeed = 100 * delta;
            if (this.keys['w'] || this.keys['arrowup']) this.player.position.z -= moveSpeed;
            if (this.keys['s'] || this.keys['arrowdown']) this.player.position.z += moveSpeed;
            if (this.keys['a'] || this.keys['arrowleft']) this.player.position.x -= moveSpeed;
            if (this.keys['d'] || this.keys['arrowright']) this.player.position.x += moveSpeed;

            this.camera.position.lerp(this.player.position.clone().add(new THREE.Vector3(0, 10, 50)), 0.05);
            this.camera.lookAt(this.player.position);

            let closestDist = Infinity;
            this.artifacts.forEach(artifact => {
                artifact.rotation.y += delta;
                const dist = this.player.position.distanceTo(artifact.position);
                if (dist < closestDist) closestDist = dist;
                if (dist < 20) {
                    this.scene.remove(artifact);
                    this.artifacts = this.artifacts.filter(a => a !== artifact);
                    this.foundCount++;
                }
            });

            if (this.gainNode) {
                const proximity = Math.max(0, 1 - closestDist / 3000);
                this.gainNode.gain.setTargetAtTime(proximity * 0.1, this.audioCtx.currentTime, 0.01);
                this.oscillator.frequency.setTargetAtTime(100 + (1000 * proximity), this.audioCtx.currentTime, 0.01);
            }
            if (this.artifacts.length === 0) { this.exit(); }
        }

        exit() {
            this.isActive = false;
            if(this.particleSystem) { this.scene.remove(this.particleSystem); this.particleSystem.geometry.dispose(); this.particleSystem.material.dispose(); }
            if(this.player) this.scene.remove(this.player);
            this.artifacts.forEach(a => { this.scene.remove(a); a.geometry.dispose(); a.material.dispose(); });
            this.artifacts = []; this.foundCount = 0;
            if(this.oscillator) this.oscillator.stop();
            if(this.audioCtx) this.audioCtx.close();
            this.audioCtx = null; this.oscillator = null;
        }

        initAudioSearch() {
            this.audioCtx = new(window.AudioContext || window.webkitAudioContext)();
            this.oscillator = this.audioCtx.createOscillator();
            this.gainNode = this.audioCtx.createGain();
            this.oscillator.connect(this.gainNode);
            this.gainNode.connect(this.audioCtx.destination);
            this.gainNode.gain.value = 0;
            this.oscillator.type = 'sine';
            this.oscillator.start();
        }
    }

    // SoundBrush - Interactive audio painting
    class SoundBrush {
        constructor(scene, camera, eventBus) {
            this.scene = scene;
            this.camera = camera;
            this.eventBus = eventBus;
            this.isActive = false;
            this.energy = 0;
            this.MAX_ENERGY = 100;
            this.latestAudioData = { raw: [], avgFreq: 0 };
            this.brushStrokes = [];
        }

        paint() {
            if (!this.isActive || this.energy <= 0) return;

            const color = freqToRgb(380e12 + this.latestAudioData.avgFreq * 370e12);
            const size = 5 + this.latestAudioData.avgFreq * 20;

            const geo = new THREE.SphereGeometry(size, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.7 });
            const stroke = new THREE.Mesh(geo, mat);

            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion);
            stroke.position.copy(this.camera.position).add(forward.multiplyScalar(100));

            this.scene.add(stroke);
            this.brushStrokes.push({ mesh: stroke, life: 5.0 });
            this.energy -= 5;
        }

        update(dt) {
            for(let i=this.brushStrokes.length-1; i>=0; i--) {
                const stroke = this.brushStrokes[i];
                stroke.life -= dt;
                if(stroke.life <= 0) {
                    this.scene.remove(stroke.mesh);
                    stroke.mesh.geometry.dispose();
                    stroke.mesh.material.dispose();
                    this.brushStrokes.splice(i, 1);
                } else {
                    stroke.mesh.material.opacity = stroke.life / 5.0;
                }
            }
            this.energy = Math.min(this.MAX_ENERGY, this.energy + dt * 10);
        }

        onAudioData(data) {
            if (!this.isActive) return;
            this.latestAudioData = data;
        }

        toggle() { this.isActive = !this.isActive; }
    }

    // PsiOverlay - CST diagnostics overlay
    class PsiOverlay {
        constructor(bus, camera) {
            this.bus = bus;
            this.camera = camera;
            this.audioLevel = 0;
            this.fps = 60;
            this.out = {};
            bus.on('audio:spectral', d => this.audioLevel = d?.level || 0);
        }

        update(dt) {
            this.fps = 1 / dt;
            const phi = PHI_GOLDEN;
            const c = 1;
            const camPosLen = this.camera.position.length();
            this.out.Ec = c*c*phi*(camPosLen*camPosLen*0.00001);
            this.out.lam = this.audioLevel;
            const Omega = THREE.MathUtils.clamp(camPosLen/4000,0,4);
            this.out.Om = Omega*(camPosLen*camPosLen*0.00001);
            this.out.U = -1.0/Math.max(1, camPosLen*camPosLen);
            this.out.Rho = THREE.MathUtils.clamp((60/this.fps)*0.6 + this.audioLevel*0.4, 0, 2);
            this.out.psi = this.out.Ec + this.out.lam + this.out.Om + this.out.U + this.out.Rho;

            const f = n => (n>=0?'+':'')+n.toFixed(3);
            if($('psi_term1')) $('psi_term1').textContent = f(this.out.Ec);
            if($('psi_term2')) $('psi_term2').textContent = f(this.out.lam);
            if($('psi_term3')) $('psi_term3').textContent = f(this.out.Om);
            if($('psi_term4')) $('psi_term4').textContent = f(this.out.U);
        }
    }

    // AtmosphericEntryEffect - Entry visual effects
    class AtmosphericEntryEffect {
        constructor(camera, eventBus) {
            this.camera = camera;
            this.eventBus = eventBus;
            this.isActive = false;
            this.intensity = 0.0;
            this.time = 0.0;

            const plasmaGeo = new THREE.SphereGeometry(1.1, 32, 32);
            const plasmaMat = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0.0 }, intensity: { value: 0.0 } },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float intensity;
                    varying vec2 vUv;

                    float noise(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }

                    void main() {
                        vec2 uv = vUv * 4.0 - 2.0;
                        float plasma = noise(uv * 2.0 + time * 2.0) * 0.5 +
                                       noise(uv * 5.0 - time * 3.0) * 0.3;
                        vec3 color = mix(vec3(1.0, 0.2, 0.0), vec3(1.0, 0.8, 0.2), plasma);
                        float edge = smoothstep(0.8, 1.0, length(vUv * 2.0 - 1.0));
                        gl_FragColor = vec4(color, (1.0 - edge) * intensity * plasma);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                side: THREE.BackSide,
            });
            this.plasmaShield = new THREE.Mesh(plasmaGeo, plasmaMat);
            this.plasmaShield.scale.set(camera.near * 2, camera.near * 2, camera.near * 2);
            this.camera.add(this.plasmaShield);
            this.plasmaShield.visible = false;
        }

        update(delta, camera, planets) {
            this.time += delta;
            let isNearPlanet = false;

            if (planets && planets.length > 0) {
                for (const planet of planets) {
                    const dist = camera.position.distanceTo(planet.position);
                    const entryDist = planet.geometry.parameters.radius * 2.0;
                    if (dist < entryDist) {
                        isNearPlanet = true;
                        this.intensity = Math.min(1.0, this.intensity + delta * 0.5);
                        const shake = this.intensity * 0.1;
                        camera.position.x += (Math.random() - 0.5) * shake;
                        camera.position.y += (Math.random() - 0.5) * shake;
                        break;
                    }
                }
            }

            if (!isNearPlanet) {
                this.intensity = Math.max(0.0, this.intensity - delta * 0.5);
            }

            this.plasmaShield.visible = this.intensity > 0.01;
            if(this.plasmaShield.visible) {
                 this.plasmaShield.material.uniforms.intensity.value = this.intensity;
                 this.plasmaShield.material.uniforms.time.value = this.time;
            }
        }
    }

    // --- MAIN APPLICATION CLASS ---
    class Application {
        constructor() {
            this.initProperties();
            this.initDOM();
            this.initEngine();
            this.bindUI();
        }

        initProperties() {
            this.isRunning = false;
            this.clock = new THREE.Clock();
            this.mouse = new THREE.Vector2(-1, -1);
            this.isMouseDown = false;
            this.directivePrimeActive = false;
            this.directiveState = 'idle';
            this.directiveTimer = 0;
            this.currentView = 'galaxy';

            this.physicsParams = {
                ugrav: 0.55, lambda: 0.25, ec: 1.2,
                li: 0.985, omega: 0.62,
            };
        }

        initDOM() {
            this.ui = {
                blocker: $('blocker'),
                initialScreen: $('initial-screen'),
                finalMessage: $('final-message'),
                startButton: $('start-button'),
                anewButton: $('btn-anew'),
                directiveButton: $('btn-directive-prime'),
                regenerateButton: $('regenerate-button'),
                audioToggle: $('toggle-audio'),
                audioStatus: $('audio-status'),
                mainUI: $('main-ui'),
                hudPanel: $('hud-panel'),
                tabs: document.querySelectorAll(".tab-button"),
                tabContents: document.querySelectorAll(".tab-content"),
                viewModeSelect: $("view-mode-select"),
                actionText: $("action-text"),
                
                hud: {
                    influence: $('hud-influence'), gravity: $('hud-gravity'),
                    chaos: $('hud-chaos'), energy: $('hud-energy'),
                    lifePop: $('hud-life-pop'), lifeForms: $('hud-life-forms'),
                    lifeEnergy: $('hud-life-energy'), shipVel: $('hud-ship-vel'),
                    shipAlt: $('hud-ship-alt'), shipGrav: $('hud-ship-grav'),
                    aiState: $('hud-ai-state'), aiInteraction: $('hud-ai-interaction'),
                },
                
                galaxyHUD: $('galaxy-hud'),
                shipHUD: $('ship-hud'),
                aiHUD: $('ai-hud'),
            };
        }

        initEngine() {
            // Core Three.js setup
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 150000);
            this.camera.position.set(0, 500, 4000);
            this.camera.lookAt(0, 0, 0);
            this.camera.updateProjectionMatrix();
            console.log('[CAMERA] Positioned at:', this.camera.position);

            this.renderer = new THREE.WebGLRenderer({
                canvas: $('main-canvas'),
                antialias: true,
                powerPreference: 'high-performance',
                logarithmicDepthBuffer: true
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            // FIX: Changed from deprecated outputEncoding to outputColorSpace
            this.renderer.outputColorSpace = THREE.SRGBColorSpace;
            this.renderer.toneMapping = THREE.ACESFilmicToneMapping;

            // Controls
            this.orbitControls = new OrbitControls(this.camera, this.renderer.domElement);
            this.orbitControls.enableDamping = true;
            this.orbitControls.dampingFactor = 0.05;
            this.orbitControls.minDistance = 100;
            this.orbitControls.maxDistance = 10000;
            this.orbitControls.target.set(0, 0, 0);
            this.orbitControls.update();
            this.pointerLockControls = new PointerLockControls(this.camera, this.renderer.domElement);

            // Post-processing
            this.composer = new EffectComposer(this.renderer);
            this.composer.addPass(new RenderPass(this.scene, this.camera));
            this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.8, 0.85);
            this.composer.addPass(this.bloomPass);
            this.afterimagePass = new AfterimagePass(0.85);
            this.afterimagePass.enabled = false;
            this.composer.addPass(this.afterimagePass);

            // Advanced post-processing effects
            // God Rays Shader Pass
            const godrayShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
                    exposure: { value: 0.18 },
                    decay: { value: 0.97 },
                    density: { value: 0.96 },
                    weight: { value: 0.4 },
                    samples: { value: 100 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 lightPosition;
                    uniform float exposure;
                    uniform float decay;
                    uniform float density;
                    uniform float weight;
                    uniform int samples;
                    varying vec2 vUv;
                    const int MAX_SAMPLES = 100;

                    void main() {
                        vec2 texCoord = vUv;
                        vec2 deltaTexCoord = texCoord - lightPosition;
                        deltaTexCoord *= 1.0 / float(samples) * density;
                        float illuminationDecay = 1.0;
                        vec4 color = texture2D(tDiffuse, texCoord);

                        for(int i=0; i < MAX_SAMPLES; i++) {
                            if(i >= samples) break;
                            texCoord -= deltaTexCoord;
                            vec4 sampledColor = texture2D(tDiffuse, texCoord);
                            sampledColor *= illuminationDecay * weight;
                            color += sampledColor;
                            illuminationDecay *= decay;
                        }

                        gl_FragColor = color * exposure;
                    }
                `
            };
            this.godrayPass = new ShaderPass(godrayShader);
            this.composer.addPass(this.godrayPass);

            // Gravitational Lensing Shader Pass
            const lensingShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    center: { value: new THREE.Vector2(0.5, 0.5) },
                    scale: { value: 50.0 },
                    strength: { value: 0.05 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    varying vec2 vUv;
                    uniform vec2 center;
                    uniform float scale;
                    uniform float strength;

                    void main() {
                        vec2 toCenter = center - vUv;
                        float dist = length(toCenter);
                        vec2 uv = vUv - toCenter * (1.0 - dist * scale) * strength / dist;
                        gl_FragColor = texture2D(tDiffuse, uv);
                    }
                `
            };
            this.lensingPass = new ShaderPass(lensingShader);
            this.composer.addPass(this.lensingPass);

            // Vignette Shader Pass
            const vignetteShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    darkness: { value: 1.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float darkness;
                    varying vec2 vUv;

                    void main() {
                        vec4 color = texture2D(tDiffuse, vUv);
                        vec2 center = vUv - 0.5;
                        float vignette = 1.0 - dot(center, center) * darkness;
                        color.rgb *= vignette;
                        gl_FragColor = color;
                    }
                `
            };
            this.vignettePass = new ShaderPass(vignetteShader);
            this.composer.addPass(this.vignettePass);

            // Film Grain Shader Pass
            const filmShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    time: { value: 0 },
                    grayscale: { value: 0 },
                    nIntensity: { value: 0.35 },
                    sIntensity: { value: 0.95 },
                    sCount: { value: 4096 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float time;
                    uniform bool grayscale;
                    uniform float nIntensity;
                    uniform float sIntensity;
                    uniform float sCount;
                    varying vec2 vUv;

                    float rand(vec2 co) {
                        return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
                    }

                    void main() {
                        vec4 cTextureScreen = texture2D(tDiffuse, vUv);
                        float dx = rand(vUv + time);
                        vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp(0.1 + dx, 0.0, 1.0);
                        vec2 sc = vec2(sin(vUv.y * sCount), cos(vUv.y * sCount));
                        cResult += cTextureScreen.rgb * vec3(sc.x, sc.y, sc.x) * sIntensity;
                        cResult = cTextureScreen.rgb + clamp(nIntensity, 0.0,1.0) * (cResult - cTextureScreen.rgb);
                        if(grayscale) {
                            cResult = vec3(cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11);
                        }
                        gl_FragColor = vec4(clamp(cResult, 0.0, 1.0), cTextureScreen.a);
                    }
                `
            };
            this.filmPass = new ShaderPass(filmShader);
            this.composer.addPass(this.filmPass);

            // FXAA Anti-Aliasing Pass
            const fxaaShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    resolution: { value: new THREE.Vector2(1.0 / window.innerWidth, 1.0 / window.innerHeight) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 resolution;
                    varying vec2 vUv;

                    void main() {
                        vec4 color = texture2D(tDiffuse, vUv);
                        vec3 rgbNW = texture2D(tDiffuse, vUv + vec2(-1.0, -1.0) * resolution).rgb;
                        vec3 rgbNE = texture2D(tDiffuse, vUv + vec2(1.0, -1.0) * resolution).rgb;
                        vec3 rgbSW = texture2D(tDiffuse, vUv + vec2(-1.0, 1.0) * resolution).rgb;
                        vec3 rgbSE = texture2D(tDiffuse, vUv + vec2(1.0, 1.0) * resolution).rgb;
                        vec3 rgbM = color.rgb;
                        vec3 luma = vec3(0.299, 0.587, 0.114);
                        float lumaNW = dot(rgbNW, luma);
                        float lumaNE = dot(rgbNE, luma);
                        float lumaSW = dot(rgbSW, luma);
                        float lumaSE = dot(rgbSE, luma);
                        float lumaM = dot(rgbM, luma);
                        float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
                        float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
                        vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));
                        float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * 0.03125, 0.0078125);
                        float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
                        dir = min(vec2(8.0), max(vec2(-8.0), dir * rcpDirMin)) * resolution;
                        vec3 rgbA = 0.5 * (texture2D(tDiffuse, vUv + dir * (1.0 / 3.0 - 0.5)).rgb + texture2D(tDiffuse, vUv + dir * (2.0 / 3.0 - 0.5)).rgb);
                        vec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tDiffuse, vUv + dir * -0.5).rgb + texture2D(tDiffuse, vUv + dir * 0.5).rgb);
                        float lumaB = dot(rgbB, luma);
                        if ((lumaB < lumaMin) || (lumaB > lumaMax)) {
                            gl_FragColor = vec4(rgbA, color.a);
                        } else {
                            gl_FragColor = vec4(rgbB, color.a);
                        }
                    }
                `
            };
            this.fxaaPass = new ShaderPass(fxaaShader);
            this.fxaaPass.enabled = true;
            this.composer.addPass(this.fxaaPass);

            // Pixelation Pass
            const pixelationShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    pixelSize: { value: 4.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 resolution;
                    uniform float pixelSize;
                    varying vec2 vUv;

                    void main() {
                        vec2 dxy = pixelSize / resolution;
                        vec2 coord = dxy * floor(vUv / dxy);
                        gl_FragColor = texture2D(tDiffuse, coord);
                    }
                `
            };
            this.pixelationPass = new ShaderPass(pixelationShader);
            this.pixelationPass.enabled = false;
            this.composer.addPass(this.pixelationPass);

            // Toon/Cel Shading Pass
            const toonShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    steps: { value: 4.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float steps;
                    varying vec2 vUv;

                    void main() {
                        vec4 color = texture2D(tDiffuse, vUv);
                        float luminance = 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;
                        luminance = floor(luminance * steps) / steps;
                        color.rgb = color.rgb * (luminance / max(0.001, 0.299 * color.r + 0.587 * color.g + 0.114 * color.b));
                        gl_FragColor = color;
                    }
                `
            };
            this.toonPass = new ShaderPass(toonShader);
            this.toonPass.enabled = false;
            this.composer.addPass(this.toonPass);

            // RGB Shift/Chromatic Aberration Pass
            const rgbShiftShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    amount: { value: 0.003 },
                    angle: { value: 0.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float amount;
                    uniform float angle;
                    varying vec2 vUv;

                    void main() {
                        vec2 offset = amount * vec2(cos(angle), sin(angle));
                        vec4 cr = texture2D(tDiffuse, vUv + offset);
                        vec4 cga = texture2D(tDiffuse, vUv);
                        vec4 cb = texture2D(tDiffuse, vUv - offset);
                        gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);
                    }
                `
            };
            this.rgbShiftPass = new ShaderPass(rgbShiftShader);
            this.rgbShiftPass.enabled = false;
            this.composer.addPass(this.rgbShiftPass);

            // Swirl/Vortex Distortion Pass
            const swirlShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    center: { value: new THREE.Vector2(0.5, 0.5) },
                    radius: { value: 0.5 },
                    angle: { value: 0.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 center;
                    uniform float radius;
                    uniform float angle;
                    varying vec2 vUv;

                    void main() {
                        vec2 uv = vUv - center;
                        float dist = length(uv);
                        if (dist < radius) {
                            float percent = (radius - dist) / radius;
                            float theta = percent * percent * angle;
                            float s = sin(theta);
                            float c = cos(theta);
                            uv = vec2(
                                uv.x * c - uv.y * s,
                                uv.x * s + uv.y * c
                            );
                        }
                        uv += center;
                        gl_FragColor = texture2D(tDiffuse, uv);
                    }
                `
            };
            this.swirlPass = new ShaderPass(swirlShader);
            this.swirlPass.enabled = false;
            this.composer.addPass(this.swirlPass);

            console.log('[PostProcessing] Advanced shader passes initialized (Bloom, Godrays, Lensing, Afterimage, Vignette, Film, FXAA, Pixelation, Toon, RGB Shift, Swirl)');

            // PHASE 1 SYSTEMS - Initialize EventBus and DataLogger first
            this.eventBus = new EventBus();
            this.dataLogger = new DataLogger(this.eventBus);

            // Initialize sensor systems
            this.sensorManager = new SensoryInputManager(this.eventBus, this);

            // Initialize external data and ML systems
            this.externalData = new ExternalDataManager(this.eventBus);
            this.mlCore = new MachineLearningCore(this.eventBus, this);

            // Initialize AI and decision-making
            this.cosmicAI = new CosmicAwarenessAgent(this.eventBus, this.dataLogger);

            // Initialize CST 12D Computation Engine
            this.cstCompute = new CSTComputeEngine(this.eventBus, this.dataLogger);

            // Initialize quantum and procedural systems
            this.quantumEvents = new QuantumEventManager(this.eventBus, this, this.scene, this.camera);
            this.proceduralGen = new ProceduralGenerationEngine(this.scene, this.eventBus);

            // CRITICAL: Populate the universe with celestial objects
            this.proceduralGen.populateUniverse();

            setTimeout(() => {
                console.log('═══ VERIFICATION ═══');
                console.log('Scene children:', this.scene.children.length);
                console.log('Celestial objects:', this.proceduralGen.celestialObjects.length);
                console.log('Camera:', this.camera.position);
                console.log('═══════════════════');
            }, 1000);

            // Legacy systems (keep for compatibility)
            this.audio = new AudioManager(this.ui.audioToggle, this.ui.audioStatus);
            this.solarSystem = new SolarSystemManager(this.scene);
            this.singularity = new Singularity(this.scene);
            this.cosmos = new CosmosParticleSystem(this.scene);
            this.aiLife = new AILifeParticleSystem(this.scene);
            this.spaceship = new SpaceshipController(this.scene);
            this.aiModel = new QuantumAIModel();
            this.particlizer = new Particlizer(this.scene);

            // Initialize new unified systems (from merge)
            const seed = cyrb128(Date.now().toString() + navigator.userAgent);
            this.prng = sfc32(...seed);
            // FIX: Changed this.bus to this.eventBus to match the EventBus instance initialized above
            this.surfaceManager = new SurfaceManager(this.eventBus, this.scene, this.prng);
            this.objectLibrary = new ObjectLibrary(this.eventBus, this.scene, this.prng);
            this.volumetricDust = new VolumetricDust(this.scene, this.camera);
            this.audioReactive = new AudioReactiveSystem(this.scene, this.eventBus);
            this.memoryEcho = new MemoryEcho(this.scene, this.camera, this.eventBus);
            this.soundBrush = new SoundBrush(this.scene, this.camera, this.eventBus);
            this.psiOverlay = new PsiOverlay(this.eventBus, this.camera);
            this.atmosphericEntry = new AtmosphericEntryEffect(this.camera, this.eventBus);

            // Initialize ProceduralAudioEngine
            const audioListener = this.camera.children.find(c => c.type === 'AudioListener');
            this.proceduralAudio = new ProceduralAudioEngine(audioListener);
            console.log('[ProceduralAudio] Engine initialized');

            // Background star field
            this.initBackgroundStars();

            // Event listeners
            window.addEventListener('resize', this.onResize.bind(this));
            window.addEventListener('mousedown', this.onMouseDown.bind(this));
            window.addEventListener('mouseup', this.onMouseUp.bind(this));
            window.addEventListener('mousemove', this.onMouseMove.bind(this));
            document.addEventListener('keydown', (e) => this.spaceship.keys[e.code] = true);
            document.addEventListener('keyup', (e) => this.spaceship.keys[e.code] = false);

            // Complete Hotkey System
            this.devMode = false;
            document.addEventListener('keydown', (e) => {
                // Prevent default only for hotkeys we handle
                const key = e.key.toLowerCase();

                // H - Toggle UI visibility
                if (key === 'h' && !e.repeat) {
                    e.preventDefault();
                    const controlPanel = document.getElementById('control-panel');
                    if (controlPanel) {
                        const isVisible = controlPanel.style.display !== 'none';
                        controlPanel.style.display = isVisible ? 'none' : 'block';
                        console.log(`UI ${isVisible ? 'hidden' : 'visible'}`);
                        this.eventBus.emit('ui:toggle', { visible: !isVisible });
                    }
                }

                // Ctrl+Alt+D - Dev Mode toggle
                if (e.ctrlKey && e.altKey && key === 'd' && !e.repeat) {
                    e.preventDefault();
                    this.devMode = !this.devMode;
                    console.log(`Dev Mode: ${this.devMode ? 'ON' : 'OFF'}`);
                    this.eventBus.emit('dev:mode', { active: this.devMode });

                    // Show additional debug info in dev mode
                    if (this.devMode) {
                        console.log('Dev Mode Features:');
                        console.log('- Performance stats visible');
                        console.log('- Event bus logging enabled');
                        console.log('- Shader uniform inspection available');
                    }
                }

                // Number keys 1-5 - View presets
                if (key >= '1' && key <= '5' && !e.repeat && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    switch(key) {
                        case '1':
                            this.setView('galaxy');
                            console.log('View: Galaxy');
                            break;
                        case '2':
                            this.setView('solar_system');
                            console.log('View: Solar System');
                            break;
                        case '3':
                            this.setView('spaceship');
                            console.log('View: Spaceship');
                            break;
                        case '4':
                            if (this.surfaceManager) {
                                this._applyMode('surface');
                                console.log('Mode: Surface');
                            }
                            break;
                        case '5':
                            this._applyMode('echo');
                            console.log('Mode: Echo');
                            break;
                    }
                }

                // Mode switching hotkeys (Ctrl+U/S/E)
                if (e.ctrlKey && !e.repeat) {
                    if (key === 'u') {
                        e.preventDefault();
                        this._applyMode('universe');
                        console.log('Mode: Universe');
                    } else if (key === 's') {
                        e.preventDefault();
                        if (this.surfaceManager) {
                            this._applyMode('surface');
                            console.log('Mode: Surface');
                        }
                    } else if (key === 'e') {
                        e.preventDefault();
                        this._applyMode('echo');
                        console.log('Mode: Echo');
                    }
                }

                // Post-processing effect toggles (Alt+Key)
                if (e.altKey && !e.repeat) {
                    switch(key) {
                        case 'b': // Bloom
                            e.preventDefault();
                            if (this.bloomPass) {
                                this.bloomPass.enabled = !this.bloomPass.enabled;
                                console.log(`Bloom: ${this.bloomPass.enabled ? 'ON' : 'OFF'}`);
                            }
                            break;
                        case 'g': // Godrays
                            e.preventDefault();
                            if (this.godrayPass) {
                                this.godrayPass.enabled = !this.godrayPass.enabled;
                                console.log(`Godrays: ${this.godrayPass.enabled ? 'ON' : 'OFF'}`);
                            }
                            break;
                        case 'l': // Lensing
                            e.preventDefault();
                            if (this.lensingPass) {
                                this.lensingPass.enabled = !this.lensingPass.enabled;
                                console.log(`Lensing: ${this.lensingPass.enabled ? 'ON' : 'OFF'}`);
                            }
                            break;
                        case 'm': // Motion blur (afterimage)
                            e.preventDefault();
                            if (this.afterimagePass) {
                                this.afterimagePass.enabled = !this.afterimagePass.enabled;
                                console.log(`Motion Blur: ${this.afterimagePass.enabled ? 'ON' : 'OFF'}`);
                            }
                            break;
                        case 'v': // Vignette
                            e.preventDefault();
                            if (this.vignettePass) {
                                this.vignettePass.enabled = !this.vignettePass.enabled;
                                console.log(`Vignette: ${this.vignettePass.enabled ? 'ON' : 'OFF'}`);
                            }
                            break;
                        case 'f': // Film grain
                            e.preventDefault();
                            if (this.filmPass) {
                                this.filmPass.enabled = !this.filmPass.enabled;
                                console.log(`Film Grain: ${this.filmPass.enabled ? 'ON' : 'OFF'}`);
                            }
                            break;
                        case 'p': // Pixelation
                            e.preventDefault();
                            if (this.pixelationPass) {
                                this.pixelationPass.enabled = !this.pixelationPass.enabled;
                                console.log(`Pixelation: ${this.pixelationPass.enabled ? 'ON' : 'OFF'}`);
                            }
                            break;
                        case 't': // Toon shading
                            e.preventDefault();
                            if (this.toonPass) {
                                this.toonPass.enabled = !this.toonPass.enabled;
                                console.log(`Toon Shading: ${this.toonPass.enabled ? 'ON' : 'OFF'}`);
                            }
                            break;
                        case 'r': // RGB shift
                            e.preventDefault();
                            if (this.rgbShiftPass) {
                                this.rgbShiftPass.enabled = !this.rgbShiftPass.enabled;
                                console.log(`RGB Shift: ${this.rgbShiftPass.enabled ? 'ON' : 'OFF'}`);
                            }
                            break;
                        case 'w': // Swirl
                            e.preventDefault();
                            if (this.swirlPass) {
                                this.swirlPass.enabled = !this.swirlPass.enabled;
                                console.log(`Swirl: ${this.swirlPass.enabled ? 'ON' : 'OFF'}`);
                            }
                            break;
                    }
                }

                // C - Cleanup scene
                if (key === 'c' && e.ctrlKey && e.shiftKey && !e.repeat) {
                    e.preventDefault();
                    this.cleanupScene();
                    console.log('Scene cleanup triggered');
                }
            });

            console.log('[Hotkeys] Complete hotkey system initialized');
            console.log('Hotkeys: H=Toggle UI | 1-5=Views | Ctrl+U/S/E=Modes | Alt+B/G/L/M/V/F/P/T/R/W=Effects | Ctrl+Alt+D=Dev | Ctrl+Shift+C=Cleanup');

            // Wire event listeners for Phase 1 systems
            this.setupEventHandlers();
        }

        initBackgroundStars() {
            // Simple background star field (different from quantum soul dust)
            const starGeo = new THREE.BufferGeometry();
            const starCount = 10000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = 5000 + Math.random() * 40000;

                positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);

                // Random star colors (white, blue, red, yellow)
                const colorType = Math.random();
                if (colorType < 0.7) {
                    // White
                    colors[i3] = colors[i3 + 1] = colors[i3 + 2] = 1;
                } else if (colorType < 0.85) {
                    // Blue
                    colors[i3] = 0.7; colors[i3 + 1] = 0.8; colors[i3 + 2] = 1;
                } else if (colorType < 0.95) {
                    // Red
                    colors[i3] = 1; colors[i3 + 1] = 0.5; colors[i3 + 2] = 0.4;
                } else {
                    // Yellow
                    colors[i3] = 1; colors[i3 + 1] = 1; colors[i3 + 2] = 0.7;
                }
            }

            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starMat = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            this.backgroundStars = new THREE.Points(starGeo, starMat);
            this.scene.add(this.backgroundStars);
        }

        setupEventHandlers() {
            // Listen to sensor updates
            this.eventBus.on('sensor:audio:update', (data) => {
                this.dataLogger.logTelemetry('audio', data);
                this.cosmicAI.learn({ audio: data });
            });

            this.eventBus.on('ml:detection', (data) => {
                this.dataLogger.logTelemetry('ml', data);
                this.cosmicAI.learn({ ml: data.detections });
            });

            this.eventBus.on('external:all:fetched', (data) => {
                this.dataLogger.logTelemetry('external', data);
                this.cosmicAI.learn({ external: data });
            });

            // Listen to AI state changes
            this.eventBus.on('ai:influence:generated', (influence) => {
                $('ai-intention').textContent = `Generate universe with gravity: ${influence.gravity.toFixed(2)}, chaos: ${influence.chaos.toFixed(2)}`;
            });

            // Listen to procedural generation events
            this.eventBus.on('procedural:universe:generated', (data) => {
                $('system-status-readout').textContent = `STATUS: Universe generated (${data.stars} stars, ${data.planets} planets)`;
            });
        }

        bindUI() {
            Object.keys(this.physicsParams).forEach(p => {
                const input = $(`in-${p}`);
                const valueDisplay = $(`val-${p}`);
                input.addEventListener('input', () => {
                    this.physicsParams[p] = parseFloat(input.value);
                    valueDisplay.textContent = this.physicsParams[p].toFixed(p === 'li' ? 3 : 2);
                });
            });
            
            this.ui.startButton.addEventListener('click', this.start.bind(this));
            this.ui.anewButton.addEventListener('click', this.reset.bind(this));
            this.ui.directiveButton.addEventListener('click', this.activateDirectivePrime.bind(this));

            // Wire Regenerate button to Phase 1 systems
            this.ui.regenerateButton.addEventListener('click', () => {
                const influence = this.cosmicAI.generateInfluence();
                this.proceduralGen.generateUniverse(influence);
            });
            
            this.ui.tabs.forEach(tab => {
                tab.addEventListener("click", () => {
                    this.ui.tabs.forEach(t => t.classList.remove("active"));
                    this.ui.tabContents.forEach(tc => tc.classList.remove("active"));
                    tab.classList.add("active");
                    $(`tab-${tab.dataset.tab}`).classList.add("active");
                });
            });
            
            this.ui.viewModeSelect.addEventListener('change', (e) => this.setView(e.target.value));

            $('video-particlize-button').addEventListener('click', () => {
                console.log("Live particlizer needs camera access logic to be implemented.");
            });
            $('file-upload').addEventListener('change', (e) => {
                if(e.target.files[0]) this.particlizer.particlize(e.target.files[0]);
            });

            // Wire new unified system UI controls
            // Motion Blur controls
            const motionBlurToggle = $('motion-blur-toggle');
            const motionBlurSlider = $('in-motion-blur');
            const motionBlurValue = $('val-motion-blur');
            if(motionBlurToggle) {
                motionBlurToggle.addEventListener('change', (e) => {
                    if(this.afterimagePass) this.afterimagePass.enabled = e.target.checked;
                });
            }
            if(motionBlurSlider) {
                motionBlurSlider.addEventListener('input', (e) => {
                    if(this.afterimagePass) this.afterimagePass.uniforms.damp.value = parseFloat(e.target.value);
                    if(motionBlurValue) motionBlurValue.textContent = e.target.value;
                });
            }

            // Data & Telemetry download buttons
            const downloadLedger = $('download-ledger-button');
            const downloadTelemetry = $('download-telemetry-button');
            if(downloadLedger) {
                downloadLedger.addEventListener('click', () => this.dataLogger.download());
            }
            if(downloadTelemetry) {
                downloadTelemetry.addEventListener('click', () => this.dataLogger.downloadTelemetry());
            }

            // Telemetry filter
            const telemetryFilter = $('telemetry-filter');
            if(telemetryFilter) {
                telemetryFilter.addEventListener('input', (e) => {
                    const filter = e.target.value.toLowerCase();
                    const content = $('telemetry-log-content');
                    if(!content) return;
                    const entries = content.querySelectorAll('.telemetry-entry');
                    entries.forEach(entry => {
                        const text = entry.textContent.toLowerCase();
                        entry.style.display = text.includes(filter) ? 'block' : 'none';
                    });
                });
            }

            // Surface build trigger
            if(this.surfaceManager) {
                this.surfaceManager.buildSurface();
            }
        }

        async start() {
            if (this.isRunning) return;
            this.isRunning = true;
            this.ui.blocker.style.opacity = '0';
            setTimeout(() => this.ui.blocker.style.display = 'none', 500);

            // FIX: Resume Tone.js AudioContext after user gesture
            if (typeof Tone !== 'undefined' && Tone.context) {
                try {
                    await Tone.start();
                    console.log('[Audio] Tone.js AudioContext started successfully');
                } catch (err) {
                    console.warn('[Audio] Failed to start Tone.js context:', err);
                }
            }

            // Initialize Phase 1 systems
            await this.sensorManager.initializeAll();
            await this.mlCore.initialize();

            // Fetch external data (non-blocking)
            this.externalData.fetchAll().catch(err => console.warn('External data fetch failed:', err));

            // Initialize quantum and procedural systems
            this.quantumEvents.initialize();

            // Generate initial AI seed
            const aiSeed = this.cosmicAI.generateSeed();
            this.dataLogger.log('events', { name: 'Genesis Seed', data: aiSeed });

            // Generate initial universe using AI
            const initialInfluence = this.cosmicAI.generateInfluence();
            this.proceduralGen.generateUniverse(initialInfluence);

            // Initialize legacy systems
            this.solarSystem.init();
            this.cosmos.init(this.physicsParams);
            this.aiLife.init();

            this.eventBus.emit('app:started', { timestamp: Date.now() });

            // Initialize PSI overlay and seed visualizer
            initPSIOverlay();

            this.animate();
        }
        
        reset() {
            window.location.reload();
        }

        activateDirectivePrime() {
            if (this.directivePrimeActive) return;
            this.setView('galaxy');
            this.directivePrimeActive = true;
            this.directiveState = 'supernova';
            this.directiveTimer = 0;
            this.orbitControls.enabled = false;
        }
        
        animate() {
            if (!this.isRunning && !this.directivePrimeActive) return;
            requestAnimationFrame(this.animate.bind(this));

            const dt = Math.min(this.clock.getDelta(), 0.1);
            const audioData = this.audio.getAnalysis();

            this.aiModel.learn({
                audio: audioData,
                ship: this.spaceship.getState(),
                galaxy: this.physicsParams,
                life: this.aiLife.getStats(),
            });
            const aiState = this.aiModel.update(dt);
            this.updateAIHUD(aiState);

            if (this.directivePrimeActive) {
                this.updateDirectivePrime(dt, audioData);
            } else {
                 this.updateSimulation(dt, audioData);
            }
            
            if (this.currentView === 'spaceship' || this.currentView === 'cockpit') {
                const celestialBodies = this.solarSystem.getCelestialBodies();
                this.spaceship.update(dt, celestialBodies);
                this.spaceship.updateCamera(this.camera);
                this.updateShipHUD();
            } else {
                this.orbitControls.update();
            }

            if (this.orbitControls) {
                this.orbitControls.update();
            }

            this.composer.render();
        }

        updateSimulation(dt, audioData) {
            this.physicsParams.ugrav = lerp(parseFloat($('in-ugrav').value), parseFloat($('in-ugrav').value) + audioData.bass * 2.5, 0.1);
            this.physicsParams.lambda = lerp(parseFloat($('in-lambda').value), parseFloat($('in-lambda').value) + audioData.mids * 1.5, 0.1);
            this.physicsParams.ec = lerp(parseFloat($('in-ec').value), parseFloat($('in-ec').value) + audioData.treble * 1.0, 0.1);

            // Update Phase 1 systems
            this.sensorManager.update();
            this.quantumEvents.update(dt);
            this.proceduralGen.update(dt);
            this.cosmicAI.tick(Date.now());

            // Update post-processing shader uniforms
            const elapsed = this.clock.getElapsedTime();

            if (this.filmPass && this.filmPass.uniforms.time) {
                this.filmPass.uniforms.time.value = elapsed;
            }

            if (this.godrayPass && this.proceduralGen.celestialObjects.length > 0) {
                // Update god ray position to track active star
                const starObj = this.proceduralGen.celestialObjects.find(obj => obj.type === 'star');
                if (starObj && starObj.mesh) {
                    const starScreenPos = starObj.mesh.position.clone();
                    starScreenPos.project(this.camera);
                    this.godrayPass.uniforms.lightPosition.value.set(
                        (starScreenPos.x + 1) / 2,
                        (starScreenPos.y + 1) / 2
                    );
                }
            }

            if (this.lensingPass) {
                // Update lensing effect based on nearest black hole
                const blackHole = this.proceduralGen.celestialObjects.find(obj => obj.type === 'blackhole');
                if (blackHole && blackHole.mesh) {
                    const bhScreenPos = blackHole.mesh.position.clone();
                    bhScreenPos.project(this.camera);
                    this.lensingPass.uniforms.center.value.set(
                        (bhScreenPos.x + 1) / 2,
                        (bhScreenPos.y + 1) / 2
                    );

                    // Adjust strength based on distance
                    const distance = this.camera.position.distanceTo(blackHole.mesh.position);
                    this.lensingPass.uniforms.strength.value = Math.max(0, 0.1 - distance / 10000);
                }
            }

            // Compute CST 12D state vectors and ψ
            const allEntities = [
                ...this.cosmos.particles,
                ...this.aiLife.particles,
                ...(this.quantumEvents.getParticles ? this.quantumEvents.getParticles() : [])
            ];
            const sensorData = { audio: audioData };
            const cstData = this.cstCompute.computePsi(this.physicsParams, sensorData, allEntities);

            // Update entity state vectors
            allEntities.forEach(entity => {
                this.cstCompute.updateEntityState(entity, dt);
            });

            // Update legacy systems
            if (this.currentView === 'galaxy') {
                this.singularity.update(this.physicsParams, this.isMouseDown);
            }
            this.cosmos.update(dt, this.physicsParams, this.mouse, this.isMouseDown);
            this.aiLife.update(dt, audioData, this.mouse, this.isMouseDown);
            this.solarSystem.update(dt);
            this.particlizer.update(dt);

            // Update new unified systems
            this.objectLibrary.update(dt);
            this.audioReactive.update(dt, audioData);
            this.memoryEcho.update(dt);
            this.soundBrush.update(dt);
            this.psiOverlay.update(dt);
            this.atmosphericEntry.update(dt, this.camera, this.solarSystem.planets || []);
            this.volumetricDust.update(performance.now() / 1000, 1/dt, this.physicsParams.lambda);

            // Periodic ML detection (every 2 seconds)
            if (!this.lastMLDetection || Date.now() - this.lastMLDetection > 2000) {
                this.lastMLDetection = Date.now();
                const videoElement = this.sensorManager.sensors.video.element;
                if (videoElement && this.sensorManager.sensors.video.active) {
                    this.mlCore.detect(videoElement);
                }
            }

            this.updateGalaxyHUD(this.aiLife.getStats());

            // Update Telemetry UI
            this.updateTelemetryUI();

            // Update Surface HUD if in surface mode
            if (this.currentMode === 'surface' || this.ui.surfaceHUD?.style.display === 'block') {
                this.updateSurfaceHUD();
            }

            // Update additional post-processing uniforms
            if (this.rgbShiftPass && this.rgbShiftPass.enabled) {
                this.rgbShiftPass.uniforms.angle.value = elapsed * 0.5;
                this.rgbShiftPass.uniforms.amount.value = 0.003 + audioData.bass * 0.002;
            }

            if (this.swirlPass && this.swirlPass.enabled) {
                this.swirlPass.uniforms.angle.value = Math.sin(elapsed * 0.5) * 3.14;
                this.swirlPass.uniforms.radius.value = 0.3 + audioData.mids * 0.2;
            }

            if (this.vignettePass) {
                this.vignettePass.uniforms.darkness.value = 0.5 + audioData.bass * 0.3;
            }

            if (this.bloomPass) {
                this.bloomPass.threshold = Math.max(0, 0.85 - audioData.treble * 0.2);
                this.bloomPass.strength = 1.2 + audioData.mids * 0.5;
            }
        }
        
        updateDirectivePrime(dt, audioData) {
            this.directiveTimer += dt;
            switch (this.directiveState) {
                case 'supernova':
                    this.physicsParams.ugrav = -10.0;
                    if (this.directiveTimer > 3) { this.directiveTimer = 0; this.directiveState = 'convergence'; }
                    break;
                case 'convergence':
                    this.physicsParams.ugrav = lerp(-10.0, 50.0, this.directiveTimer / 8);
                    if (this.directiveTimer > 8) { this.directiveTimer = 0; this.directiveState = 'crystal'; this.aiLife.formNeuralCrystal(); }
                    break;
                case 'crystal':
                    this.physicsParams.ugrav = 50.0;
                    if (this.directiveTimer > 10) { this.directiveTimer = 0; this.directiveState = 'final'; }
                    break;
                case 'final':
                    this.ui.blocker.style.display = 'flex';
                    this.ui.initialScreen.style.display = 'none';
                    this.ui.finalMessage.style.display = 'flex';
                    this.ui.blocker.style.opacity = '1';
                    this.directiveState = 'finished';
                    this.isRunning = false;
                    break;
            }
            this.singularity.update(this.physicsParams, false);
            this.cosmos.update(dt, this.physicsParams, this.mouse, false);
            this.aiLife.update(dt, audioData, this.mouse, false, this.directiveState === 'crystal');
        }
        
        updateGalaxyHUD(lifeStats) {
            this.ui.hud.influence.textContent = this.isMouseDown ? 'Active' : 'Idle';
            this.ui.hud.gravity.textContent = this.physicsParams.ugrav.toFixed(2);
            this.ui.hud.chaos.textContent = this.physicsParams.lambda.toFixed(2);
            this.ui.hud.energy.textContent = this.physicsParams.ec.toFixed(2);
            this.ui.hud.lifePop.textContent = lifeStats.population;
            this.ui.hud.lifeForms.textContent = lifeStats.formations;
            this.ui.hud.lifeEnergy.textContent = lifeStats.energy;
        }
        
        updateShipHUD() {
            const shipState = this.spaceship.getState();
            this.ui.hud.shipVel.textContent = `${shipState.velocity.toFixed(0)} km/s`;
            if (shipState.gravSource) {
                this.ui.hud.shipGrav.textContent = shipState.gravSource.name;
                this.ui.hud.shipAlt.textContent = `${shipState.altitude.toFixed(0)} km`;
            } else {
                this.ui.hud.shipGrav.textContent = 'Deep Space';
                this.ui.hud.shipAlt.textContent = 'N/A';
            }
        }

        updateAIHUD(aiState) {
            this.ui.hud.aiState.textContent = aiState.dominantState;
            this.ui.hud.aiInteraction.textContent = aiState.interaction;
        }

        /**
         * updateTelemetryUI - Auto-update telemetry log from EventBus history
         */
        updateTelemetryUI() {
            const telemetryContent = document.getElementById('telemetry-log-content');
            const telemetryFilter = document.getElementById('telemetry-filter');

            if (!telemetryContent || !this.eventBus) return;

            const filter = telemetryFilter ? telemetryFilter.value.toLowerCase() : '';
            const recentEvents = this.eventBus.history.slice(-20); // Last 20 events

            let output = '';
            recentEvents.forEach(event => {
                const eventStr = `[${new Date(event.timestamp).toLocaleTimeString()}] ${event.name}`;
                if (!filter || eventStr.toLowerCase().includes(filter)) {
                    output += eventStr + '\n';
                }
            });

            telemetryContent.textContent = output || 'No telemetry events yet...';

            // Auto-scroll to bottom
            telemetryContent.scrollTop = telemetryContent.scrollHeight;
        }

        /**
         * updateSurfaceHUD - Auto-update surface environment HUD from SurfaceManager
         */
        updateSurfaceHUD() {
            if (!this.surfaceManager || !this.ui.surfaceHUD) return;

            const hudOcean = document.getElementById('hud-ocean');
            const hudCloud = document.getElementById('hud-cloud');
            const hudVegetation = document.getElementById('hud-vegetation');
            const hudSurfaceAlt = document.getElementById('hud-surface-alt');

            if (hudOcean && this.surfaceManager.params) {
                hudOcean.textContent = (this.surfaceManager.params.oceanRoughness || 0).toFixed(2);
            }
            if (hudCloud && this.surfaceManager.params) {
                hudCloud.textContent = `${Math.round((this.surfaceManager.params.cloudCoverage || 0) * 100)}%`;
            }
            if (hudVegetation && this.surfaceManager.params) {
                hudVegetation.textContent = `${Math.round((this.surfaceManager.params.vegetation || 0) * 100)}%`;
            }
            if (hudSurfaceAlt) {
                // Calculate altitude from camera position
                const altitude = this.camera.position.y;
                hudSurfaceAlt.textContent = `${altitude.toFixed(0)} m`;
            }
        }

        setView(view) {
            this.currentView = view;

            const isGalaxy = view === 'galaxy';
            const isSolar = view === 'solar_system';
            const isShip = view === 'spaceship' || view === 'cockpit';

            // Make particles always visible
            this.cosmos.show(true);
            this.aiLife.show(true);

            // Toggle visibility of mode-specific systems
            this.solarSystem.show(isSolar || isShip);
            this.singularity.show(isGalaxy);
            this.spaceship.show(isShip);

            this.ui.galaxyHUD.style.display = isGalaxy ? 'block' : 'none';
            this.ui.shipHUD.style.display = isShip ? 'block' : 'none';

            this.orbitControls.enabled = isGalaxy || isSolar;
            if (isShip) {
                this.pointerLockControls.lock();
                this.spaceship.reset();
            } else {
                if(this.pointerLockControls.isLocked) this.pointerLockControls.unlock();
            }

            if (isGalaxy) {
                this.orbitControls.minDistance = 500;
                this.orbitControls.maxDistance = 10000;
                this.camera.position.set(0, 0, 3500);
                this.orbitControls.target.set(0, 0, 0);
                this.ui.actionText.textContent = 'Hold Left-Click to exert influence.';
            } else if (isSolar) {
                this.orbitControls.minDistance = 100;
                this.orbitControls.maxDistance = 40000;
                this.camera.position.set(0, 8000, 20000);
                this.orbitControls.target.set(0, 0, 0);
                this.ui.actionText.textContent = 'Observe the procedurally generated system.';
            } else if (isShip) {
                 this.ui.actionText.textContent = 'W/S: Thrust | A/D: Yaw | Q/E: Roll | Mouse: Pitch/Yaw';
            }
        }

        /**
         * _applyMode - Non-destructive mode switching for universe/surface/echo modes
         * @param {string} mode - 'universe', 'surface', or 'echo'
         */
        _applyMode(mode) {
            this.currentMode = mode;

            const isUniverse = mode === 'universe';
            const isSurface = mode === 'surface';
            const isEcho = mode === 'echo';

            // Emit mode change event
            this.eventBus.emit('mode:change', { mode, timestamp: Date.now() });

            // Toggle visibility of mode-specific systems (non-destructive)
            if (isUniverse) {
                // Show universe systems
                this.cosmos.show(true);
                this.aiLife.show(true);
                this.singularity.show(true);
                this.solarSystem.show(true);
                if (this.surfaceManager) this.surfaceManager.hide();

                // Hide mode-specific HUDs
                if (this.ui.surfaceHUD) this.ui.surfaceHUD.style.display = 'none';

                // Reset to galaxy view
                this.setView('galaxy');
                this.ui.actionText.textContent = 'Universe Mode: Exploring the cosmos';

            } else if (isSurface) {
                // Show surface systems
                if (this.surfaceManager) {
                    this.surfaceManager.show();
                    // Position camera for surface view
                    this.camera.position.set(0, 1000, 2000);
                    this.orbitControls.target.set(0, 0, 0);
                    this.orbitControls.minDistance = 100;
                    this.orbitControls.maxDistance = 5000;
                }

                // Show surface HUD
                if (this.ui.surfaceHUD) this.ui.surfaceHUD.style.display = 'block';

                // Hide other systems (but don't destroy)
                this.singularity.show(false);
                this.spaceship.show(false);

                this.ui.actionText.textContent = 'Surface Mode: Exploring planetary environment';

            } else if (isEcho) {
                // Echo mode - visualize audio/physics feedback loops
                this.cosmos.show(true);
                this.aiLife.show(true);

                // Enable special visualizations
                if (this.bloomPass) this.bloomPass.enabled = true;
                if (this.afterimagePass) this.afterimagePass.enabled = true;
                if (this.godrayPass) this.godrayPass.enabled = true;

                this.ui.actionText.textContent = 'Echo Mode: Audio-reactive feedback visualization';
            }

            console.log(`Mode switched to: ${mode}`);
        }

        /**
         * CleanupScene - Removes prior generated meshes only; engines persist
         * Safely disposes geometries and materials to prevent memory leaks
         */
        cleanupScene() {
            console.log('Cleaning up scene meshes...');

            // Clean up procedurally generated objects
            const objectsToRemove = [];

            this.scene.traverse((obj) => {
                // Only remove meshes that are procedurally generated
                // Preserve engine systems (they have show/hide methods)
                if (obj.isMesh && !obj.userData.isEngine) {
                    objectsToRemove.push(obj);
                }
            });

            objectsToRemove.forEach((obj) => {
                // Dispose geometry
                if (obj.geometry) {
                    obj.geometry.dispose();
                }

                // Dispose material(s)
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => {
                            if (mat.map) mat.map.dispose();
                            if (mat.normalMap) mat.normalMap.dispose();
                            if (mat.roughnessMap) mat.roughnessMap.dispose();
                            if (mat.metalnessMap) mat.metalnessMap.dispose();
                            mat.dispose();
                        });
                    } else {
                        if (obj.material.map) obj.material.map.dispose();
                        if (obj.material.normalMap) obj.material.normalMap.dispose();
                        if (obj.material.roughnessMap) obj.material.roughnessMap.dispose();
                        if (obj.material.metalnessMap) obj.material.metalnessMap.dispose();
                        obj.material.dispose();
                    }
                }

                // Remove from parent
                if (obj.parent) {
                    obj.parent.remove(obj);
                }
            });

            // Clean up surface manager generated objects
            if (this.surfaceManager && this.surfaceManager.surfaceGroup) {
                const surfaceObjects = [];
                this.surfaceManager.surfaceGroup.traverse((obj) => {
                    if (obj.isMesh) {
                        surfaceObjects.push(obj);
                    }
                });

                surfaceObjects.forEach((obj) => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) {
                            obj.material.forEach(mat => mat.dispose());
                        } else {
                            obj.material.dispose();
                        }
                    }
                });

                // Clear the surface group but don't destroy the manager
                while (this.surfaceManager.surfaceGroup.children.length > 0) {
                    this.surfaceManager.surfaceGroup.remove(this.surfaceManager.surfaceGroup.children[0]);
                }
            }

            console.log(`Cleaned up ${objectsToRemove.length} procedural meshes`);
            this.eventBus.emit('scene:cleanup', { count: objectsToRemove.length });
        }

        onResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.composer.setSize(window.innerWidth, window.innerHeight);
        }
        onMouseDown(event) {
            if (event.button === 0) this.isMouseDown = true;
        }
        onMouseUp(event) {
            if (event.button === 0) this.isMouseDown = false;
        }
        onMouseMove(event) {
            if (this.pointerLockControls.isLocked) {
                this.spaceship.handleMouseMove(event);
            } else {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }
        }
    }

    // PSI Overlay and Seed Visualizer Functions
    function initPSIOverlay() {
        const psiPanel = document.getElementById('psiPanel');
        const psiClose = document.getElementById('psiClose');
        const seedViz = document.getElementById('seed-visualizer');

        // Show PSI panel and seed visualizer after initialization
        setTimeout(() => {
            if (psiPanel) psiPanel.style.display = 'block';
            if (seedViz) seedViz.style.display = 'block';
        }, 2000);

        // Close button handler
        if (psiClose) {
            psiClose.addEventListener('click', () => {
                if (psiPanel) psiPanel.style.display = 'none';
            });
        }

        // Listen for CST updates
        if (window.genesisApp && window.genesisApp.eventBus) {
            window.genesisApp.eventBus.on('cst:psi_update', (data) => {
                updatePSIDisplay(data);
                updatePSIGraph();
            });

            // Listen for sensor updates to pulse the seed visualizer
            window.genesisApp.eventBus.on('sensor:audio:update', () => pulseIndicator('pulse-audio'));
            window.genesisApp.eventBus.on('sensor:video:initialized', () => pulseIndicator('pulse-video'));
            window.genesisApp.eventBus.on('sensor:geolocation:update', () => pulseIndicator('pulse-loc'));
            window.genesisApp.eventBus.on('sensor:ambientLight:update', () => pulseIndicator('pulse-light'));
            window.genesisApp.eventBus.on('external:usgs_earthquakes:success', () => pulseIndicator('pulse-usgs'));
            window.genesisApp.eventBus.on('external:nasa_apod:success', () => pulseIndicator('pulse-apod'));
            window.genesisApp.eventBus.on('ml:detections', () => pulseIndicator('pulse-ml'));
        }
    }

    function updatePSIDisplay(data) {
        const term1El = document.getElementById('psi_term1');
        const term2El = document.getElementById('psi_term2');
        const term3El = document.getElementById('psi_term3');
        const term4El = document.getElementById('psi_term4');
        const term5El = document.getElementById('psi_term5');
        const sumEl = document.getElementById('psi_sum');

        if (term1El) term1El.textContent = data.term1.toExponential(2);
        if (term2El) term2El.textContent = data.term2.toFixed(2);
        if (term3El) term3El.textContent = data.term3.toFixed(3);
        if (term4El) term4El.textContent = data.term4.toExponential(2);
        if (term5El) term5El.textContent = data.term5.toFixed(3);
        if (sumEl) sumEl.textContent = data.psi.toExponential(2);
    }

    function updatePSIGraph() {
        const canvas = document.getElementById('psi_graph_canvas');
        if (!canvas || !window.genesisApp || !window.genesisApp.cstCompute) return;

        const ctx = canvas.getContext('2d');
        const history = window.genesisApp.cstCompute.getPsiHistory();

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (history.length < 2) return;

        const values = history.map(h => h.psi);
        const min = Math.min(...values);
        const max = Math.max(...values);
        const range = max - min || 1;

        // Draw grid
        ctx.strokeStyle = 'rgba(100, 116, 139, 0.2)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
            const y = (i / 4) * canvas.height;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        // Draw PSI line
        ctx.strokeStyle = '#7c9cff';
        ctx.lineWidth = 2;
        ctx.beginPath();

        history.forEach((h, i) => {
            const x = (i / (history.length - 1)) * canvas.width;
            const y = canvas.height - ((h.psi - min) / range) * canvas.height;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });

        ctx.stroke();
    }

    function pulseIndicator(elementId) {
        const el = document.getElementById(elementId);
        if (!el) return;

        el.classList.add('active');
        el.style.animation = 'pulse-glow 0.6s ease-out';

        setTimeout(() => {
            el.classList.remove('active');
            el.style.animation = '';
        }, 600);
    }

    window.genesisApp = new Application();
</script>
</body>
</html>

