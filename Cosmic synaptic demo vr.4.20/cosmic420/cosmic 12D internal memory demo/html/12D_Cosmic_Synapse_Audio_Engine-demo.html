<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12D Cosmic Synapse - Audio-Driven Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #2a1a4a 100%);
            color: #ffffff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #00d4ff, #7b2ff7, #f06eaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.1em;
            color: #a0a0ff;
            margin-bottom: 15px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(123, 47, 247, 0.3);
        }

        .card h2 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .equation {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            margin: 10px 0;
            border-left: 3px solid #00d4ff;
            overflow-x: auto;
        }

        .value-display {
            background: rgba(123, 47, 247, 0.2);
            padding: 8px;
            border-radius: 8px;
            margin: 8px 0;
            font-size: 0.95em;
            border-left: 3px solid #7b2ff7;
        }

        #canvas-container {
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            margin: 20px 0;
            border: 2px solid rgba(0, 212, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group label {
            display: block;
            color: #00d4ff;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(45deg, #00d4ff, #7b2ff7);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(123, 47, 247, 0.5);
        }

        button {
            background: linear-gradient(45deg, #00d4ff, #7b2ff7);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(123, 47, 247, 0.5);
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .audio-controls {
            text-align: center;
            margin: 20px 0;
        }

        #micButton {
            background: linear-gradient(45deg, #ff0080, #ff8c00);
            font-size: 1.1em;
            padding: 15px 40px;
        }

        #micButton.active {
            background: linear-gradient(45deg, #00ff00, #00cc00);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.5); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 0, 0.8); }
        }

        .frequency-viz {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 10px 0;
            position: relative;
        }

        #frequencyCanvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .stat-box {
            background: rgba(0, 212, 255, 0.1);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .stat-label {
            font-size: 0.8em;
            color: #a0a0ff;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #00d4ff;
        }

        .token-display {
            background: rgba(240, 110, 170, 0.1);
            border: 1px solid rgba(240, 110, 170, 0.3);
            border-radius: 10px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
        }

        .token-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 3px solid #f06eaa;
            line-height: 1.5;
        }

        .token-item strong {
            color: #00d4ff;
        }

        .info-text {
            color: #b0b0ff;
            line-height: 1.5;
            margin: 8px 0;
            font-size: 0.9em;
        }

        .alert-box {
            background: rgba(123, 47, 247, 0.2);
            border-left: 4px solid #7b2ff7;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.95em;
        }

        #fps-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 10;
            font-size: 0.9em;
        }

        .audio-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 128, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10;
            display: none;
        }

        .audio-indicator.active {
            display: block;
            animation: blink 1s infinite;
        }

        .token-indicator {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0, 212, 255, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10;
            display: none;
            font-size: 0.9em;
        }

        .token-indicator.active {
            display: block;
            animation: pulse-blue 0.5s infinite;
        }

        @keyframes pulse-blue {
            0%, 100% { 
                background: rgba(0, 212, 255, 0.7);
                box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            }
            50% { 
                background: rgba(0, 255, 255, 0.9);
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé§ 12D Cosmic Synapse Theory</h1>
            <p class="subtitle">Audio-Driven Deterministic Cosmological Simulation Engine</p>
            <p class="info-text"><strong>CONTINUOUS TOKEN GENERATION:</strong> Audio ‚Üí FFT ‚Üí œÜ-Harmonics ‚Üí Sound-Color Mapping ‚Üí Seed Generation ‚Üí Token Stream</p>
            <p class="info-text" style="font-size: 0.85em; color: #7b2ff7;">Every audio frame generates multiple tokens through the 12D formula (œà = œÜE/c¬≤ + Œª + ‚à´v¬∑dt + Œ©E + U‚ÇÅ‚ÇÅD)</p>
        </header>

        <div class="audio-controls">
            <button id="micButton" onclick="toggleMicrophone()">üé§ START MICROPHONE ENGINE</button>
            <p class="info-text" style="margin-top: 10px;">
                <strong>Activate continuous token generation:</strong> Every 100ms, audio is analyzed and converted into:<br>
                ‚Ä¢ Audio Frame Tokens (complete spectrum snapshot)<br>
                ‚Ä¢ œÜ-Harmonic Tokens (golden ratio frequency series)<br>
                ‚Ä¢ Particle Creation/Update Tokens (visual entities)<br>
                ‚Ä¢ Sound‚ÜíColor‚ÜíSeed‚ÜíToken pipeline running in real-time
            </p>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üéµ Audio Input Analysis</h2>
                <div class="frequency-viz">
                    <canvas id="frequencyCanvas"></canvas>
                </div>
                <div class="value-display">
                    RMS Energy: <span id="rms-energy">0.00</span>
                </div>
                <div class="value-display">
                    Dominant Freq: <span id="dominant-freq">0.0</span> Hz
                </div>
                <div class="value-display">
                    Spectral Centroid: <span id="spectral-centroid">0.0</span> Hz
                </div>
                <p class="info-text">Live FFT analysis of environmental sound</p>
            </div>

            <div class="card">
                <h2>‚ö° Mass-Energy (Audio-Modulated)</h2>
                <div class="equation">E = mc¬≤ (modulated by RMS)</div>
                <div class="value-display">
                    Base Energy: <span id="energy-value">8.99e16</span> J
                </div>
                <div class="value-display">
                    Audio Gain: <span id="audio-gain">1.00</span>x
                </div>
                <p class="info-text">Energy scaled by audio amplitude</p>
            </div>

            <div class="card">
                <h2>üåÄ œÜ-Harmonic Series</h2>
                <div class="equation">f_n = f‚ÇÄ ¬∑ œÜ^(n/2)</div>
                <div class="value-display">
                    œÜ = <span id="phi-value">1.618033988749895</span>
                </div>
                <div class="value-display">
                    Harmonics: <span id="harmonics-count">0</span> generated
                </div>
                <p class="info-text">Golden ratio frequency spacing</p>
            </div>

            <div class="card">
                <h2>ü¶ã Chaos & Butterfly Effect</h2>
                <div class="equation">Œª = lim (1/t) ln|dX(t)/dX(0)|</div>
                <div class="value-display">
                    Lyapunov: <span id="lyapunov-value">0.905</span>
                </div>
                <div class="value-display">
                    Audio Chaos: <span id="audio-chaos">0.00</span>
                </div>
                <p class="info-text">Chaos driven by frequency variance</p>
            </div>
        </div>

        <div class="card">
            <h2>üåä Lorenz Attractor - Audio-Reactive Visualization</h2>
            <div id="canvas-container">
                <div id="fps-counter">FPS: <span id="fps">60</span></div>
                <div class="audio-indicator" id="audioIndicator">üé§ LISTENING</div>
                <div class="token-indicator" id="tokenIndicator">üé´ GENERATING TOKENS</div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>œÉ (Sigma): <span id="sigma-display">10</span></label>
                    <input type="range" id="sigma" min="1" max="20" value="10" step="0.1">
                </div>
                <div class="control-group">
                    <label>œÅ (Rho): <span id="rho-display">28</span></label>
                    <input type="range" id="rho" min="10" max="40" value="28" step="0.1">
                </div>
                <div class="control-group">
                    <label>Œ≤ (Beta): <span id="beta-display">2.667</span></label>
                    <input type="range" id="beta" min="1" max="5" value="2.667" step="0.01">
                </div>
                <div class="control-group">
                    <label>Audio Sensitivity: <span id="sensitivity-display">1.0</span></label>
                    <input type="range" id="sensitivity" min="0.1" max="5" value="1.0" step="0.1">
                </div>
                <div class="control-group">
                    <label>Replication Threshold: <span id="replication-display">50</span></label>
                    <input type="range" id="replication" min="10" max="200" value="50" step="10">
                </div>
            </div>

            <div style="text-align: center;">
                <button onclick="resetSystem()">üîÑ Reset</button>
                <button onclick="togglePause()">‚èØÔ∏è Pause/Play</button>
                <button onclick="changeColor()">üé® Color</button>
                <button onclick="addParticle()">‚ûï Add Particle</button>
            </div>
        </div>

        <!-- 12D CST Advanced Controls -->
        <div class="grid">
            <div class="card">
                <h2>‚öõÔ∏è Physics Controls</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Blend Lorenz: <span id="blend-lorenz-display">0.7</span></label>
                        <input type="range" id="blend-lorenz" min="0" max="1" value="0.7" step="0.05">
                        <small class="info-text">0=gravity only, 1=Lorenz only</small>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="grav-enabled">
                            Enable Gravity
                        </label>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="dm-enabled">
                            Enable Dark Matter
                        </label>
                    </div>
                    <div class="control-group">
                        <label>Cutoff Radius: <span id="rcutoff-display">10.0</span></label>
                        <input type="range" id="rcutoff" min="1" max="50" value="10.0" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>Softening (Œµ): <span id="epsilon-display">0.1</span></label>
                        <input type="range" id="epsilon" min="0.01" max="1" value="0.1" step="0.01">
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üß† Adaptive State Controls</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>k (Coupling): <span id="k-display">0.5</span></label>
                        <input type="range" id="k" min="0" max="2" value="0.5" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Œ≥ (Decay): <span id="gamma-display">0.2</span></label>
                        <input type="range" id="gamma" min="0" max="1" value="0.2" step="0.05">
                    </div>
                    <div class="control-group">
                        <label>Œ± (Memory): <span id="alpha-display">0.3</span></label>
                        <input type="range" id="alpha" min="0" max="1" value="0.3" step="0.05">
                    </div>
                    <div class="control-group">
                        <label>œÉ (Similarity): <span id="sigma-sim-display">0.3</span></label>
                        <input type="range" id="sigma-sim" min="0.1" max="1" value="0.3" step="0.05">
                    </div>
                </div>
            </div>

            <!-- NEW: Adaptive state strip chart -->
            <div class="card">
                <h2>üß† Adaptive State Trace</h2>
                <canvas id="adaptiveStateCanvas" width="400" height="120" style="width: 100%; height: 120px; border-radius: 10px; background: rgba(0,0,0,0.3); margin-top: 10px;"></canvas>
            </div>

            <div class="card">
                <h2>üîÑ Synchronization & Timestep</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>K_sync: <span id="ksync-display">0.1</span></label>
                        <input type="range" id="ksync" min="0" max="1" value="0.1" step="0.01">
                    </div>
                    <div class="control-group">
                        <label>Max dt: <span id="dtmax-display">0.01</span></label>
                        <input type="range" id="dtmax" min="0.001" max="0.1" value="0.01" step="0.001">
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="adaptive-dt" checked="true">
                            Adaptive Timestep
                        </label>
                    </div>
                    <div class="control-group">
                        <label for="projection-mode">Projection Mode:</label>
                        <select id="projection-mode" style="width: 100%; padding: 5px; border-radius: 5px; background: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.2);">
                            <option value="orthogonal">Orthogonal</option>
                            <option value="random_embedding">Random Embedding</option>
                            <option value="learned_embedding">Learned Embedding</option>
                        </select>
                        <p class="info-text">Active: <span id="projection-status">orthogonal</span></p>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üé¨ Determinism & Replay</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Seed: <input type="number" id="deterministic-seed" value="12345" style="width: 100px;"></label>
                        <button onclick="setDeterministicSeed(parseInt(document.getElementById('deterministic-seed').value))">Set Seed</button>
                    </div>
                    <div class="control-group">
                        <button onclick="toggleRecording()" id="record-btn">üî¥ Start Recording</button>
                        <button onclick="toggleReplay()" id="replay-btn">‚ñ∂Ô∏è Replay</button>
                    </div>
                    <div class="value-display" id="recording-status">Not recording</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üß™ Replay Validation</h2>
                <div class="stats">
                    <div class="stat-box"><div class="stat-label">ŒîE/E‚ÇÄ</div><div class="stat-value" id="replay-edrift">0.00%</div></div>
                    <div class="stat-box"><div class="stat-label">|P|</div><div class="stat-value" id="replay-pmag">0.00</div></div>
                    <div class="stat-box"><div class="stat-label">|L|</div><div class="stat-value" id="replay-lmag">0.00</div></div>
                    <div class="stat-box"><div class="stat-label">Virial</div><div class="stat-value" id="replay-virial">1.00</div></div>
                </div>
                <p class="info-text">Replay mode must reproduce identical diagnostics for a given recording + seed.</p>
            </div>

        <!-- 12D CST Advanced Displays -->
        <div class="grid">
            <div class="card">
                <h2>üìä Conservation Diagnostics</h2>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">E_total</div>
                        <div class="stat-value" id="conservation-etotal">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ŒîE/E‚ÇÄ</div>
                        <div class="stat-value" id="conservation-edrift">0.00%</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">|P|</div>
                        <div class="stat-value" id="conservation-pmag">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">|L|</div>
                        <div class="stat-value" id="conservation-lmag">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Virial</div>
                        <div class="stat-value" id="conservation-virial">1.00</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üéµ Synchronization Metrics</h2>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Order (r)</div>
                        <div class="stat-value" id="sync-r">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Mean Œ∏</div>
                        <div class="stat-value" id="sync-mean">0¬∞</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Std Œ∏</div>
                        <div class="stat-value" id="sync-std">0.0¬∞</div>
                    </div>
                </div>
                <p class="info-text">r=1: fully synchronized, r=0: no synchronization</p>
            </div>

            <div class="card">
                <h2>üåÄ œà Normalized Breakdown</h2>
                <div class="value-display">
                    <strong>Energy Term:</strong> <span id="psi-energy-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>Œª Term:</strong> <span id="psi-lambda-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>‚à´||v|| dt:</strong> <span id="psi-velint-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>‚à´|Œîx‚ÇÅ‚ÇÇ| dt:</strong> <span id="psi-x12int-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>Œ© Term:</strong> <span id="psi-omega-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>Potential Term:</strong> <span id="psi-potential-term">0.000</span>
                </div>
                <div class="value-display" style="border-left: 3px solid #00d4ff; font-weight: bold;">
                    <strong>Total œà:</strong> <span id="psi-total-normalized">0.000</span>
                </div>
            </div>

            <div class="card">
                <h2>üåå Dark Matter Parameters</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>œÅ‚ÇÄ: <span id="dm-rho0-display">1.0</span></label>
                        <input type="range" id="dm-rho0" min="0.1" max="10" value="1.0" step="0.1">
                </div>
                    <div class="control-group">
                        <label>r_s: <span id="dm-rs-display">5.0</span></label>
                        <input type="range" id="dm-rs" min="1" max="20" value="5.0" step="0.5">
                </div>
                </div>
            </div>

            <div class="card">
                <h2>üìâ NFW Density Profile</h2>
                <canvas id="dmProfileCanvas" width="400" height="120" style="width: 100%; height: 120px; border-radius: 10px; background: rgba(0, 0, 0, 0.3); margin-top: 10px;"></canvas>
            </div>

            <div class="card">
                <h2>üåê Global Entropy</h2>
                <div class="value-display">Entropy: <span id="entropy-global">0.000</span></div>
                <div class="value-display">Distribution: <span id="entropy-bins">[]</span></div>
                <div class="value-display">Temperature Proxy: <span id="entropy-temperature">0.000</span></div>
                <canvas id="entropyCanvas" width="400" height="100" style="width: 100%; height: 100px; border-radius: 10px; background: rgba(0, 0, 0, 0.3); margin-top: 10px;"></canvas>
            </div>
            
            <div class="card">
                <h2>üìà Entropy Trace</h2>
                <canvas id="entropyTraceCanvas" width="400" height="60" style="width: 100%; height: 60px; border-radius: 10px; background: rgba(0, 0, 0, 0.3); margin-top: 10px;"></canvas>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üéØ 12D State Function (œà)</h2>
                <div class="equation">
                    œà = œÜE/c¬≤ + Œª + ‚à´v¬∑dt + ‚à´Œîx‚ÇÅ‚ÇÇ¬∑dt + Œ©E + U‚ÇÅ‚ÇÅD
                </div>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">E/c¬≤</div>
                        <div class="stat-value" id="psi-energy">1.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">œÜ</div>
                        <div class="stat-value" id="psi-phi">1.618</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Œª</div>
                        <div class="stat-value" id="psi-lambda">0.905</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Œ©</div>
                        <div class="stat-value" id="psi-omega">12.45</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Total œà</div>
                        <div class="stat-value" id="psi-total">15.97</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üé´ Continuous Token Stream</h2>
                <p class="info-text">
                    <strong>LIVE GENERATION:</strong> Audio Frame Tokens ‚Ä¢ œÜ-Harmonic Tokens ‚Ä¢ Particle Tokens ‚Ä¢ Frequency Update Tokens<br>
                    <em>Each audio snapshot creates deterministic, blockchain-ready tokens</em>
                </p>
                <div class="token-display" id="tokenDisplay">
                    <div class="token-item">Waiting for audio input...</div>
                </div>
                <div class="value-display">
                    Total Tokens: <span id="token-count">0</span>
                </div>
                <div style="text-align: center; margin-top: 10px;">
                    <label style="margin-right: 10px;"><input type="checkbox" id="export-compact" checked> Compact export</label>
                    <button onclick="exportTokens()">üíæ Export Tokens (JSON)</button>
                    <button onclick="exportTokens({full:true})">üíæ Export Full JSON</button>
                    <button onclick="clearTokens()">üóëÔ∏è Clear Tokens</button>
                </div>
            </div>
        </div>

        <div class="alert-box">
            <strong>üî¨ System Status:</strong> <span id="system-status">Audio engine offline - Click START MICROPHONE to begin</span><br>
            <strong>üìä Particles:</strong> <span id="particle-count">0</span> active | 
            <strong>üé´ Tokens:</strong> <span id="token-count-status">0</span> generated |
            <strong>üîÑ Replications:</strong> <span id="replication-count">0</span> |
            <strong>‚ö° Token Rate:</strong> <span id="token-rate">0.0</span> tokens/sec
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        /*
         * ============================================================================
         * 12D COSMIC SYNAPSE THEORY - CONTINUOUS TOKEN GENERATION ENGINE v2.0
         * ============================================================================
         * 
         * UPGRADED FEATURES (v2.0):
         * 
         * 1. 11D-TO-3D PROJECTION: Each particle maintains 11D position/velocity projection
         * 2. GRAVITATIONAL SUBSTRATE: Softened Newtonian forces with optional dark matter (NFW profile)
         * 3. ADAPTIVE STATE x12: Per-particle 12th dimension with ODE evolution and memory m12
         * 4. SYNAPTIC STRENGTH Œ©: Gravitational coupling with Gaussian internal-state similarity
         * 5. CHARACTERISTIC FREQUENCY vi: Derived from cosmic energy (Ec/h) with phase synchronization
         * 6. KURAMOTO SYNCHRONIZATION: Phase coupling between particles with order parameter tracking
         * 7. ENTROPY: Coarse-grained Boltzmann-style entropy via speed histogram
         * 8. CONSERVATION DIAGNOSTICS: Energy, momentum, angular momentum tracking with virial checks
         * 9. SPATIAL INDEXING: Uniform grid for efficient neighbor queries (O(N) instead of O(N¬≤))
         * 10. ADAPTIVE TIMESTEP: Dynamic dt based on minimum distance and maximum velocity
         * 11. DETERMINISTIC REPLAY: Record audio frames and replay with fixed seed for reproducibility
         * 12. NORMALIZED œà: Dimensionless breakdown with reference scales (m0, Eref, tref, vref)
         * 
         * PIPELINE FLOW:
         * 1. AUDIO INPUT: Microphone captures live environmental sound (44.1kHz)
         * 2. FFT ANALYSIS: Fast Fourier Transform extracts frequency spectrum
         * 3. FREQUENCY EXTRACTION: Top 10 frequencies identified with magnitudes
         * 4. œÜ-HARMONIC GENERATION: Golden ratio (1.618...) creates harmonic series
         * 5. SOUND‚ÜíCOLOR MAPPING: Frequency (0-20kHz) mapped to Hue (0-360¬∞)
         * 6. SEED GENERATION: Deterministic seeds from frequency√ómagnitude combinations
         * 7. TOKEN CREATION: Every 100ms generates:
         *    - Audio Frame Tokens (complete spectrum snapshot)
         *    - œÜ-Harmonic Tokens (each harmonic in the series)
         *    - Particle Creation Tokens (new visual entities with x12, Ec, Œ©, vi, Œ∏, etc.)
         *    - Frequency Update Tokens (existing particle updates)
         * 8. œà CALCULATION: Normalized 12D state function: 
         *    œà = œÜ¬∑(Ec/Eref) + Œª + ‚à´||v|| dt/vref + ‚à´|Œîx12| dt + Œ©¬∑(Ec/Eref) + (Ugrav+Udm)/Eref
         * 9. PHYSICS INTEGRATION: Blended Lorenz + gravitational dynamics with adaptive states
         * 10. VISUAL RENDERING: Particles rendered in 3D with blended dynamics
         * 11. BLOCKCHAIN EXPORT: All tokens exportable as JSON for permanent record
         * 
         * CONTINUOUS: Token generation runs constantly while audio is active
         * DETERMINISTIC: Same audio input always produces identical tokens (replay mode)
         * 
         * REPLAY MODE USAGE:
         * 1. Click "Start Recording" to capture audio frames
         * 2. Set a deterministic seed (optional, defaults to 12345)
         * 3. Click "Replay" to feed recorded frames instead of live audio
         * 4. All tokens and œà values will be identical for the same recording
         * 
         * DEFAULT SETTINGS (tuned for stability):
         * - gravEnabled: false, dmEnabled: false, blendLorenz: 0.7
         * - adaptive timestep: true, k=0.5, Œ≥=0.2, Œ±=0.3, œÉ=0.3, Ksync=0.1
         * 
         * ============================================================================
         * 
         * CST v2.0 RESTORATION NOTES (Additive Updates):
         * 
         * RESTORED FUNCTIONALITY:
         * 1. Continuous Token Generation: Enhanced with rolling window rate calculation (2-second window)
         *    - Tokens generate every 100ms from live audio or replay
         *    - Token rate displayed in real-time with smooth updates every 500ms
         *    - Token display bounded to last 200 items for performance
         * 
         * 2. Deterministic Record/Replay: Enhanced with deep copying and seed management
         *    - Complete audio frame data recorded (RMS, frequencies, harmonics, raw FFT)
         *    - Replay resets token arrays and counters for clean deterministic output
         *    - Same seed + recording produces identical tokens and Œ® values
         *    - Deep copy prevents mutation issues during replay
         * 
         * 3. Adaptive Timestep: Already implemented, verified working
         *    - Dynamic dt based on min distance and max velocity
         *    - Clamped to [0.001, dtMax] for stability
         *    - Respects adaptive-dt checkbox control
         * 
         * 4. Real-time Diagnostics: All metrics update continuously
         *    - Œ® breakdown: energy, Œª, ‚à´||v||dt, ‚à´|Œîx12|dt, Œ©¬∑E, potential terms
         *    - Synchronization: Kuramoto order parameter r and mean Œ∏
         *    - Conservation: Energy, momentum, angular momentum, virial ratio
         *    - Chaos: Lyapunov exponent and audio chaos measure
         * 
         * 5. Controls: All sliders/checkboxes wired and functional
         *    - Physics: blend-lorenz, grav-enabled, dm-enabled, rcutoff, epsilon
         *    - Adaptive state: k, gamma, alpha, sigma-sim
         *    - Synchronization: ksync
         *    - Timestep: dtmax, adaptive-dt checkbox
         * 
         * WHERE TO FIND IN UI:
         * - Token Rate: Alert box (bottom) and token display header
         * - Recording Status: "Determinism & Replay" card
         * - Seed Control: "Determinism & Replay" card
         * - All Diagnostics: "Conservation Diagnostics", "Synchronization Metrics", "œà Normalized Breakdown" cards
         * - Controls: "Physics Controls", "Adaptive State Controls", "Synchronization & Timestep" cards
         * 
         * ============================================================================
         * 
         * CST v2.0+ ENHANCEMENTS (Latest Additive Updates):
         * 
         * 1. Enhanced Export Schema:
         *    - Full particle snapshots with 11D projection data (pos11D[], vel11D[])
         *    - Reference scales (m0, Eref, tref, vref) for dimensionless œà normalization
         *    - Recorded frames array with complete FFT data
         *    - Replay integrity hash for deterministic verification
         *    - Dark matter parameters included in metadata
         * 
         * 2. Deterministic Replay Integrity:
         *    - Reset œà accumulators (velocityIntegral, x12Integral) on replay
         *    - Reset conservation stats (E0, P0, L0) for clean replay
         *    - All randomness funneled through getRandom() for determinism
         *    - Fixed Math.random() leaks in createParticleFromFrequency()
         * 
         * 3. Adaptive Timestep Precision:
         *    - Clamping corrected to [0.001, dtMax] per specification
         *    - Proper handling of edge cases (rMin=Infinity, vMax=0)
         * 
         * 4. 11D Projection Documentation:
         *    - Added hooks for alternative projection maps (orthogonal, random embedding, learned)
         *    - Maintained Float64Array precision for numerical stability
         *    - Projection data included in all particle tokens
         * 
         * 5. Token Generation Cadence:
         *    - Fixed recursive setTimeout ‚Üí setInterval for exact 100ms timing (no drift)
         *    - Clean interval management with audioProcessingInterval tracking
         *    - Token rate calculation with 2-second rolling window
         * 
         * VERIFICATION CHECKLIST:
         * ‚úì Continuous audio‚Üítoken pipeline (100ms cadence)
         * ‚úì 11D‚Üí3D projection continuity (updated each frame)
         * ‚úì Adaptive state x12 with memory m12
         * ‚úì Gravitational substrate with dark matter (NFW-like)
         * ‚úì Kuramoto synchronization with order parameter r
         * ‚úì Entropy metrics (coarse-grained Boltzmann-style)
         * ‚úì Adaptive timestep (clamped to [0.001, dtMax])
         * ‚úì Deterministic replay (identical tokens with same seed)
         * ‚úì œà normalized breakdown (all terms tracked)
         * ‚úì Spatial indexing (O(N) neighbor queries)
         * ‚úì Export schema (complete with 11D data and integrity hash)
         * ‚úì UI wiring (all controls functional and live-bound)
         * 
         * ============================================================================
         */
        
        // Constants
        const c = 299792458; // Speed of light
        const phi = (1 + Math.sqrt(5)) / 2;
        const h = 6.62607015e-34; // Planck's constant
        const kB = 1.380649e-23; // Boltzmann constant
        
        // Audio variables
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let dataArray = null;
        let bufferLength = 0;
        let isAudioActive = false;
        let audioProcessingInterval = null; // CST v2.0+: Interval ID for configurable cadence
        let frequencyData = [];
        let audioEnergy = 0;
        let spectralCentroid = 0;
        let tokenCount = 0;
        let tokens = [];
        let replicationThreshold = 50; // Energy threshold for particle replication
        let replicationCount = 0;
        let tokenGenerationRate = 0;
        let lastTokenCount = 0;
        let lastTokenTime = Date.now();
        let lastTokenRateTime = Date.now();
        
        // CST v2.0+ additive: Configurable cadence and FFT settings
        const audioConfig = {
            cadence: 100, // Token generation cadence in ms (1-100)
            fftSize: 2048, // FFT size (256, 512, 1024, 2048, 4096, 8192)
            tokenDisplayLimit: 200 // Maximum tokens to display in UI
        };
        
        // CST v2.0+ additive: Token buffering for batched UI updates
        const tokenBuffer = {
            tokens: [], // Buffer of tokens waiting to be flushed to UI
            flushInterval: null, // Interval ID for UI flush (~20Hz = 50ms)
            flushRate: 50 // UI update rate in ms (~20Hz)
        };
        
        // CST v2.0+ additive: Token rate update interval for smooth UI updates
        let tokenRateUpdateInterval = null;
        
        // CST v2.0+ additive: Deterministic ID generation for replay
        let deterministicIdCounter = 0;
        function nextDeterministicId() {
            if (determinism.mode === 'replay') {
                deterministicIdCounter++;
                return `replay-${determinism.seed || 0}-${deterministicIdCounter}`;
            }
            return generateUUID();
        }
        
        // CST v2.0 additive: Rolling window for token rate calculation
        const tokenRateWindow = {
            timestamps: [], // Array of timestamps when tokens were generated
            windowSize: 2000, // 2 second window in milliseconds
            maxEntries: 1000 // Maximum entries to keep
        };

        // ============================================================================
        // 12D CST GLOBAL SIMULATION STATE
        // ============================================================================
        const physics = {
            G: 6.67430e-11, // Gravitational constant (m¬≥/kg/s¬≤)
            a0: 1.0, // Reference acceleration scale
            m0: 1.0, // Reference mass scale
            Eref: 1.0, // Reference energy scale
            tref: 1.0, // Reference time scale
            vref: 1.0, // Reference velocity scale
            epsilon: 0.1, // Softening parameter for gravity
            rCutoff: 10.0, // Cutoff radius for neighbor search
            blendLorenz: 0.7, // Blend factor: 0=gravity only, 1=Lorenz only
            gravEnabled: false, // Enable gravitational forces
            dmEnabled: false // Enable dark matter
        };

        const adapt = {
            k: 0.5, // Adaptive state coupling strength
            gamma: 0.2, // Adaptive state decay
            alpha: 0.3, // Memory update rate
            sigmaSimilarity: 0.3 // Gaussian width for similarity in Œ©
        };

        const sync = {
            Ksync: 0.1 // Kuramoto coupling strength
        };

        const timestep = {
            dt: 0.005, // Current timestep
            dtMax: 0.01, // Maximum timestep
            adaptive: true // Use adaptive timestep
        };

        const determinism = {
            mode: 'live', // 'live' or 'replay'
            seed: null, // Deterministic seed for replay
            recordedAudioFrames: [], // Recorded audio frames for replay
            isRecording: false, // Currently recording
            replayIndex: 0, // Current frame index in replay mode
            replayInterval: null // Interval ID for replay processing
        };
        
        // Accumulators for œà integrals
        const psiAccumulators = {
            velocityIntegral: new Map(), // ‚à´||v|| dt per particle
            x12Integral: new Map(), // ‚à´|Œîx12| dt per particle
            x12Previous: new Map() // Previous x12 value per particle for computing Œîx12
        };

        // Conservation tracking
        let conservationStats = {
            E0: 0, // Initial total energy
            P0: { x: 0, y: 0, z: 0 }, // Initial total momentum
            L0: { x: 0, y: 0, z: 0 }, // Initial total angular momentum
            lastUpdate: Date.now()
        };
        
        // Dark matter parameters
        const dmParams = {
            rho0: 1.0, // Central density
            rs: 5.0 // Scale radius
        };

        // CST v2.0+ additive: Projection mode configuration
        const projectionConfig = {
            mode: 'orthogonal',
            randomSeed: 1337,
            randomR: null, // Random projection matrix (11x3)
            learnedWeights: null // Learned embedding weights (placeholder)
        };

        // CST v2.0+ additive: Global entropy state
        const entropyState = {
            bins: 32,
            histogram: new Array(32).fill(0),
            lastEntropy: 0,
            tempProxy: 0,
            ctx: null,
            traceCtx: null // CST v2.0+ additive: Context for entropy trace canvas
        };
        
        // --- NEW: adaptive state canvas init ---
        let adaptiveStateCtx = null;
        let x12History = []; // array of arrays: per-particle x12 trace
        
        // --- NEW: dark matter profile plot ---
        let dmProfileCtx = null;
        
        // CST v2.0+ additive: Rolling buffer for entropy trace
        const entropyTrace = [];
        
        // --- NEW: entropy trace smoothing ---
        const entropyTraceConfig = {
            emaAlpha: 0.3 // exponential moving average smoothing factor
        };
        let entropyEma = null;
        
        function getSmoothedEntropy(current) {
            if (entropyEma === null || !isFinite(entropyEma)) {
                entropyEma = current;
                return current;
            }
            entropyEma = entropyTraceConfig.emaAlpha * current + (1 - entropyTraceConfig.emaAlpha) * entropyEma;
            return entropyEma;
        }

        // UUID generator (deterministic in replay mode)
        function generateUUID() {
            if (determinism.mode === 'replay' && determinism.seed !== null) {
                // Use deterministic pseudo-random for replay
                determinism.seed = (determinism.seed * 1103515245 + 12345) & 0x7fffffff;
                const r = determinism.seed % 16;
                const v = r & 0x3 | 0x8;
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const val = c === 'x' ? r : v;
                    return val.toString(16);
                });
            }
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // Deterministic random for replay mode
        let deterministicRandom = null;
        function getRandom() {
            if (determinism.mode === 'replay' && determinism.seed !== null) {
                if (!deterministicRandom) {
                    deterministicRandom = determinism.seed;
                }
                deterministicRandom = (deterministicRandom * 1103515245 + 12345) & 0x7fffffff;
                return (deterministicRandom / 0x7fffffff);
            }
            return Math.random();
        }
        
        // CST v2.0 additive: Enhanced deterministic seed setting
        function setDeterministicSeed(seed) {
            determinism.seed = seed;
            deterministicRandom = seed;
            projectionConfig.randomR = null; // force regen for random embedding
            updateStatus(`Seed set to ${seed}`);
        }

        // Three.js setup
        let scene, camera, renderer;
        let particles = [];
        let isPaused = false;
        let colorHue = 180;
        let frameCount = 0;
        let lastTime = performance.now();

        // Lorenz parameters
        let sigma = 10;
        let rho = 28;
        let beta = 2.667;
        let audioSensitivity = 1.0;
        // Note: dt is now managed by timestep.dt (see timestep object above)

        // Frequency canvas
        let freqCanvas, freqCtx;

        class LorenzParticle {
            constructor(x, y, z, color, frequency = 0, parent = null) {
                this.id = generateUUID();
                this.x = x || 0.1;
                this.y = y || 0;
                this.z = z || 0;
                this.color = color || 0x00d4ff;
                this.frequency = frequency;
                this.energy = 0; // Legacy energy (kept for compatibility)
                this.mass = 1;
                this.velocity = { x: 0, y: 0, z: 0 };
                this.entropy = 0; // Legacy entropy
                this.memory = new Array(10).fill(0);
                this.tokens = []; // Token list per particle
                this.parent = parent; // Track parent for replication
                this.points = [];
                this.maxPoints = 2000;
                this.createdAt = Date.now();
                
                // ============================================================================
                // 12D CST NEW PROPERTIES
                // ============================================================================
                this.x12 = 0; // Adaptive state (dimensionless, bounded [-1, 1])
                this.m12 = 0; // Memory of x12
                this.Ec = 0; // Cosmic energy = kinetic + potential + dark matter
                this.Ugrav = 0; // Gravitational potential energy
                this.Udm = 0; // Dark matter potential contribution
                this.vi = 0; // Characteristic frequency = Ec/h
                this.theta = getRandom() * 2 * Math.PI; // Phase (initialized randomly)
                this.neighbors = []; // Cached neighbor indices
                this.omega = 0; // Œ©i = synaptic strength
                this.entropyS = 0; // Boltzmann-style coarse-grained entropy
                this.projection11D = {
                    pos11D: new Float64Array(11).fill(0),
                    vel11D: new Float64Array(11).fill(0)
                };
                
                // Initialize 11D projection (project 3D position to 11D)
                this.update11DProjection();
                
                // Create line geometry
                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({ 
                    color: this.color,
                    transparent: true,
                    opacity: 0.7
                });
                this.line = new THREE.Line(geometry, material);
                scene.add(this.line);
                
                // Add starting glow sphere
                const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: this.color,
                    transparent: true,
                    opacity: 0.8
                });
                this.sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                scene.add(this.sphere);
            }

            // Update 11D projection from 3D position
            // CST v2.0+ additive: Maintains per-particle 11D position/velocity projections
            // Hook for alternative projection maps: orthogonal, random embedding, learned
            update11DProjection() {
                // Use projection mode selector
                if (projectionConfig.mode === 'orthogonal') {
                    orthogonalProjection(this);
                } else if (projectionConfig.mode === 'random_embedding') {
                    randomEmbeddingProjection(this);
                } else if (projectionConfig.mode === 'learned_embedding') {
                    learnedEmbeddingProjection(this);
                } else {
                    // Fallback to orthogonal
                    orthogonalProjection(this);
                }
            }

            update(audioModulation = 1.0, gravAcceleration = null) {
                // Audio-modulated Lorenz equations
                const effectiveSigma = sigma * (1 + audioModulation * 0.5);
                const effectiveRho = rho * (1 + audioModulation * 0.3);
                
                const dxLorenz = effectiveSigma * (this.y - this.x) * timestep.dt;
                const dyLorenz = (this.x * (effectiveRho - this.z) - this.y) * timestep.dt;
                const dzLorenz = (this.x * this.y - beta * this.z) * timestep.dt;

                // Blend Lorenz and gravitational accelerations
                let dx, dy, dz;
                if (gravAcceleration && physics.gravEnabled) {
                    const dxGrav = gravAcceleration.x * timestep.dt;
                    const dyGrav = gravAcceleration.y * timestep.dt;
                    const dzGrav = gravAcceleration.z * timestep.dt;
                    
                    dx = physics.blendLorenz * dxLorenz + (1 - physics.blendLorenz) * dxGrav;
                    dy = physics.blendLorenz * dyLorenz + (1 - physics.blendLorenz) * dyGrav;
                    dz = physics.blendLorenz * dzLorenz + (1 - physics.blendLorenz) * dzGrav;
                } else {
                    dx = dxLorenz;
                    dy = dyLorenz;
                    dz = dzLorenz;
                }

                this.x += dx;
                this.y += dy;
                this.z += dz;

                // Update velocity
                this.velocity = { x: dx / timestep.dt, y: dy / timestep.dt, z: dz / timestep.dt };
                
                // Update 11D projection
                this.update11DProjection();

                // Store point
                this.points.push(new THREE.Vector3(this.x, this.y, this.z));
                
                if (this.points.length > this.maxPoints) {
                    this.points.shift();
                }

                // Update geometry
                // CST v2.0+ fix: Properly handle geometry updates when point count changes
                const pointCount = this.points.length;
                if (pointCount > 0) {
                    const positions = new Float32Array(pointCount * 3);
                    for (let i = 0; i < pointCount; i++) {
                        positions[i * 3] = this.points[i].x;
                        positions[i * 3 + 1] = this.points[i].y;
                        positions[i * 3 + 2] = this.points[i].z;
                    }
                    
                    // Update or create position attribute
                    if (this.line.geometry.attributes.position) {
                        // Update existing attribute if size matches
                        if (this.line.geometry.attributes.position.count === pointCount) {
                            this.line.geometry.attributes.position.array.set(positions);
                            this.line.geometry.attributes.position.needsUpdate = true;
                        } else {
                            // Recreate if size changed - Three.js will dispose old attribute automatically
                            this.line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        }
                    } else {
                        // Create new attribute
                        this.line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    }
                    // Set draw range to ensure only valid points are rendered
                    this.line.geometry.setDrawRange(0, pointCount);
                }

                // Update sphere position
                this.sphere.position.set(this.x, this.y, this.z);

                // Calculate cosmic energy: Ec = 0.5 * m * v^2 * c^2 (relativistic-inspired)
                const velocityMagnitude = Math.sqrt(dx*dx + dy*dy + dz*dz) / timestep.dt;
                this.energy = 0.5 * this.mass * velocityMagnitude * velocityMagnitude;
                
                // Update entropy based on trajectory complexity
                this.entropy = Math.log(this.points.length + 1) * this.energy;

                // Note: œà integrals (‚à´||v|| dt, ‚à´|Œîx‚ÇÅ‚ÇÇ| dt) are accumulated in updatePsiNormalized()
                // which is called after all particles are updated for efficiency

                // Check for replication
                this.checkReplication();

                return { dx, dy, dz };
            }

            checkReplication() {
                // Replication when Ec and omega exceed thresholds
                const energyThreshold = this.Ec > replicationThreshold;
                const omegaThreshold = this.omega > 0.1; // Minimum synaptic strength
                
                if (energyThreshold && omegaThreshold && particles.length < 30) {
                    // Create offspring particle
                    const offset = (getRandom() * 2 - 1) * 0.5;
                    const color = new THREE.Color(this.color);
                    color.offsetHSL(0.1, 0, 0); // Slight color variation
                    
                    const offspring = new LorenzParticle(
                        this.x + offset,
                        this.y + offset,
                        this.z + offset,
                        color.getHex(),
                        this.frequency * (1 + (getRandom() * 0.1 - 0.05)), // Slight frequency mutation
                        this.id // Set parent
                    );
                    
                    offspring.mass = this.mass * (0.95 + getRandom() * 0.1);
                    offspring.x12 = this.x12 + (getRandom() * 0.2 - 0.1); // Inherit with variation
                    offspring.m12 = this.m12;
                    
                    // Split energy
                    this.Ec *= 0.5;
                    offspring.Ec = this.Ec;
                    this.energy *= 0.5; // Legacy
                    offspring.energy = this.energy;
                    
                    particles.push(offspring);
                    replicationCount++;
            
                    // Generate replication token for offspring
                    generateParticleToken(offspring, 'replication');
                    
                    updateStatus(`Particle ${this.id.substr(0, 8)} replicated ‚Üí ${offspring.id.substr(0, 8)}`);
                }
            }

            assignFrequency(freq, magnitude) {
                this.frequency = freq;
                // Generate simple token format for frequency assignment
                const simpleToken = `Freq_${freq.toFixed(2)}_Particle_${this.id.substr(0, 8)}`;
                this.tokens.push(simpleToken);
            }

            destroy() {
                scene.remove(this.line);
                scene.remove(this.sphere);
                this.line.geometry.dispose();
                this.line.material.dispose();
                this.sphere.geometry.dispose();
                this.sphere.material.dispose();
            }
        }

        // ============================================================================
        // 12D CST CORE ALGORITHMS
        // ============================================================================
        
        // 1) Spatial indexing for neighbor queries
        function buildSpatialIndex(particles, rCutoff) {
            // Simple uniform grid spatial index (3D)
            const cellSize = rCutoff;
            const grid = new Map();
            
            particles.forEach((p, i) => {
                const gx = Math.floor(p.x / cellSize);
                const gy = Math.floor(p.y / cellSize);
                const gz = Math.floor(p.z / cellSize);
                const key = `${gx},${gy},${gz}`;
                
                if (!grid.has(key)) {
                    grid.set(key, []);
                }
                grid.get(key).push(i);
            });
            
            return { grid, cellSize };
        }

        function queryNeighbors(i, particles, index, rCutoff) {
            const p = particles[i];
            const neighbors = [];
            const cellSize = index.cellSize;
            
            // Check current cell and 26 neighboring cells
            const gx = Math.floor(p.x / cellSize);
            const gy = Math.floor(p.y / cellSize);
            const gz = Math.floor(p.z / cellSize);
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        const key = `${gx + dx},${gy + dy},${gz + dz}`;
                        const cell = index.grid.get(key);
                        if (cell) {
                            cell.forEach(j => {
                                if (i !== j) {
                                    const pj = particles[j];
                                    const dx2 = pj.x - p.x;
                                    const dy2 = pj.y - p.y;
                                    const dz2 = pj.z - p.z;
                                    const r = Math.sqrt(dx2*dx2 + dy2*dy2 + dz2*dz2);
                                    if (r <= rCutoff) {
                                        neighbors.push(j);
                                    }
                                }
                            });
                        }
                    }
                }
            }
            
            return neighbors;
        }

        // 2) Gravitational forces and energies
        function computeGravitationalAccelerations(particles, index, physics) {
            const accelerations = particles.map(() => ({ x: 0, y: 0, z: 0 }));
            
            if (!physics.gravEnabled) return accelerations;
            
            particles.forEach((pi, i) => {
                const neighbors = queryNeighbors(i, particles, index, physics.rCutoff);
                
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - pi.x;
                    const dy = pj.y - pi.y;
                    const dz = pj.z - pi.z;
                    const r2 = dx*dx + dy*dy + dz*dz;
                    const r_eff2 = r2 + physics.epsilon * physics.epsilon;
                    const r_eff = Math.sqrt(r_eff2);
                    
                    const force = physics.G * pi.mass * pj.mass / r_eff2;
                    const fx = force * (dx / r_eff);
                    const fy = force * (dy / r_eff);
                    const fz = force * (dz / r_eff);
                    
                    accelerations[i].x += fx / pi.mass;
                    accelerations[i].y += fy / pi.mass;
                    accelerations[i].z += fz / pi.mass;
                });
            });
            
            return accelerations;
        }

        function computeGravitationalEnergy(particles, index, physics) {
            if (!physics.gravEnabled) {
                particles.forEach(p => p.Ugrav = 0);
                return;
            }
            
            particles.forEach((pi, i) => {
                let U = 0;
                const neighbors = queryNeighbors(i, particles, index, physics.rCutoff);
                
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - pi.x;
                    const dy = pj.y - pi.y;
                    const dz = pj.z - pi.z;
                    const r2 = dx*dx + dy*dy + dz*dz;
                    const r_eff = Math.sqrt(r2 + physics.epsilon * physics.epsilon);
                    
                    U -= physics.G * pi.mass * pj.mass / r_eff;
                });
                
                pi.Ugrav = U;
            });
        }

        // 3) Dark matter via NFW profile
        function computeDarkMatterPotential(particles, dmParams) {
            if (!physics.dmEnabled) {
                particles.forEach(p => p.Udm = 0);
                return;
            }
            
            particles.forEach(p => {
                // CST v2.0+ fix: Add epsilon to avoid division by zero at r=0
                const r = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z) + physics.epsilon;
                const r_rs = r / dmParams.rs;
                
                // NFW density profile: œÅ(r) = œÅ0 / ((r/rs) * (1 + r/rs)^2)
                // CST v2.0+ fix: Avoid division by zero - ensure r_rs > 0
                const rho = r_rs > 1e-10 ? dmParams.rho0 / (r_rs * Math.pow(1 + r_rs, 2)) : 0;
                
                // Simplified potential: Udm = -G * m * œÅ * 4œÄ * r^2 / 3
                p.Udm = -physics.G * p.mass * rho * 4 * Math.PI * r * r / 3;
            });
        }

        // 4) Synaptic strength Œ© with similarity
        function computeSynapticStrength(particles, index, physics, adapt) {
            particles.forEach((pi, i) => {
                let omegaSum = 0;
                const neighbors = queryNeighbors(i, particles, index, physics.rCutoff);
                pi.neighbors = neighbors;
                
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - pi.x;
                    const dy = pj.y - pi.y;
                    const dz = pj.z - pi.z;
                    const r2 = dx*dx + dy*dy + dz*dz;
                    const r_eff2 = r2 + physics.epsilon * physics.epsilon;
                    
                    // Gravitational coupling term
                    const gravTerm = (physics.G * pi.mass * pj.mass) / (r_eff2 * physics.a0 * physics.m0);
                    
                    // Gaussian similarity term
                    const x12Diff = pi.x12 - pj.x12;
                    const similarity = Math.exp(-(x12Diff * x12Diff) / (2 * adapt.sigmaSimilarity * adapt.sigmaSimilarity));
                    
                    omegaSum += gravTerm * similarity;
                });
                
                pi.omega = omegaSum;
            });
        }

        // 5) 12th dimension evolution and memory
        function updateAdaptiveStates(particles, adapt, dt) {
            particles.forEach(p => {
                // CST v2.0: Combined formula: dx12/dt = k¬∑(stimulus - Œ≥¬∑x12) + Œ±¬∑(m12 - x12)
                // where stimulus = Œ© (synaptic strength from neighbor interactions)
                const stimulus = p.omega; // Œ© from neighbor interactions
                const dx12 = (adapt.k * (stimulus - adapt.gamma * p.x12) + adapt.alpha * (p.m12 - p.x12)) * dt;
                p.x12 += dx12;
                
                // Bound x12 to [-1, 1]
                p.x12 = Math.max(-1, Math.min(1, p.x12));
                
                // dm12/dt = Œ± * (x12_i ‚àí m12_i) - exponential/rolling memory update
                const dm12 = adapt.alpha * (p.x12 - p.m12) * dt;
                p.m12 += dm12;
            });
        }

        // 6) Characteristic frequency and phase synchronization
        function updatePhases(particles, sync, index, dt) {
            particles.forEach((pi, i) => {
                // vi = Ec / h
                pi.vi = pi.Ec / h;
                
                // Kuramoto phase dynamics
                let phaseCoupling = 0;
                const neighbors = pi.neighbors || queryNeighbors(i, particles, index, physics.rCutoff);
                const degree = Math.max(1, neighbors.length);
                
                neighbors.forEach(j => {
                    const pj = particles[j];
                    phaseCoupling += Math.sin(pj.theta - pi.theta);
                });
                
                // dŒ∏i/dt = vi + (Ksync / deg_i) Œ£_j sin(Œ∏j ‚àí Œ∏i)
                const dtheta = (pi.vi + (sync.Ksync / degree) * phaseCoupling) * dt;
                pi.theta += dtheta;
                
                // Keep theta in [0, 2œÄ]
                pi.theta = ((pi.theta % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            });
        }

        function computeSynchronizationMetric(particles) {
            if (particles.length === 0) return { r: 0, meanTheta: 0 };
            
            let sumReal = 0;
            let sumImag = 0;
            
            particles.forEach(p => {
                sumReal += Math.cos(p.theta);
                sumImag += Math.sin(p.theta);
            });
            
            const r = Math.sqrt(sumReal*sumReal + sumImag*sumImag) / particles.length;
            const meanTheta = Math.atan2(sumImag, sumReal);
            
            return { r, meanTheta };
        }

        // 7) Entropy via coarse-graining
        function computeEntropy(particles, kB, bins = 32) {
            if (particles.length === 0) return 0;
            
            // Bin particle speeds
            const speeds = particles.map(p => {
                const v = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                return v;
            });
            
            const maxSpeed = Math.max(...speeds, 1);
            const histogram = new Array(bins).fill(0);
            
            speeds.forEach(v => {
                const bin = Math.min(bins - 1, Math.floor((v / maxSpeed) * bins));
                histogram[bin]++;
            });
            
            // Shannon entropy: S = -kB Œ£ p_b ln p_b
            let S = 0;
            histogram.forEach(count => {
                if (count > 0) {
                    const p = count / particles.length;
                    S -= p * Math.log(p);
                }
            });
            
            const entropy = kB * S;
            
            // Update per-particle entropy (use global for now)
            particles.forEach(p => {
                p.entropyS = entropy;
            });
            
            return entropy;
        }

        // 8) Energy and conservation diagnostics
        function computeConservationStats(particles) {
            let Etotal = 0;
            const P = { x: 0, y: 0, z: 0 };
            const L = { x: 0, y: 0, z: 0 };
            
            particles.forEach(p => {
                // Kinetic energy
                const v2 = p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z;
                const K = 0.5 * p.mass * v2;
                
                // Cosmic energy: Ec = K + Ugrav + Udm
                p.Ec = K + p.Ugrav + p.Udm;
                Etotal += p.Ec;
                
                // Momentum
                P.x += p.mass * p.velocity.x;
                P.y += p.mass * p.velocity.y;
                P.z += p.mass * p.velocity.z;
                
                // Angular momentum: L = r √ó (m v)
                L.x += p.mass * (p.y * p.velocity.z - p.z * p.velocity.y);
                L.y += p.mass * (p.z * p.velocity.x - p.x * p.velocity.z);
                L.z += p.mass * (p.x * p.velocity.y - p.y * p.velocity.x);
            });
            
            // Compute drift
            const now = Date.now();
            const timeDiff = (now - conservationStats.lastUpdate) / 1000;
            let drift = { E: 0, P: 0, L: 0 };
            
            if (conservationStats.E0 !== 0 && timeDiff > 0) {
                drift.E = Math.abs((Etotal - conservationStats.E0) / conservationStats.E0);
                const P0mag = Math.sqrt(conservationStats.P0.x**2 + conservationStats.P0.y**2 + conservationStats.P0.z**2);
                const Pmag = Math.sqrt(P.x**2 + P.y**2 + P.z**2);
                if (P0mag > 0) {
                    drift.P = Math.abs((Pmag - P0mag) / P0mag);
                }
                const L0mag = Math.sqrt(conservationStats.L0.x**2 + conservationStats.L0.y**2 + conservationStats.L0.z**2);
                const Lmag = Math.sqrt(L.x**2 + L.y**2 + L.z**2);
                if (L0mag > 0) {
                    drift.L = Math.abs((Lmag - L0mag) / L0mag);
        }
            }
            
            return { Etotal, P, L, drift };
        }
        
        function checkVirial(particles) {
            let Ksum = 0;
            let Usum = 0;
            
            particles.forEach(p => {
                const v2 = p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z;
                Ksum += 0.5 * p.mass * v2;
                Usum += p.Ugrav + p.Udm;
            });
            
            // Virial: 2<K> ‚âà -<U>
            const ratio = Math.abs(Usum) > 1e-10 ? (2 * Ksum) / Math.abs(Usum) : 1;
            const ok = Math.abs(ratio - 1) < 0.1; // Within 10% tolerance
            
            return { ratio, ok };
        }

        // --- NEW: œà term computation helpers (dimensionless) ---
        // Normalize a value safely by a reference; fallback to 1 to avoid NaN.
        function safeNormalize(value, ref) {
            const r = (typeof ref === 'number' && ref !== 0) ? ref : 1;
            const v = (typeof value === 'number' && isFinite(value)) ? value : 0;
            return v / r;
        }

        // Compute Œª (Lyapunov-like) from audio chaos and system derivatives
        function computeLambdaTerm(audioChaos, chaosDerivativeSum) {
            // Œª = log(1 + chaosDerivativeSum) / scale + audioChaos contribution
            const scale = 100; // mild normalization
            const base = Math.log(Math.abs(chaosDerivativeSum) + 1) / scale;
            return base + (isFinite(audioChaos) ? audioChaos : 0);
        }

        // Compute Œ© term = Œ£_i Œ©_i ¬∑ (Ec/Eref)
        function computeOmegaTerm(particles, Eref) {
            let sum = 0;
            for (const p of particles) {
                const normE = safeNormalize(p.Ec, Eref);
                const omega = (typeof p.omega === 'number' && isFinite(p.omega)) ? p.omega : 0;
                sum += omega * normE;
            }
            return sum;
        }

        // Compute potential term (U11D/Eref) including dark matter
        function computePotentialTerm(particles, Eref) {
            let sum = 0;
            for (const p of particles) {
                const U = ((p.Ugrav || 0) + (p.Udm || 0));
                sum += safeNormalize(U, Eref);
            }
            return sum;
        }

        // Compute energy term œÜ ¬∑ (Ec/Eref)
        function computeEnergyTerm(particles, Eref) {
            let sum = 0;
            for (const p of particles) {
                sum += phi * safeNormalize(p.Ec, Eref);
            }
            return sum;
        }

        // 9) œà normalization and breakdown
        function updatePsiNormalized(particles, refs, accum) {
            const terms = {
                energyTerm: 0,
                lambdaTerm: 0,
                velocityIntegralTerm: 0,
                x12IntegralTerm: 0,
                omegaTerm: 0,
                potentialTerm: 0
            };
            
            if (particles.length === 0) {
                return { terms, psiTotal: 0 };
            }
            
            // Accumulate ‚à´||v|| dt and ‚à´|Œîx12| dt per particle
            let chaosDerivativeSum = 0;
            
            particles.forEach((p, i) => {
                // CST v2.0+ fix: Use particle ID as key for stable accumulator indexing
                const pid = p.id;
                
                const vMag = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                chaosDerivativeSum += Math.abs(vMag);
                
                // Update velocity integral accumulator: ‚à´||v|| dt normalized by vref
                const vIntPrev = accum.velocityIntegral.get(pid) || 0;
                const vIntNew = vIntPrev + safeNormalize(vMag, refs.vref) * timestep.dt;
                accum.velocityIntegral.set(pid, vIntNew);
                
                // Update x12 integral accumulator: ‚à´|Œîx12| dt (dimensionless)
                const x12Prev = accum.x12Previous.get(pid);
                if (x12Prev !== undefined) {
                    const deltaX12 = Math.abs(p.x12 - x12Prev);
                    const x12IntPrev = accum.x12Integral.get(pid) || 0;
                    const x12IntNew = x12IntPrev + deltaX12 * timestep.dt;
                    accum.x12Integral.set(pid, x12IntNew);
                } else {
                    // First frame: initialize accumulator
                    accum.x12Integral.set(pid, 0);
                }
                accum.x12Previous.set(pid, p.x12); // Store current x12 for next frame
            });
            
            // Compute dimensionless terms using helper functions
            terms.energyTerm = computeEnergyTerm(particles, refs.Eref);
            terms.lambdaTerm = computeLambdaTerm(isAudioActive ? calculateAudioChaos() : 0, chaosDerivativeSum);
            terms.velocityIntegralTerm = Array.from(accum.velocityIntegral.values()).reduce((a, b) => a + b, 0);
            terms.x12IntegralTerm = Array.from(accum.x12Integral.values()).reduce((a, b) => a + b, 0);
            terms.omegaTerm = computeOmegaTerm(particles, refs.Eref);
            terms.potentialTerm = computePotentialTerm(particles, refs.Eref);
            
            const psiTotal = terms.energyTerm + terms.lambdaTerm + terms.velocityIntegralTerm + 
                           terms.x12IntegralTerm + terms.omegaTerm + terms.potentialTerm;
            
            return { terms, psiTotal };
        }

        // 10) Adaptive timestep
        function computeAdaptiveDt(particles, physics, timestepConfig) {
            if (!timestepConfig.adaptive || particles.length === 0) {
                return timestepConfig.dt;
            }
            
            let rMin = Infinity;
            let vMax = 0;
            
            particles.forEach(p => {
                const v = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                vMax = Math.max(vMax, v);
                
                // Find minimum distance to neighbors
                const neighbors = p.neighbors || [];
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - p.x;
                    const dy = pj.y - p.y;
                    const dz = pj.z - p.z;
                    const r = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        rMin = Math.min(rMin, r);
                });
            });
            
            if (rMin === Infinity) rMin = 1.0;
            if (vMax === 0) vMax = 1.0;
            
            // CST v2.0+ additive: Enhanced adaptive timestep with proper clamping
            // dt = min(dtMax, 0.1 * r_min / v_max)
            const dt = Math.min(timestepConfig.dtMax, 0.1 * rMin / vMax);
            // Clamp to [0.001, dtMax] for stability (per spec)
            return Math.max(0.001, Math.min(dt, timestepConfig.dtMax));
        }

        // CST v2.0 additive: Enhanced deterministic replay mode
        // 11) Deterministic replay mode
        function recordAudioFrame(frame) {
            if (determinism.isRecording) {
                // CST v2.0 additive: Record complete frame data for deterministic replay
                determinism.recordedAudioFrames.push({
                    timestamp: Date.now() / 1000,
                    rmsEnergy: frame.rmsEnergy,
                    frequencyData: JSON.parse(JSON.stringify(frame.frequencyData)), // Deep copy
                    spectralCentroid: frame.spectralCentroid,
                    harmonics: frame.harmonics ? JSON.parse(JSON.stringify(frame.harmonics)) : [],
                    dataArray: frame.dataArray ? Array.from(frame.dataArray) : null // Store raw FFT data
                });
            }
        }

        // CST v2.0 additive: Enhanced replay mode with deterministic seed reset
        function toggleReplayMode(data) {
            if (data && data.recordedAudioFrames) {
                determinism.mode = 'replay';
                determinism.recordedAudioFrames = JSON.parse(JSON.stringify(data.recordedAudioFrames)); // Deep copy
                determinism.replayIndex = 0;
                
                // CST v2.0 additive: Reset seed for deterministic replay
                const seed = data.seed || determinism.seed || 12345;
                setDeterministicSeed(seed);
                
                // CST v2.0 fix: Reset deterministicRandom to ensure clean RNG state
                deterministicRandom = seed;
                
                // CST v2.0+ additive: Reset token arrays and counters for clean replay
                tokens = [];
                tokenCount = 0;
                tokenRateWindow.timestamps = [];
                replicationCount = 0;
                deterministicIdCounter = 0; // Reset deterministic ID counter
                
                // CST v2.0+ additive: Reset œà accumulators, conservation stats, and entropy
                resetIntegralsAndConservation();
                updateEntropy(); // Update UI immediately
                
                // CST v2.0+ additive: Reset particles to initial state if needed
                // (Optional: could reset particles array here for full determinism)
                // Note: For full determinism, particles should be reset to initial state
                // or replay should start with a known particle configuration
                
                // Start replay processing
                startReplayProcessing();
            } else {
                determinism.mode = 'live';
                determinism.recordedAudioFrames = [];
                stopReplayProcessing();
            }
        }

        // CST v2.0+ additive: Helper function to reset integrals and conservation stats
        function resetIntegralsAndConservation() {
            // Reset œà accumulators
            psiAccumulators.velocityIntegral.clear();
            psiAccumulators.x12Integral.clear();
            psiAccumulators.x12Previous.clear();
            
            // Reset conservation stats
            conservationStats.E0 = 0;
            conservationStats.P0 = { x: 0, y: 0, z: 0 };
            conservationStats.L0 = { x: 0, y: 0, z: 0 };
            conservationStats.lastUpdate = Date.now();
            
            // Reset entropy state
            entropyState.histogram = new Array(entropyState.bins).fill(0);
            entropyState.lastEntropy = 0;
            entropyState.tempProxy = 0;
            entropyTrace.length = 0;
            // NEW: Reset entropy smoothing EMA
            entropyEma = null;
        }

        // CST v2.0 additive: Enhanced deterministic replay processing
        // Process recorded audio frames in replay mode
        function processReplayAudio() {
            if (determinism.mode !== 'replay' || determinism.recordedAudioFrames.length === 0) {
                stopReplayProcessing();
                return;
            }

            // Get current frame
            const frame = determinism.recordedAudioFrames[determinism.replayIndex];
            if (!frame) {
                // Loop back to start
                determinism.replayIndex = 0;
                return;
            }

            // CST v2.0 additive: Deep copy frequency data to avoid mutation
            audioEnergy = frame.rmsEnergy || 0;
            frequencyData = JSON.parse(JSON.stringify(frame.frequencyData || []));
            spectralCentroid = frame.spectralCentroid || 0;

            // Update displays
            const rmsEl = document.getElementById('rms-energy');
            const dominantEl = document.getElementById('dominant-freq');
            const centroidEl = document.getElementById('spectral-centroid');
            const gainEl = document.getElementById('audio-gain');
            
            if (rmsEl) rmsEl.textContent = audioEnergy.toFixed(3);
            if (gainEl) gainEl.textContent = (1 + audioEnergy * audioSensitivity).toFixed(2);
            if (frequencyData.length > 0 && dominantEl) {
                dominantEl.textContent = frequencyData[0].frequency.toFixed(1);
            }
            if (centroidEl) centroidEl.textContent = spectralCentroid.toFixed(1);

            // CST v2.0 additive: Generate tokens with deterministic RNG (already set via seed)
            generateTokens(frequencyData, audioEnergy, spectralCentroid);

            // Update chaos measure
            const chaos = calculateAudioChaos();
            const chaosEl = document.getElementById('audio-chaos');
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);

            // Move to next frame
            determinism.replayIndex = (determinism.replayIndex + 1) % determinism.recordedAudioFrames.length;
        }

        function startReplayProcessing() {
            stopReplayProcessing(); // Clear any existing interval
            if (determinism.mode === 'replay' && determinism.recordedAudioFrames.length > 0) {
                // CST v2.0+ additive: Reset deterministic ID counter for replay
                deterministicIdCounter = 0;
                // Process immediately, then at configured cadence
                processReplayAudio();
                determinism.replayInterval = setInterval(processReplayAudio, audioConfig.cadence);
                startTokenBufferFlush();
            }
        }

        function stopReplayProcessing() {
            if (determinism.replayInterval) {
                clearInterval(determinism.replayInterval);
                determinism.replayInterval = null;
            }
            stopTokenBufferFlush();
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a1a, 0.002);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(50, 30, 50);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x0a0a1a, 0.5);
            container.appendChild(renderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Add initial particle
            addParticle();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }

        function initFrequencyCanvas() {
            freqCanvas = document.getElementById('frequencyCanvas');
            if (freqCanvas) {
            freqCtx = freqCanvas.getContext('2d');
                freqCanvas.width = freqCanvas.offsetWidth || 400;
                freqCanvas.height = freqCanvas.offsetHeight || 150;
                
                // Handle window resize for frequency canvas
                window.addEventListener('resize', () => {
                    if (freqCanvas) {
                        freqCanvas.width = freqCanvas.offsetWidth || 400;
                        freqCanvas.height = freqCanvas.offsetHeight || 150;
                    }
                });
            }
        }

        // CST v2.0+ additive: Initialize entropy canvas
        function initEntropyCanvas() {
            const canvas = document.getElementById('entropyCanvas');
            if (canvas) {
                entropyState.ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth || 400;
                canvas.height = 100;
                
                // Handle window resize for entropy canvas
                window.addEventListener('resize', () => {
                    if (canvas) {
                        canvas.width = canvas.offsetWidth || 400;
                        canvas.height = 100;
                        // Redraw histogram on resize
                        if (entropyState.histogram) {
                            drawEntropyHistogram(entropyState.histogram);
                        }
                    }
                });
            }
            
            // CST v2.0+ additive: Initialize entropy trace canvas
            const traceCanvas = document.getElementById('entropyTraceCanvas');
            if (traceCanvas) {
                entropyState.traceCtx = traceCanvas.getContext('2d');
                traceCanvas.width = traceCanvas.offsetWidth || 400;
                traceCanvas.height = 60;
                
                // Handle window resize for trace canvas
                window.addEventListener('resize', () => {
                    if (traceCanvas) {
                        const oldWidth = traceCanvas.width;
                        traceCanvas.width = traceCanvas.offsetWidth || 400;
                        traceCanvas.height = 60;
                        
                        // Adjust trace buffer size if canvas width changed
                        const newWidth = traceCanvas.width;
                        if (newWidth !== oldWidth && entropyTrace.length > 0) {
                            // Trim or pad trace buffer to match new canvas width
                            if (entropyTrace.length > newWidth) {
                                // Remove oldest entries
                                entropyTrace.splice(0, entropyTrace.length - newWidth);
                            }
                            // Redraw trace immediately after resize
                            if (entropyState.lastEntropy !== undefined) {
                                drawEntropyTrace(entropyState.lastEntropy);
                            }
                        }
                    }
                });
            }
        }
        
        // --- NEW: adaptive state canvas init ---
        function initAdaptiveStateCanvas() {
            const canvas = document.getElementById('adaptiveStateCanvas');
            if (!canvas) return;
            adaptiveStateCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth || 400;
            canvas.height = 120;

            window.addEventListener('resize', () => {
                if (!adaptiveStateCtx) return;
                const c = adaptiveStateCtx.canvas;
                c.width = c.offsetWidth || 400;
                c.height = 120;
            });
        }
        
        // --- NEW: dark matter profile canvas init ---
        function initDmProfileCanvas() {
            const canvas = document.getElementById('dmProfileCanvas');
            if (!canvas) return;
            dmProfileCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth || 400;
            canvas.height = 120;
            window.addEventListener('resize', () => {
                if (!dmProfileCtx) return;
                const c = dmProfileCtx.canvas;
                c.width = c.offsetWidth || 400;
                c.height = 120;
            });
        }

        // CST v2.0+ additive: Projection mode functions
        function orthogonalProjection(p) {
            // Identity mapping: replicate x,y,z with variations
            const scale = 0.1;
            for (let i = 0; i < 11; i++) {
                const dim = i % 3;
                const coord = dim === 0 ? p.x : (dim === 1 ? p.y : p.z);
                p.projection11D.pos11D[i] = coord * (1 + i * scale);
                p.projection11D.vel11D[i] = (dim === 0 ? p.velocity.x : (dim === 1 ? p.velocity.y : p.velocity.z)) * (1 + i * scale);
            }
        }

        function randomEmbeddingProjection(p) {
            // Seeded random projection matrix (deterministic in replay mode)
            if (!projectionConfig.randomR) {
                // Initialize random projection matrix (11x3)
                projectionConfig.randomR = [];
                const seed = determinism.mode === 'replay' && determinism.seed !== null 
                    ? determinism.seed 
                    : projectionConfig.randomSeed;
                let rng = seed;
                
                for (let i = 0; i < 11; i++) {
                    projectionConfig.randomR[i] = [];
                    for (let j = 0; j < 3; j++) {
                        rng = (rng * 1103515245 + 12345) & 0x7fffffff;
                        projectionConfig.randomR[i][j] = (rng / 0x7fffffff) * 2 - 1; // [-1, 1]
                    }
                }
            }
            
            // Project 3D position to 11D using random matrix
            const pos3D = [p.x, p.y, p.z];
            const vel3D = [p.velocity.x, p.velocity.y, p.velocity.z];
            
            for (let i = 0; i < 11; i++) {
                let posSum = 0;
                let velSum = 0;
                for (let j = 0; j < 3; j++) {
                    posSum += projectionConfig.randomR[i][j] * pos3D[j];
                    velSum += projectionConfig.randomR[i][j] * vel3D[j];
                }
                p.projection11D.pos11D[i] = posSum;
                p.projection11D.vel11D[i] = velSum;
            }
        }

        function learnedEmbeddingProjection(p) {
            // Learned embedding: use learnedWeights if available, otherwise fallback to orthogonal
            if (projectionConfig.learnedWeights && projectionConfig.learnedWeights.length === 11) {
                // Use learned weights for projection
                for (let i = 0; i < 11; i++) {
                    if (projectionConfig.learnedWeights[i] && projectionConfig.learnedWeights[i].length === 3) {
                        p.projection11D.pos11D[i] = 
                            projectionConfig.learnedWeights[i][0] * p.x +
                            projectionConfig.learnedWeights[i][1] * p.y +
                            projectionConfig.learnedWeights[i][2] * p.z;
                        p.projection11D.vel11D[i] = 
                            projectionConfig.learnedWeights[i][0] * p.velocity.x +
                            projectionConfig.learnedWeights[i][1] * p.velocity.y +
                            projectionConfig.learnedWeights[i][2] * p.velocity.z;
                    } else {
                        // Fallback to orthogonal for this dimension
                        const dim = i % 3;
                        const coord = dim === 0 ? p.x : (dim === 1 ? p.y : p.z);
                        p.projection11D.pos11D[i] = coord;
                        p.projection11D.vel11D[i] = (dim === 0 ? p.velocity.x : (dim === 1 ? p.velocity.y : p.velocity.z));
                    }
                }
            } else {
                // Fallback to orthogonal if no learned weights
                orthogonalProjection(p);
            }
        }

        // CST v2.0+ additive: Compute entropy metrics from particle speeds
        function computeEntropyMetrics() {
            const bins = 32;
            const histogram = new Array(bins).fill(0);
            let totalSpeed = 0;
            
            if (particles.length === 0) {
                return { entropy: 0, histogram, tempProxy: 0 };
            }
            
            // Compute speeds first
            const speeds = particles.map(p => {
                const speed = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                totalSpeed += speed;
                return speed;
            });
            
            // Find max speed for normalization - CST v2.0+ fix: Handle empty speeds array
            const maxSpeed = speeds.length > 0 ? Math.max(...speeds, 1) : 1;
            
            // Bin particle speeds into histogram
            speeds.forEach(speed => {
                const bin = Math.min(bins - 1, Math.floor((speed / maxSpeed) * bins));
                histogram[bin]++;
            });
            
            // Normalize to probabilities
            const total = particles.length || 1;
            const probs = histogram.map(c => c / total);
            
            // Compute Shannon entropy: S = -Œ£ p_b ln p_b
            let S = 0;
            probs.forEach(p => {
                if (p > 0) {
                    S -= p * Math.log(p);
                }
            });
            
            // Temperature proxy from mean particle speed
            const tempProxy = totalSpeed / total;
            
            return { entropy: S, histogram, tempProxy };
        }
        
        // CST v2.0+ additive: Update entropy metrics and UI
        function updateEntropy() {
            if (particles.length === 0) {
                // Reset entropy state and update UI to zeros
                entropyState.histogram = new Array(entropyState.bins).fill(0);
                entropyState.lastEntropy = 0;
                entropyState.tempProxy = 0;
                entropyTrace.length = 0; // CST v2.0+ additive: Clear entropy trace
                
                const entropyEl = document.getElementById('entropy-global');
                const binsEl = document.getElementById('entropy-bins');
                const tempEl = document.getElementById('entropy-temperature');
                
                if (entropyEl) entropyEl.textContent = '0.000';
                if (binsEl) binsEl.textContent = '[]';
                if (tempEl) tempEl.textContent = '0.000';
                // CST v2.0+ additive: Clear trace when no particles - draw empty trace
                if (entropyState.traceCtx) {
                    const ctx = entropyState.traceCtx;
                    const canvas = ctx.canvas;
                    const width = canvas.width || 400;
                    const height = canvas.height || 60;
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
                    ctx.fillRect(0, 0, width, height);
                    // Draw baseline
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, height / 2);
                    ctx.lineTo(width, height / 2);
                    ctx.stroke();
                }
                return;
            }
            
            // Compute entropy metrics
            const { entropy, histogram, tempProxy } = computeEntropyMetrics();
            
            // Store in state
            entropyState.lastEntropy = kB * entropy;
            entropyState.histogram = histogram;
            entropyState.tempProxy = tempProxy;
            
            // Update UI
            const entropyEl = document.getElementById('entropy-global');
            const binsEl = document.getElementById('entropy-bins');
            const tempEl = document.getElementById('entropy-temperature');
            
            if (entropyEl) entropyEl.textContent = entropyState.lastEntropy.toFixed(3);
            if (binsEl) binsEl.textContent = JSON.stringify(histogram.slice(0, 5)); // Show first 5 bins as preview
            if (tempEl) tempEl.textContent = entropyState.tempProxy.toFixed(3);
            
            // CST v2.0+ additive: Draw entropy trace after updating metrics
            drawEntropyTrace(entropyState.lastEntropy);
        }
        
        // CST v2.0+ additive: Draw scrolling entropy trace (heart-rate monitor style)
        function drawEntropyTrace(entropyValue) {
            if (!entropyState.traceCtx) return;
            
            // Apply exponential moving average smoothing
            const smoothed = getSmoothedEntropy(entropyValue);
            
            const ctx = entropyState.traceCtx;
            const canvas = ctx.canvas;
            const width = canvas.width || 400;
            const height = canvas.height || 60;
            
            // Add new entropy value to trace buffer (only if it's a valid number)
            if (typeof smoothed === 'number' && !isNaN(smoothed) && isFinite(smoothed)) {
                entropyTrace.push(smoothed);
            }
            
            // Limit trace buffer to canvas width (ensure we don't exceed it)
            while (entropyTrace.length > width) {
                entropyTrace.shift();
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw baseline at mid-height
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
            
            // Draw trace line
            if (entropyTrace.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = '#00ffcc'; // Bright cyan
                ctx.lineWidth = 2;
                
                // Auto-scale based on min/max in trace (like heart-rate monitor)
                const validValues = entropyTrace.filter(v => typeof v === 'number' && !isNaN(v) && isFinite(v));
                if (validValues.length > 0) {
                    const minEntropy = Math.min(...validValues);
                    const maxEntropy = Math.max(...validValues);
                    const range = Math.max(maxEntropy - minEntropy, 0.001); // Avoid division by zero
                    
                    // Use 80% of canvas height for the trace, centered
                    const traceHeight = height * 0.8;
                    const baseline = height / 2;
                    
                    // Draw the trace line
                    let firstPoint = true;
                    entropyTrace.forEach((val, i) => {
                        if (typeof val === 'number' && !isNaN(val) && isFinite(val)) {
                            const x = i;
                            // Normalize to [0, 1] then scale and center around baseline
                            const normalized = (val - minEntropy) / range;
                            const y = baseline + (traceHeight / 2) - (normalized * traceHeight);
                            
                            // Clamp y to canvas bounds
                            const clampedY = Math.max(0, Math.min(height, y));
                            
                            if (firstPoint) {
                                ctx.moveTo(x, clampedY);
                                firstPoint = false;
                            } else {
                                ctx.lineTo(x, clampedY);
                            }
                        }
                    });
                    
                    ctx.stroke();
                }
            } else if (entropyTrace.length === 1) {
                // Draw a single point if only one value
                const val = entropyTrace[0];
                if (typeof val === 'number' && !isNaN(val) && isFinite(val)) {
                    ctx.fillStyle = '#00ffcc';
                    ctx.beginPath();
                    ctx.arc(0, height / 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // CST v2.0+ additive: Draw entropy histogram
        function drawEntropyHistogram(histogram) {
            if (!entropyState.ctx) return;
            
            const ctx = entropyState.ctx;
            const canvas = ctx.canvas;
            const width = canvas.width;
            const height = canvas.height;
            
            // Use provided histogram or fall back to state
            const hist = histogram || entropyState.histogram || new Array(entropyState.bins).fill(0);
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw histogram bars with gradient colors
            const barW = width / entropyState.bins;
            const maxCount = Math.max(...hist, 1);
            
            for (let i = 0; i < entropyState.bins; i++) {
                const barH = (hist[i] / maxCount) * height;
                const hue = (i / entropyState.bins) * 360;
                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.fillRect(i * barW, height - barH, barW - 1, barH);
            }
        }
        
        // --- NEW: adaptive state updater ---
        function updateAdaptiveStateTrace() {
            if (!adaptiveStateCtx) return;
            const ctx = adaptiveStateCtx;
            const c = ctx.canvas;
            const width = c.width || 400;
            const height = c.height || 120;

            // Extend x12History to number of particles
            while (x12History.length < particles.length) x12History.push([]);
            // Trim if particles removed
            if (x12History.length > particles.length) x12History.length = particles.length;

            // Append current x12 to each particle's history
            particles.forEach((p, i) => {
                const val = (typeof p.x12 === 'number' && isFinite(p.x12)) ? p.x12 : 0;
                x12History[i].push(val);
                while (x12History[i].length > width) x12History[i].shift();
            });

            // Draw background
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            ctx.fillRect(0, 0, width, height);

            // Draw baseline at y=0 centered
            const baseline = height / 2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.moveTo(0, baseline);
            ctx.lineTo(width, baseline);
            ctx.stroke();

            // Draw each particle's trace
            particles.forEach((p, i) => {
                const colorHex = '#' + p.color.toString(16).padStart(6, '0');
                ctx.strokeStyle = colorHex;
                ctx.lineWidth = 1;
                ctx.beginPath();
                let first = true;
                const hist = x12History[i];
                for (let x = 0; x < hist.length; x++) {
                    // x12 in [-1,1] mapped to vertical extent
                    const y = baseline - (hist[x] * (height * 0.45));
                    const clampedY = Math.max(0, Math.min(height, y));
                    if (first) { ctx.moveTo(x, clampedY); first = false; } else { ctx.lineTo(x, clampedY); }
                }
                ctx.stroke();
            });
        }
        
        // --- NEW: dark matter profile plot ---
        function drawNfwProfile(rho0, rs) {
            if (!dmProfileCtx) return;
            const ctx = dmProfileCtx;
            const c = ctx.canvas;
            const width = c.width || 400;
            const height = c.height || 120;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(10,10,26,0.25)';
            ctx.fillRect(0, 0, width, height);

            // r from 0.1*rs to 10*rs (avoid 0 singularity)
            const samples = 200;
            const rMin = Math.max(0.1 * rs, 1e-6);
            const rMax = 10 * rs;
            let values = [];
            for (let i = 0; i < samples; i++) {
                const t = i / (samples - 1);
                const r = rMin * Math.pow(rMax / rMin, t); // log spacing
                const r_rs = r / rs;
                const rho = r_rs > 0 ? rho0 / (r_rs * Math.pow(1 + r_rs, 2)) : 0;
                values.push({ r, rho });
            }

            const rhoMax = Math.max(...values.map(v => v.rho), 1e-12);
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.beginPath();

            values.forEach((v, i) => {
                const x = (i / (samples - 1)) * width;
                const y = height - (Math.log(v.rho + 1) / Math.log(rhoMax + 1)) * height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }
        
        // --- NEW: theta std deviation ---
        function computeThetaStd(particles) {
            if (!particles || particles.length === 0) return 0;
            const thetas = particles.map(p => p.theta);
            const mean = thetas.reduce((a,b)=>a+b,0)/thetas.length;
            const variance = thetas.reduce((a,b)=>a + (b - mean)**2, 0) / thetas.length;
            return Math.sqrt(variance);
        }
        
        // --- NEW: replay validation updater ---
        function updateReplayValidation(consStats, virial) {
            if (determinism.mode !== 'replay') return;
            const edriftEl = document.getElementById('replay-edrift');
            const pmagEl = document.getElementById('replay-pmag');
            const lmagEl = document.getElementById('replay-lmag');
            const virialEl = document.getElementById('replay-virial');
            if (!edriftEl || !pmagEl || !lmagEl || !virialEl) return;

            edriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
            const Pmag = Math.sqrt(consStats.P.x**2 + consStats.P.y**2 + consStats.P.z**2);
            const Lmag = Math.sqrt(consStats.L.x**2 + consStats.L.y**2 + consStats.L.z**2);
            pmagEl.textContent = Pmag.toExponential(2);
            lmagEl.textContent = Lmag.toExponential(2);
            virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
        }
        
        // --- NEW: package œà terms for tokens ---
        function currentPsiSnapshot() {
            const psiResult = updatePsiNormalized(particles, physics, psiAccumulators);
            return {
                energyTerm: parseFloat(psiResult.terms.energyTerm.toFixed(6)),
                lambdaTerm: parseFloat(psiResult.terms.lambdaTerm.toFixed(6)),
                velocityIntegralTerm: parseFloat(psiResult.terms.velocityIntegralTerm.toFixed(6)),
                x12IntegralTerm: parseFloat(psiResult.terms.x12IntegralTerm.toFixed(6)),
                omegaTerm: parseFloat(psiResult.terms.omegaTerm.toFixed(6)),
                potentialTerm: parseFloat(psiResult.terms.potentialTerm.toFixed(6)),
                psiTotal: parseFloat(psiResult.psiTotal.toFixed(6))
            };
        }

        // CST v2.0+ additive: Audio setup helpers
        async function startAudio() {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
            analyser.fftSize = audioConfig.fftSize; // Use configurable FFT size
                    bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);
        }
        
        // CST v2.0+ additive: Restart audio processing loop with new cadence
        function restartAudioProcessingLoop() {
            if (audioProcessingInterval) {
                clearInterval(audioProcessingInterval);
                audioProcessingInterval = null;
            }
            if (isAudioActive && analyser) {
                // Process immediately, then at configured cadence
                    processAudio();
                audioProcessingInterval = setInterval(processAudio, audioConfig.cadence);
            }
        }
        
        // CST v2.0+ additive: Restart replay loop with new cadence
        function restartReplayLoop() {
            if (determinism.replayInterval) {
                clearInterval(determinism.replayInterval);
                determinism.replayInterval = null;
            }
            if (determinism.mode === 'replay' && determinism.recordedAudioFrames.length > 0) {
                processReplayAudio();
                determinism.replayInterval = setInterval(processReplayAudio, audioConfig.cadence);
            }
        }
        
        // CST v2.0+ additive: Start token buffer flush loop
        function startTokenBufferFlush() {
            if (tokenBuffer.flushInterval) {
                clearInterval(tokenBuffer.flushInterval);
            }
            tokenBuffer.flushInterval = setInterval(() => {
                flushTokenBuffer();
            }, tokenBuffer.flushRate);
            
            // CST v2.0+ additive: Start periodic token rate updates at ~500ms cadence
            if (tokenRateUpdateInterval) {
                clearInterval(tokenRateUpdateInterval);
            }
            tokenRateUpdateInterval = setInterval(() => {
                updateTokenRate();
            }, 500);
        }
        
        // CST v2.0+ additive: Stop token buffer flush loop
        function stopTokenBufferFlush() {
            if (tokenBuffer.flushInterval) {
                clearInterval(tokenBuffer.flushInterval);
                tokenBuffer.flushInterval = null;
            }
            // CST v2.0+ additive: Stop token rate update interval
            if (tokenRateUpdateInterval) {
                clearInterval(tokenRateUpdateInterval);
                tokenRateUpdateInterval = null;
            }
            // Flush any remaining tokens
            flushTokenBuffer();
        }
        
        // CST v2.0+ additive: Flush token buffer to UI
        function flushTokenBuffer() {
            if (tokenBuffer.tokens.length === 0) return;
            
            // Add buffered tokens to main tokens array
            tokenBuffer.tokens.forEach(token => {
                tokens.push(token);
                tokenCount++;
            });
            
            // Update token display (bounded to limit)
            updateTokenDisplay();
            
            // Update counters
            const countEl = document.getElementById('token-count');
            const countStatusEl = document.getElementById('token-count-status');
            const replEl = document.getElementById('replication-count');
            if (countEl) countEl.textContent = tokens.length;
            if (countStatusEl) countStatusEl.textContent = tokens.length;
            if (replEl) replEl.textContent = replicationCount;
            
            // Clear buffer
            tokenBuffer.tokens = [];
        }

        function stopAudio() {
            if (audioProcessingInterval) {
                clearInterval(audioProcessingInterval);
                audioProcessingInterval = null;
            }
            stopTokenBufferFlush();
                if (microphone) {
                    microphone.disconnect();
                    microphone = null;
                }
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
                isAudioActive = false;
            const button = document.getElementById('micButton');
            const indicator = document.getElementById('audioIndicator');
            if (button) {
                button.textContent = 'üé§ START MICROPHONE ENGINE';
                button.classList.remove('active');
            }
            if (indicator) indicator.classList.remove('active');
            const tokenIndicator = document.getElementById('tokenIndicator');
            if (tokenIndicator) tokenIndicator.classList.remove('active');
            updateStatus('Audio engine stopped');
        }

        function computeFFTFrame() {
            if (!analyser || !dataArray || bufferLength === 0) return { frequencies: [], rms: 0, centroid: 0, raw: [] };
            
            // Frequency-domain
            analyser.getByteFrequencyData(dataArray);
            const freqBins = Array.from(dataArray);
            const sr = audioContext.sampleRate;
            const top = freqBins
                .map((v, idx) => ({ v, idx }))
                .sort((a, b) => b.v - a.v)
                .slice(0, 10)
                .map(({ v, idx }) => ({
                    frequency: (idx * sr) / (2 * bufferLength),
                    magnitude: v / 255
                }))
                .filter(f => f.magnitude > 0.05); // Filter low magnitude
            
            // Time-domain RMS
            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const normalized = (dataArray[i] - 128) / 128;
                sum += normalized * normalized;
            }
            const rms = Math.sqrt(sum / dataArray.length);
            
            // Spectral centroid
            analyser.getByteFrequencyData(dataArray);
            let wSum = 0;
            let mSum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const freq = (i * sr) / (2 * bufferLength);
                wSum += freq * dataArray[i];
                mSum += dataArray[i];
            }
            const centroid = mSum > 0 ? wSum / mSum : 0;
            
            return { frequencies: top, rms, centroid, raw: Array.from(dataArray) };
        }

        async function toggleMicrophone() {
            const button = document.getElementById('micButton');
            const indicator = document.getElementById('audioIndicator');
            
            if (!isAudioActive) {
                try {
                    await startAudio();
                    isAudioActive = true;
                    if (button) {
                        button.textContent = 'üé§ STOP MICROPHONE';
                        button.classList.add('active');
                    }
                    if (indicator) indicator.classList.add('active');
                    updateStatus('üéµ Audio engine active - CONTINUOUSLY generating tokens from audio stream');
                    
                    // CST v2.0+ fix: Use configurable cadence
                    restartAudioProcessingLoop();
                    startTokenBufferFlush();
                } catch (err) {
                    console.error('Microphone access error:', err);
                    updateStatus('‚ùå Microphone access denied. Please grant permission and try again.');
                    alert('Could not access microphone. Please grant permission.');
                    stopAudio();
                }
            } else {
                stopAudio();
                // Stop replay if active
                if (determinism.mode === 'replay') {
                    stopReplayProcessing();
                }
            }
        }

        // Token generation function - called every 100ms from processAudio()
        // CST v2.0+ fix: Handle silent input gracefully - still generate frame tokens
        function generateTokens(frequencyData, rmsEnergy, spectralCentroid) {
            // Ensure frequencyData is an array (handle null/undefined)
            if (!frequencyData) frequencyData = [];

            // Use default fundamental frequency if no frequencies detected (silent input)
            const fundamental = frequencyData.length > 0 ? frequencyData[0].frequency : 0;
            const harmonics = fundamental > 0 ? generatePhiHarmonics(fundamental, 8) : [];
            const harmonicsCountEl = document.getElementById('harmonics-count');
            if (harmonicsCountEl) harmonicsCountEl.textContent = harmonics.length;

            // CST v2.0+ additive: Record complete audio frame for deterministic replay
            if (determinism.isRecording) {
                recordAudioFrame({
                    rmsEnergy: rmsEnergy,
                    frequencyData: frequencyData,
                    spectralCentroid: spectralCentroid,
                    harmonics: harmonics,
                    dataArray: dataArray ? Array.from(dataArray) : null // Store raw FFT data
                });
            }

            // CST v2.0+ fix: Always generate Audio Frame Token (even with silent input)
            generateAudioFrameToken(
                frequencyData,
                rmsEnergy,
                spectralCentroid,
                harmonics
            );

            // CST v2.0+ fix: Only process frequencies if available
            if (frequencyData.length > 0) {
            // Map each frequency to visual particles continuously
            frequencyData.forEach((freqData, idx) => {
                // Sound-to-color mapping
                const colorHue = (freqData.frequency / 20000) * 360;
                const color = new THREE.Color(`hsl(${colorHue}, ${freqData.magnitude * 100}%, 50%)`);
                
                // Create or update particle for this frequency
                if (particles.length < 20) {
                    createParticleFromFrequency(freqData.frequency, freqData.magnitude, color.getHex());
                } else {
                    // Update existing particles with frequency assignment
                    const targetParticle = particles[idx % particles.length];
                    if (targetParticle) {
                        updateParticleFromAudio(targetParticle, freqData.frequency, freqData.magnitude, color.getHex());
                    }
                }
            });

            // Generate œÜ-Harmonic Tokens for each harmonic
            harmonics.forEach((harmonic, idx) => {
                if (idx < frequencyData.length) {
                    generateHarmonicToken(harmonic, frequencyData[idx].magnitude, idx);
                }
            });
            }
        }

        // CST v2.0 fix: Use setInterval for exact 100ms cadence (no drift)
        function processAudio() {
            if (!isAudioActive || !analyser) return;

            const tokenIndicator = document.getElementById('tokenIndicator');
            if (tokenIndicator) tokenIndicator.classList.add('active');

            const frame = computeFFTFrame();
            audioEnergy = frame.rms || 0;
            frequencyData = frame.frequencies || [];
            spectralCentroid = frame.centroid || 0;

            // Update displays
            const rmsEl = document.getElementById('rms-energy');
            const dominantEl = document.getElementById('dominant-freq');
            const centroidEl = document.getElementById('spectral-centroid');
            const gainEl = document.getElementById('audio-gain');

            if (rmsEl) rmsEl.textContent = audioEnergy.toFixed(3);
            if (gainEl) gainEl.textContent = (1 + audioEnergy * audioSensitivity).toFixed(2);
            if (frequencyData.length > 0 && dominantEl) {
                dominantEl.textContent = frequencyData[0].frequency.toFixed(1);
            } else if (dominantEl) {
                dominantEl.textContent = '0.0';
            }
            if (centroidEl) centroidEl.textContent = spectralCentroid.toFixed(1);

            // Generate tokens and visualization
            generateTokens(frequencyData, audioEnergy, spectralCentroid);

            // Chaos display
            const chaos = calculateAudioChaos();
            const chaosEl = document.getElementById('audio-chaos');
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);
        }

        function generatePhiHarmonics(fundamental, count) {
            const harmonics = [];
            for (let i = 0; i < count; i++) {
                let freq = fundamental * Math.pow(phi, i / 2);
                
                // Octave folding
                while (freq > fundamental * 4) {
                    freq /= 2;
                }
                while (freq < fundamental / 2) {
                    freq *= 2;
                }
                
                harmonics.push(freq);
            }
            return harmonics.sort((a, b) => a - b);
        }

        function generateParticleToken(particle, eventType = 'creation') {
            // Token structure from 12D CST specification (extended with new fields)
            const token = {
                id: nextDeterministicId(), // Use deterministic ID in replay mode
                particleId: particle.id,
                frequency: parseFloat(particle.frequency.toFixed(2)),
                energy: parseFloat(particle.energy.toFixed(6)), // Legacy
                position: [
                    parseFloat(particle.x.toFixed(4)),
                    parseFloat(particle.y.toFixed(4)),
                    parseFloat(particle.z.toFixed(4))
                ],
                velocity: [
                    parseFloat(particle.velocity.x.toFixed(4)),
                    parseFloat(particle.velocity.y.toFixed(4)),
                    parseFloat(particle.velocity.z.toFixed(4))
                ],
                mass: parseFloat(particle.mass.toFixed(3)),
                entropy: parseFloat(particle.entropy.toFixed(3)), // Legacy
                timestamp: Date.now() / 1000, // Unix timestamp
                parent: particle.parent || null,
                eventType: eventType, // 'creation', 'replication', 'frequency_assignment'
                color: '#' + particle.color.toString(16).padStart(6, '0'),
                // 12D CST new fields
                x12: parseFloat(particle.x12.toFixed(4)),
                m12: parseFloat(particle.m12.toFixed(4)),
                Ec: parseFloat(particle.Ec.toFixed(6)),
                Ugrav: parseFloat(particle.Ugrav.toFixed(6)),
                Udm: parseFloat(particle.Udm.toFixed(6)),
                vi: parseFloat(particle.vi.toFixed(2)),
                theta: parseFloat(particle.theta.toFixed(4)),
                omega: parseFloat(particle.omega.toFixed(6)),
                entropyS: parseFloat(particle.entropyS.toFixed(6)),
                neighborCount: particle.neighbors ? particle.neighbors.length : 0,
                // CST v2.0+ additive: Include 11D projection data
                projection11D: {
                    pos11D: Array.from(particle.projection11D.pos11D).map(v => parseFloat(v.toFixed(6))),
                    vel11D: Array.from(particle.projection11D.vel11D).map(v => parseFloat(v.toFixed(6)))
                },
                trailCount: particle.points ? particle.points.length : 0,
                psiBreakdown: currentPsiSnapshot() // NEW: Include œà breakdown in token
            };
            
            // Add to particle's token list
            particle.tokens.push(token);
            
            // CST v2.0+ additive: Buffer token for batched UI updates
            addToken(token);
            
            return token;
        }

        function generateAudioFrameToken(frequencyData, rmsEnergy, spectralCentroid, harmonics) {
            // CONTINUOUS audio frame token - captures entire audio state
            // CST v2.0+ fix: Handle silent input gracefully
            const safeFreqData = frequencyData || [];
            const token = {
                id: nextDeterministicId(), // Use deterministic ID in replay mode
                type: 'audio_frame',
                timestamp: Date.now() / 1000,
                rmsEnergy: parseFloat((rmsEnergy || 0).toFixed(4)),
                spectralCentroid: parseFloat((spectralCentroid || 0).toFixed(2)),
                frequencyCount: safeFreqData.length,
                topFrequencies: safeFreqData.slice(0, 5).map(f => ({
                    freq: parseFloat(f.frequency.toFixed(2)),
                    magnitude: parseFloat(f.magnitude.toFixed(3))
                })),
                phiHarmonics: (harmonics || []).slice(0, 5).map(h => parseFloat(h.toFixed(2))),
                seed: generateAudioSeed(safeFreqData, rmsEnergy || 0), // Deterministic seed
                psi: calculatePsiFromAudio(safeFreqData, rmsEnergy || 0, spectralCentroid || 0),
                psiBreakdown: currentPsiSnapshot() // NEW: Include œà breakdown in token
            };
            
            // CST v2.0+ additive: Buffer token for batched UI updates
            addToken(token);
            
            return token;
        }

        function flashTokenIndicator() {
            const indicator = document.getElementById('tokenIndicator');
            indicator.classList.add('active');
            setTimeout(() => {
                // Keep it active while audio is processing
                if (!isAudioActive) {
                    indicator.classList.remove('active');
                }
            }, 100);
        }

        function generateHarmonicToken(harmonic, magnitude, index) {
            // Token for each phi-harmonic generated
            const token = {
                id: nextDeterministicId(), // Use deterministic ID in replay mode
                type: 'phi_harmonic',
                timestamp: Date.now() / 1000,
                harmonic: parseFloat(harmonic.toFixed(2)),
                magnitude: parseFloat(magnitude.toFixed(3)),
                harmonicIndex: index,
                phiRatio: Math.pow(phi, index / 2),
                colorMapping: frequencyToColor(harmonic),
                seed: hashFrequency(harmonic),
                psiBreakdown: currentPsiSnapshot() // NEW: Include œà breakdown in token
            };
            
            // CST v2.0+ additive: Buffer token for batched UI updates
            addToken(token);
            
            return token;
        }

        function generateAudioSeed(frequencyData, rmsEnergy) {
            // Generate deterministic seed from audio data
            let seedValue = 0;
            frequencyData.forEach((f, i) => {
                seedValue += f.frequency * f.magnitude * (i + 1);
            });
            seedValue += rmsEnergy * 10000;
            return Math.floor(seedValue) % 1000000;
        }

        function hashFrequency(frequency) {
            // Simple hash for frequency-based seed
            return Math.floor((frequency * phi) % 100000);
        }

        function frequencyToColor(frequency) {
            // Sound-to-color mapping
            const hue = (frequency / 20000) * 360;
            const saturation = 100;
            const lightness = 50;
            return `hsl(${hue.toFixed(0)}, ${saturation}%, ${lightness}%)`;
        }

        function calculatePsiFromAudio(frequencyData, rmsEnergy, spectralCentroid) {
            // Calculate œà directly from audio using the 12D formula
            const mass = 1;
            const energyComponent = (phi * mass * c * c * rmsEnergy) / (c * c);
            const lambdaComponent = Math.log(spectralCentroid + 1) / 100;
            const frequencyIntegral = frequencyData.reduce((sum, f) => sum + f.frequency * f.magnitude, 0) / 1000;
            const omegaComponent = frequencyData.length * rmsEnergy * phi;
            
            return energyComponent + phi + lambdaComponent + frequencyIntegral + omegaComponent;
        }

        function createParticleFromFrequency(frequency, magnitude, color) {
            // Create new particle from frequency data
            // CST v2.0+ additive: Use getRandom() for determinism in replay mode
            const offset = particles.length * 0.1;
            const particle = new LorenzParticle(
                getRandom() * 10 - 5,
                getRandom() * 10 - 5,
                getRandom() * 10 - 5,
                color,
                frequency,
                null
            );
            
            particle.mass = 1 + magnitude * 5;
            particle.energy = magnitude * 50;
            particles.push(particle);

            // Generate creation token
            generateParticleToken(particle, 'audio_creation');
        }

        function updateParticleFromAudio(particle, frequency, magnitude, color) {
            // Update existing particle with new audio data
            particle.frequency = frequency;
            particle.color = color;
            particle.line.material.color.setHex(color);
            particle.sphere.material.color.setHex(color);
            particle.mass = Math.max(1, particle.mass * (0.95 + magnitude * 0.1));
            
            // Generate frequency update token
            const token = {
                id: nextDeterministicId(), // Use deterministic ID in replay mode
                type: 'frequency_update',
                particleId: particle.id,
                frequency: parseFloat(frequency.toFixed(2)),
                magnitude: parseFloat(magnitude.toFixed(3)),
                color: '#' + color.toString(16).padStart(6, '0'),
                timestamp: Date.now() / 1000
            };
            
            // Add to particle's token list
            particle.tokens.push(token);
            
            // CST v2.0+ additive: Buffer token for batched UI updates
            addToken(token);
        }

        function calculateAudioChaos() {
            if (frequencyData.length < 2) return 0;
            
            let variance = 0;
            const mean = frequencyData.reduce((sum, d) => sum + d.magnitude, 0) / frequencyData.length;
            frequencyData.forEach(d => {
                variance += Math.pow(d.magnitude - mean, 2);
            });
            return Math.sqrt(variance / frequencyData.length);
        }

        function addParticleFromAudio(frequency, energy) {
            const offset = particles.length * 0.1;
            const hue = (frequency / 20000) * 360;
            const color = new THREE.Color(`hsl(${hue}, 100%, 50%)`);
            
            const particle = new LorenzParticle(
                0.1 + offset + energy * 5,
                offset,
                offset,
                color.getHex(),
                frequency,
                null // No parent for audio-generated particles
            );
            
            particle.mass = 1 + energy * 10;
            particles.push(particle);

            // Generate creation token
            generateParticleToken(particle, 'creation');
            
            updateStatus(`Audio particle created: ${frequency.toFixed(1)}Hz, E=${energy.toFixed(3)}`);
        }

        // CST v2.0 additive: Enhanced token display with bounded view
        function updateTokenDisplay() {
            const display = document.getElementById('tokenDisplay');
            if (tokens.length === 0) {
                if (display) display.innerHTML = '<div class="token-item">Waiting for audio input...</div>';
                const countEl = document.getElementById('token-count');
                if (countEl) countEl.textContent = '0';
                return;
            }
            
            // CST v2.0+ additive: Use configurable token display limit
            const recentTokens = tokens.slice(-audioConfig.tokenDisplayLimit).reverse();
            display.innerHTML = recentTokens.map(t => {
                // Different display formats based on token type
                if (t.type === 'audio_frame') {
                    return `<div class="token-item">
                        <strong>üéµ AUDIO FRAME</strong> ${t.id.substr(0, 13)}...<br>
                        <strong>RMS:</strong> ${t.rmsEnergy} | <strong>Centroid:</strong> ${t.spectralCentroid}Hz<br>
                        <strong>Top Freq:</strong> ${t.topFrequencies[0]?.freq || 0}Hz<br>
                        <strong>Seed:</strong> ${t.seed} | <strong>œà:</strong> ${t.psi?.toFixed(2)}
                    </div>`;
                } else if (t.type === 'phi_harmonic') {
                    return `<div class="token-item">
                        <strong>üåÄ œÜ-HARMONIC #${t.harmonicIndex}</strong><br>
                        <strong>Freq:</strong> ${t.harmonic}Hz | <strong>Mag:</strong> ${t.magnitude}<br>
                        <strong>œÜ^${(t.harmonicIndex / 2).toFixed(1)}:</strong> ${t.phiRatio?.toFixed(3)}<br>
                        <strong>Color:</strong> <span style="color: ${t.colorMapping}">${t.colorMapping}</span> | <strong>Seed:</strong> ${t.seed}
                    </div>`;
                } else if (t.type === 'frequency_update') {
                    return `<div class="token-item">
                        <strong>üîÑ FREQ UPDATE</strong> Particle: ${t.particleId.substr(0, 8)}...<br>
                        <strong>Freq:</strong> ${t.frequency}Hz | <strong>Mag:</strong> ${t.magnitude}<br>
                        <strong>Color:</strong> <span style="color: ${t.color}">${t.color}</span>
                    </div>`;
                } else {
                    // Standard particle token
                    const parentInfo = t.parent ? `Parent: ${t.parent.substr(0, 8)}...` : 'No parent';
                    const posStr = `[${t.position[0].toFixed(1)}, ${t.position[1].toFixed(1)}, ${t.position[2].toFixed(1)}]`;
                    return `<div class="token-item">
                        <strong>‚öõÔ∏è ${t.eventType?.toUpperCase()}</strong> ${t.id.substr(0, 13)}...<br>
                        <strong>Freq:</strong> ${t.frequency}Hz | <strong>E:</strong> ${t.energy?.toFixed(3)}<br>
                        <strong>Pos:</strong> ${posStr}<br>
                        <strong>${parentInfo}</strong>
                    </div>`;
                }
            }).join('');
            
            // Smooth scroll to bottom if near bottom
            if (display) {
                requestAnimationFrame(() => {
                    const isNearBottom = display.scrollHeight - display.scrollTop - display.clientHeight < 50;
                    if (isNearBottom) {
                        display.scrollTop = display.scrollHeight;
                    }
                });
            }
        }

        // ============================================================================
        // ANIMATION MODULES - Real-time updates and smooth transitions
        // ============================================================================
        
        // State buffers for frequency spectrum smoothing
        let lastFreqBars = null;
        let freqLerp = 0.25; // smoothing factor
        
        // 1) Frequency spectrum animation
        function updateFrequencyViz(freqs, mags) {
            if (!freqCtx || !freqCanvas) return;
            
            // Use provided parameters or read from analyser
            let bars = null;
            let binCount = 0;
            let currentRMS = audioEnergy || 0;
            let currentDominantFreq = 0;
            let currentSpectralCentroid = 0;
            
            if (freqs && mags && freqs.length > 0) {
                // Use provided frequency data
                binCount = Math.max(freqs.length, 100); // Default to 100 bins if not specified
                bars = new Array(binCount).fill(0);
                freqs.forEach((f, i) => {
                    const bin = Math.min(binCount - 1, Math.floor((f / 20000) * binCount));
                    if (mags[i] !== undefined) {
                        bars[bin] = Math.max(bars[bin], mags[i]);
                    }
                });
                
                // Calculate RMS, dominant frequency, and spectral centroid from provided data
                if (mags.length > 0) {
                    const sumSq = mags.reduce((sum, m) => sum + m * m, 0);
                    currentRMS = Math.sqrt(sumSq / mags.length);
                    currentDominantFreq = freqs[0] || 0;
                    
                    // Calculate spectral centroid
                    let weightedSum = 0;
                    let magnitudeSum = 0;
                    freqs.forEach((f, i) => {
                        weightedSum += f * (mags[i] || 0);
                        magnitudeSum += (mags[i] || 0);
                    });
                    currentSpectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
                }
            } else if (analyser && dataArray && bufferLength > 0) {
                // Read from analyser (live audio)
                analyser.getByteFrequencyData(dataArray);
                binCount = bufferLength;
                bars = Array.from(dataArray, v => v / 255);
                
                // Calculate RMS from time domain data
                analyser.getByteTimeDomainData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    const normalized = (dataArray[i] - 128) / 128;
                    sum += normalized * normalized;
                }
                currentRMS = Math.sqrt(sum / dataArray.length);
                
                // Get dominant frequency and spectral centroid from frequency data
                analyser.getByteFrequencyData(dataArray);
                let maxMag = 0;
                let maxIdx = 0;
                let weightedSum = 0;
                let magnitudeSum = 0;
                if (audioContext && audioContext.sampleRate) {
                    for (let i = 0; i < dataArray.length; i++) {
                        const mag = dataArray[i] / 255;
                        if (mag > maxMag) {
                            maxMag = mag;
                            maxIdx = i;
                        }
                        const freq = (i * audioContext.sampleRate) / (2 * bufferLength);
                        weightedSum += freq * dataArray[i];
                        magnitudeSum += dataArray[i];
                    }
                    currentDominantFreq = (maxIdx * audioContext.sampleRate) / (2 * bufferLength);
                    currentSpectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
                }
            } else if (determinism.mode === 'replay' && frequencyData && frequencyData.length > 0) {
                // Use global frequencyData from replay mode
                binCount = 100; // Default bin count
                bars = new Array(binCount).fill(0);
                const freqs = frequencyData.map(f => f.frequency);
                const mags = frequencyData.map(f => f.magnitude);
                
                freqs.forEach((f, i) => {
                    const bin = Math.min(binCount - 1, Math.floor((f / 20000) * binCount));
                    if (mags[i] !== undefined) {
                        bars[bin] = Math.max(bars[bin], mags[i]);
                    }
                });
                
                currentRMS = audioEnergy || 0;
                currentDominantFreq = freqs.length > 0 ? freqs[0] : 0;
                
                // Calculate spectral centroid
                let weightedSum = 0;
                let magnitudeSum = 0;
                freqs.forEach((f, i) => {
                    weightedSum += f * (mags[i] || 0);
                    magnitudeSum += (mags[i] || 0);
                });
                currentSpectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : spectralCentroid || 0;
            } else {
                // No data available
                return;
            }

            // Update RMS energy, dominant frequency, and spectral centroid displays
            const rmsEl = document.getElementById('rms-energy');
            const dominantEl = document.getElementById('dominant-freq');
            const centroidEl = document.getElementById('spectral-centroid');
            if (rmsEl) rmsEl.textContent = currentRMS.toFixed(3);
            if (dominantEl) dominantEl.textContent = currentDominantFreq.toFixed(1);
            if (centroidEl) centroidEl.textContent = currentSpectralCentroid.toFixed(1);
            
            const width = freqCanvas.width;
            const height = freqCanvas.height;
            const barW = (width / binCount) * 2.0;

            // Prepare smoothed bars
            if (!lastFreqBars || lastFreqBars.length !== bars.length) {
                lastFreqBars = bars.slice();
            } else {
                for (let i = 0; i < bars.length; i++) {
                    lastFreqBars[i] = lastFreqBars[i] + freqLerp * (bars[i] - lastFreqBars[i]);
                }
            }
            
            // Clear canvas
            freqCtx.clearRect(0, 0, width, height);
            freqCtx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            freqCtx.fillRect(0, 0, width, height);
            
            // Draw bars with hue mapping (0‚Äì360)
            let x = 0;
            for (let i = 0; i < binCount; i++) {
                const hue = (i / binCount) * 360;
                const barH = lastFreqBars[i] * height;
                freqCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                freqCtx.fillRect(x, height - barH, barW, barH);
                x += barW + 1;
            }
        }
        
        // Legacy function for compatibility (calls new function)
        function drawFrequencySpectrum() {
            updateFrequencyViz();
        }
        
        // 2) Lorenz attractor particle animation update
        function updateLorenzParticles() {
            if (particles.length === 0 || isPaused) return;

            // Adaptive dt is updated in animate() before this call
            const spatialIndex = buildSpatialIndex(particles, physics.rCutoff);
            const gravAccelerations = computeGravitationalAccelerations(particles, spatialIndex, physics);
            computeGravitationalEnergy(particles, spatialIndex, physics);
            computeDarkMatterPotential(particles, dmParams);
                computeSynapticStrength(particles, spatialIndex, physics, adapt);
            updateAdaptiveStates(particles, adapt, timestep.dt);
            updatePhases(particles, sync, spatialIndex, timestep.dt);

            // Audio modulation
                const audioMod = isAudioActive ? audioEnergy * audioSensitivity : 0;

            // Update particle trajectories and visuals
                let chaosSum = 0;
            particles.forEach((p, i) => {
                const accel = gravAccelerations[i];
                const d = p.update(audioMod, accel);
                chaosSum += Math.abs(d.dx) + Math.abs(d.dy) + Math.abs(d.dz);
                });

            // Recompute energies and vi
            particles.forEach(p => {
                const v2 = p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z;
                const K = 0.5 * p.mass * v2;
                p.Ec = K + p.Ugrav + p.Udm;
                p.vi = p.Ec / h;
            });
            
            // Entropy every N frames (performance)
                if (frameCount % 10 === 0) {
                    computeEntropy(particles, kB, 32);
                }

            // œà normalized breakdown
            const psiResult = updatePsiNormalized(particles, physics, psiAccumulators);
            updatePsi(chaosSum, psiResult);
            
            // Camera slow orbit
            const t = Date.now() * 0.0001;
            camera.position.x = Math.cos(t) * 60;
            camera.position.z = Math.sin(t) * 60;
            camera.lookAt(0, 20, 0);
            
            // Conservation and virial (batched updates)
                const consStats = computeConservationStats(particles);
                if (conservationStats.E0 === 0) {
                    conservationStats.E0 = consStats.Etotal;
                conservationStats.P0 = { ...consStats.P };
                conservationStats.L0 = { ...consStats.L };
                }
            const virial = checkVirial(particles);
            const syncMetric = computeSynchronizationMetric(particles);

            // UI updates throttled
            if (frameCount % Math.floor(60 / Math.max(timestep.dt, 0.01)) === 0) {
                updateAdvancedUI(consStats, virial, psiResult, syncMetric);
            }
        }
        
        // CST v2.0+ additive: Enhanced token tracking with buffering
        // Add token to buffer for batched UI updates
        function addToken(tokenObj) {
            if (!tokenObj) return;
            
            // CST v2.0+ additive: Record timestamp for rate calculation
            const now = Date.now();
            tokenRateWindow.timestamps.push(now);
            
            // CST v2.0+ additive: Buffer token instead of immediately updating UI
            tokenBuffer.tokens.push(tokenObj);
            
            // Flash indicator briefly (immediate feedback)
            const indicator = document.getElementById('tokenIndicator');
            if (indicator) {
                indicator.classList.add('active');
                setTimeout(() => {
                    indicator.classList.remove('active');
                }, 100);
            }
            }
            
        // CST v2.0 fix: updateTokenStream now only handles UI updates, not token generation
        // Token generation is handled by processAudio() via setInterval for exact 100ms cadence
        function updateTokenStream() {
            // Token generation is now handled by processAudio() and processReplayAudio()
            // This function only handles UI updates and scrolling
            
            // Smooth scroll to bottom
            const display = document.getElementById('tokenDisplay');
            if (!display) return;
            
            // Only scroll if near bottom (within 50px) to avoid interrupting user scrolling
            const isNearBottom = display.scrollHeight - display.scrollTop - display.clientHeight < 50;
            if (isNearBottom) {
                display.scrollTop = display.scrollHeight;
            }
            
            // Update token count if changed (for non-audio token sources)
            if (tokens.length !== lastTokenCount) {
                const countEl = document.getElementById('token-count');
                const countStatusEl = document.getElementById('token-count-status');
                if (countEl) countEl.textContent = tokens.length;
                if (countStatusEl) countStatusEl.textContent = tokens.length;
                lastTokenCount = tokens.length;
            }
        }
        
        // CST v2.0 additive: Enhanced token rate calculation with rolling window
        function updateTokenRate() {
            const now = Date.now();
            const windowSize = 2000;
            tokenRateWindow.timestamps = tokenRateWindow.timestamps.filter(ts => ts > (now - windowSize));
            
                const rateEl = document.getElementById('token-rate');
            const span = tokenRateWindow.timestamps.length > 0
                ? (now - tokenRateWindow.timestamps[0]) / 1000
                : 0;
            const rate = span > 0 ? tokenRateWindow.timestamps.length / span : 0;
            if (rateEl) rateEl.textContent = rate.toFixed(1);
            tokenGenerationRate = rate;
        }
        
        // Alias for compatibility
        function updateTokenCountersOncePerSecond() {
            updateTokenRate();
        }
        
        // 4) Chaos, Lyapunov, and synchronization displays
        function updateChaosMetrics() {
            const chaos = calculateAudioChaos();
            let lyapunov = 0;
            
            if (particles.length > 0) {
                // Calculate chaos sum from particle derivatives
                let chaosSum = 0;
                particles.forEach(p => {
                    const v = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                    chaosSum += Math.abs(v);
                });
                lyapunov = Math.abs(Math.log(Math.abs(chaosSum) + 1) / 10) + (isAudioActive ? chaos : 0);
            }
            
            const lyEl = document.getElementById('lyapunov-value');
            const chaosEl = document.getElementById('audio-chaos');
            if (lyEl) lyEl.textContent = lyapunov.toFixed(3);
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);
        }
        
        // 5) Conservation diagnostics animation
        function updateConservationDiagnostics() {
            if (particles.length === 0) return;
            
            const consStats = computeConservationStats(particles);
            const virial = checkVirial(particles);
            
            const eTotalEl = document.getElementById('conservation-etotal');
            const eDriftEl = document.getElementById('conservation-edrift');
            const pMagEl = document.getElementById('conservation-pmag');
            const lMagEl = document.getElementById('conservation-lmag');
            const virialEl = document.getElementById('conservation-virial');
            
            if (eTotalEl) eTotalEl.textContent = consStats.Etotal.toExponential(2);
            if (eDriftEl) eDriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
            if (pMagEl) pMagEl.textContent = Math.sqrt(consStats.P.x**2 + consStats.P.y**2 + consStats.P.z**2).toExponential(2);
            if (lMagEl) lMagEl.textContent = Math.sqrt(consStats.L.x**2 + consStats.L.y**2 + consStats.L.z**2).toExponential(2);
            if (virialEl) virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
        }
        
        // 6) Replay and determinism feedback
        function reflectDeterminismUI() {
            const status = document.getElementById('recording-status');
            const replayBtn = document.getElementById('replay-btn');
            if (!status || !replayBtn) return;
            
            if (determinism.isRecording) {
                status.textContent = `Recording audio frames... (${determinism.recordedAudioFrames.length} frames)`;
            } else {
                status.textContent = `Recording stopped. ${determinism.recordedAudioFrames.length} frames recorded.`;
            }
            replayBtn.textContent = determinism.mode === 'replay' ? '‚èπÔ∏è Stop Replay' : '‚ñ∂Ô∏è Replay';
        }
        
        // Standalone synchronization metrics update function
        function updateSynchronizationMetrics() {
            if (particles.length === 0) return;
            
            const syncMetric = computeSynchronizationMetric(particles);
            const syncREl = document.getElementById('sync-r');
            const syncMeanEl = document.getElementById('sync-mean');
            const syncStdEl = document.getElementById('sync-std');
            
            if (syncREl) syncREl.textContent = syncMetric.r.toFixed(3);
            if (syncMeanEl) syncMeanEl.textContent = (syncMetric.meanTheta * 180 / Math.PI).toFixed(1) + '¬∞';
            const thetaStd = computeThetaStd(particles);
            if (syncStdEl) syncStdEl.textContent = (thetaStd * 180 / Math.PI).toFixed(1) + '¬∞';
        }
        
        // Standalone œà breakdown update function
        // CST v2.0+ fix: Ensures all œà normalized breakdown terms update in real-time
        function updatePsiBreakdown() {
            if (particles.length === 0) {
                // Reset displays to zero when no particles
                const psiEnergyEl = document.getElementById('psi-energy-term');
                const psiLambdaEl = document.getElementById('psi-lambda-term');
                const psiVelIntEl = document.getElementById('psi-velint-term');
                const psiX12IntEl = document.getElementById('psi-x12int-term');
                const psiOmegaEl = document.getElementById('psi-omega-term');
                const psiPotentialEl = document.getElementById('psi-potential-term');
                const psiTotalEl = document.getElementById('psi-total-normalized');
                
                if (psiEnergyEl) psiEnergyEl.textContent = '0.000';
                if (psiLambdaEl) psiLambdaEl.textContent = '0.000';
                if (psiVelIntEl) psiVelIntEl.textContent = '0.000';
                if (psiX12IntEl) psiX12IntEl.textContent = '0.000';
                if (psiOmegaEl) psiOmegaEl.textContent = '0.000';
                if (psiPotentialEl) psiPotentialEl.textContent = '0.000';
                if (psiTotalEl) psiTotalEl.textContent = '0.000';
                return;
            }
            
            // CST v2.0+ fix: Calculate œà breakdown with current particle states
            const psiResult = updatePsiNormalized(particles, physics, psiAccumulators);
            
            const psiEnergyEl = document.getElementById('psi-energy-term');
            const psiLambdaEl = document.getElementById('psi-lambda-term');
            const psiVelIntEl = document.getElementById('psi-velint-term');
            const psiX12IntEl = document.getElementById('psi-x12int-term');
            const psiOmegaEl = document.getElementById('psi-omega-term');
            const psiPotentialEl = document.getElementById('psi-potential-term');
            const psiTotalEl = document.getElementById('psi-total-normalized');
            
            // CST v2.0+ fix: Update all terms with proper formatting (show at least 3 decimals)
            if (psiEnergyEl) psiEnergyEl.textContent = psiResult.terms.energyTerm.toFixed(3);
            if (psiLambdaEl) psiLambdaEl.textContent = psiResult.terms.lambdaTerm.toFixed(3);
            if (psiVelIntEl) psiVelIntEl.textContent = psiResult.terms.velocityIntegralTerm.toFixed(3);
            if (psiX12IntEl) psiX12IntEl.textContent = psiResult.terms.x12IntegralTerm.toFixed(3);
            if (psiOmegaEl) psiOmegaEl.textContent = psiResult.terms.omegaTerm.toFixed(3);
            if (psiPotentialEl) psiPotentialEl.textContent = psiResult.terms.potentialTerm.toFixed(3);
            if (psiTotalEl) psiTotalEl.textContent = psiResult.psiTotal.toFixed(3);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!isPaused) {
                // Adaptive timestep
                const adaptiveDtCheckbox = document.getElementById('adaptive-dt');
                if (adaptiveDtCheckbox && adaptiveDtCheckbox.checked && particles.length > 0) {
                    timestep.dt = computeAdaptiveDt(particles, physics, timestep);
                }

                // Update Lorenz particles with full physics
                if (particles.length > 0) {
                    updateLorenzParticles();
                }
                
                // Draw frequency spectrum
                drawFrequencySpectrum();
                
                // Update metrics
                updateChaosMetrics();
                updateSynchronizationMetrics();
                updateConservationDiagnostics();
                // CST v2.0+ fix: Update œà breakdown every frame for real-time updates
                updatePsiBreakdown();
                
                // CST v2.0+ additive: Update entropy metrics every frame, draw histogram every ~10 frames
                // Throttle entropy trace updates for better performance (update every 2 frames = ~30Hz)
                if (frameCount % 2 === 0 || frameCount === 0) {
                    updateEntropy(); // Updates metrics, UI, and trace
                } else {
                    // Still update metrics and UI, but skip trace drawing for performance
                    if (particles.length > 0) {
                        const { entropy, histogram, tempProxy } = computeEntropyMetrics();
                        entropyState.lastEntropy = kB * entropy;
                        entropyState.histogram = histogram;
                        entropyState.tempProxy = tempProxy;
                        
                        const entropyEl = document.getElementById('entropy-global');
                        const binsEl = document.getElementById('entropy-bins');
                        const tempEl = document.getElementById('entropy-temperature');
                        
                        if (entropyEl) entropyEl.textContent = entropyState.lastEntropy.toFixed(3);
                        if (binsEl) binsEl.textContent = JSON.stringify(histogram.slice(0, 5));
                        if (tempEl) tempEl.textContent = tempProxy.toFixed(3);
                    }
                }
                if (frameCount % 10 === 0 || frameCount === 0) {
                    drawEntropyHistogram(entropyState.histogram); // Draw histogram bars
                }
                
                // Update token stream
                updateTokenStream();
                // Note: updateTokenRate() is called periodically via tokenRateUpdateInterval at ~500ms cadence
                
                // NEW: Update adaptive state trace
                updateAdaptiveStateTrace();
            }

            // Render Three.js scene
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }

            // FPS counter - CST v2.0+ fix: Show actual FPS from requestAnimationFrame
            frameCount++;
            const now = performance.now();
            if (now >= lastTime + 1000) {
                const actualFPS = frameCount; // frameCount is frames in last second
                const fpsEl = document.getElementById('fps');
                if (fpsEl) fpsEl.textContent = actualFPS.toFixed(1);
                const particleEl = document.getElementById('particle-count');
                const tokenEl = document.getElementById('token-count-status');
                const replEl = document.getElementById('replication-count');
                if (particleEl) particleEl.textContent = particles.length;
                if (tokenEl) tokenEl.textContent = tokens.length;
                if (replEl) replEl.textContent = replicationCount;
                frameCount = 0;
                lastTime = now;
            }
        }
        
        // Update advanced UI displays
        function updateAdvancedUI(consStats, virial, psiResult, syncMetric) {
            // Update conservation displays if elements exist
            const eTotalEl = document.getElementById('conservation-etotal');
            const eDriftEl = document.getElementById('conservation-edrift');
            const pMagEl = document.getElementById('conservation-pmag');
            const lMagEl = document.getElementById('conservation-lmag');
            const virialEl = document.getElementById('conservation-virial');
            
            if (eTotalEl) eTotalEl.textContent = consStats.Etotal.toExponential(2);
            if (eDriftEl) eDriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
            if (pMagEl) pMagEl.textContent = Math.sqrt(consStats.P.x**2 + consStats.P.y**2 + consStats.P.z**2).toExponential(2);
            if (lMagEl) lMagEl.textContent = Math.sqrt(consStats.L.x**2 + consStats.L.y**2 + consStats.L.z**2).toExponential(2);
            if (virialEl) virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
            
            // Update synchronization displays
            const syncREl = document.getElementById('sync-r');
            const syncMeanEl = document.getElementById('sync-mean');
            if (syncREl) syncREl.textContent = syncMetric.r.toFixed(3);
            if (syncMeanEl) syncMeanEl.textContent = (syncMetric.meanTheta * 180 / Math.PI).toFixed(1) + '¬∞';
            
            // Update psi breakdown displays
            const psiEnergyEl = document.getElementById('psi-energy-term');
            const psiLambdaEl = document.getElementById('psi-lambda-term');
            const psiVelIntEl = document.getElementById('psi-velint-term');
            const psiX12IntEl = document.getElementById('psi-x12int-term');
            const psiOmegaEl = document.getElementById('psi-omega-term');
            const psiPotentialEl = document.getElementById('psi-potential-term');
            const psiTotalEl = document.getElementById('psi-total-normalized');
            
            if (psiEnergyEl) psiEnergyEl.textContent = psiResult.terms.energyTerm.toFixed(3);
            if (psiLambdaEl) psiLambdaEl.textContent = psiResult.terms.lambdaTerm.toFixed(3);
            if (psiVelIntEl) psiVelIntEl.textContent = psiResult.terms.velocityIntegralTerm.toFixed(3);
            if (psiX12IntEl) psiX12IntEl.textContent = psiResult.terms.x12IntegralTerm.toFixed(3);
            if (psiOmegaEl) psiOmegaEl.textContent = psiResult.terms.omegaTerm.toFixed(3);
            if (psiPotentialEl) psiPotentialEl.textContent = psiResult.terms.potentialTerm.toFixed(3);
            if (psiTotalEl) psiTotalEl.textContent = psiResult.psiTotal.toFixed(3);
            
            // NEW: show validation during replay
            updateReplayValidation(consStats, virial);
        }

        function addParticle() {
            const offset = particles.length * 0.1;
            const color = new THREE.Color(`hsl(${colorHue + offset * 30}, 100%, 50%)`);
            const particle = new LorenzParticle(0.1 + offset, offset, offset, color.getHex(), 440 + offset * 100);
            particles.push(particle);
            
            // Generate creation token
            generateParticleToken(particle, 'creation');
            
            updateStatus(`Added trajectory ${particles.length}`);
        }

        function resetSystem() {
            particles.forEach(p => p.destroy());
            particles = [];
            tokens = [];
            tokenCount = 0;
            replicationCount = 0;
            tokenRateWindow.timestamps = []; // CST v2.0+ fix: Clear token rate window
            // Reset conservation stats, psi accumulators, and entropy
            resetIntegralsAndConservation();
            // NEW: Reset entropy smoothing and adaptive state history
            entropyEma = null;
            x12History = [];
            updateEntropy(); // Update UI immediately
            updateTokenDisplay();
            addParticle();
            updateStatus('System reset - New trajectory initialized');
        }

        function togglePause() {
            isPaused = !isPaused;
            updateStatus(isPaused ? 'Simulation paused' : 'Simulation running');
        }

        function changeColor() {
            colorHue = (colorHue + 60) % 360;
            particles.forEach((p, i) => {
                const color = new THREE.Color(`hsl(${colorHue + i * 30}, 100%, 50%)`);
                p.line.material.color.setHex(color.getHex());
                p.sphere.material.color.setHex(color.getHex());
            });
            updateStatus('Color scheme updated');
        }

        function updatePsi(chaosSum, psiResult = null) {
            const mass = 1;
            const energy = mass * c * c;
            const audioGain = 1 + (isAudioActive ? audioEnergy * audioSensitivity : 0);
            const energyComponent = mass * audioGain;
            
            // Calculate Lyapunov approximation
            const audioChaos = isAudioActive ? calculateAudioChaos() : 0;
            const lyapunov = Math.abs(Math.log(Math.abs(chaosSum) + 1) / 10) + audioChaos;
            
            document.getElementById('energy-value').textContent = (energy * audioGain).toExponential(2);
            document.getElementById('lyapunov-value').textContent = lyapunov.toFixed(3);
            
            // Calculate œà components (legacy display)
                const psiEnergy = energyComponent;
                const psiPhi = phi;
                const psiLambda = lyapunov;
                const psiOmega = chaosSum;
            const psiTotal = psiResult ? psiResult.psiTotal : (psiEnergy + psiPhi + psiLambda + psiOmega);
                
                document.getElementById('psi-energy').textContent = psiEnergy.toFixed(3);
                document.getElementById('psi-phi').textContent = psiPhi.toFixed(3);
                document.getElementById('psi-lambda').textContent = psiLambda.toFixed(3);
                document.getElementById('psi-omega').textContent = psiOmega.toFixed(2);
                document.getElementById('psi-total').textContent = psiTotal.toFixed(3);
        }

        function updateStatus(message) {
            const statusEl = document.getElementById('system-status');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }

        // CST v2.0+ additive: Compute recording hash for deterministic verification
        // Uses FNV-1a hash algorithm for integrity verification
        function computeRecordingHash(frames, seed) {
            // FNV-1a hash (32-bit)
            let hash = 2166136261; // FNV offset basis
            
            // Hash seed
            const seedStr = String(seed || determinism.seed || projectionConfig.randomSeed || 0);
            for (let i = 0; i < seedStr.length; i++) {
                hash ^= seedStr.charCodeAt(i);
                hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
            }
            
            // Hash frame data (first 100 frames for performance)
            const frameCount = Math.min(frames.length, 100);
            for (let i = 0; i < frameCount; i++) {
                const frame = frames[i];
                const rms = (frame.rmsEnergy || frame.rms || 0).toFixed(6);
                const centroid = (frame.spectralCentroid || 0).toFixed(2);
                const hashStr = `${i}:${rms}:${centroid}`;
                
                for (let j = 0; j < hashStr.length; j++) {
                    hash ^= hashStr.charCodeAt(j);
                    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
                }
            }
            
            // Convert to unsigned 32-bit and return as hex string
            hash = hash >>> 0;
            return hash.toString(16).padStart(8, '0');
        }

        function exportTokens(opts = {full: false}) {
            if (tokens.length === 0) {
                alert('No tokens to export yet! Start the microphone or add particles.');
                return;
            }
            
            // CST v2.0+ additive: Support compact/full export
            const compact = !opts.full && document.getElementById('export-compact') && document.getElementById('export-compact').checked;
            
            // Calculate token type statistics
            const tokenTypes = {
                audio_frame: tokens.filter(t => t.type === 'audio_frame').length,
                phi_harmonic: tokens.filter(t => t.type === 'phi_harmonic').length,
                frequency_update: tokens.filter(t => t.type === 'frequency_update').length,
                particle_creation: tokens.filter(t => t.eventType === 'creation' || t.eventType === 'audio_creation').length,
                particle_replication: tokens.filter(t => t.eventType === 'replication').length
            };
            
            // CST v2.0+ additive: Enhanced export with full schema including reference scales and diagnostics
            const exportData = {
                metadata: {
                    engineVersion: '2.0+',
                    exportDate: new Date().toISOString(),
                    startTime: tokens.length > 0 ? tokens[0].timestamp : Date.now() / 1000,
                    totalTokens: tokens.length,
                    tokenGenerationRate: tokenGenerationRate.toFixed(2) + ' tokens/sec',
                    engine: '12D Cosmic Synapse Theory',
                    version: '2.0+',
                    mode: determinism.mode || 'live',
                    seed: determinism.seed || projectionConfig.randomSeed || null, // Include seed for deterministic verification
                    projectionMode: projectionConfig.mode, // CST v2.0+ additive: Include projection mode
                    cadence: audioConfig.cadence, // CST v2.0+ additive: Token generation cadence in ms
                    fftSize: audioConfig.fftSize, // CST v2.0+ additive: FFT size used
                    tokenDisplayLimit: audioConfig.tokenDisplayLimit, // CST v2.0+ additive: Token display limit
                    compact: compact, // CST v2.0+ additive: Include compact flag
                    formula: 'œà = œÜE/c¬≤ + Œª + ‚à´v¬∑dt + ‚à´Œîx‚ÇÅ‚ÇÇ¬∑dt + Œ©E + U‚ÇÅ‚ÇÅD',
                    particleCount: particles.length,
                    replicationCount: replicationCount,
                    tokenTypes: tokenTypes,
                    recordingFrames: determinism.recordedAudioFrames.length, // Number of recorded frames if any
                    // CST v2.0+ additive: Reference scales for dimensionless œà normalization
                    referenceScales: {
                        m0: physics.m0,
                        Eref: physics.Eref,
                        tref: physics.tref,
                        vref: physics.vref
                    },
                    physics: {
                        blendLorenz: physics.blendLorenz,
                        gravEnabled: physics.gravEnabled,
                        dmEnabled: physics.dmEnabled,
                        epsilon: physics.epsilon,
                        rCutoff: physics.rCutoff,
                        G: physics.G
                    },
                    adaptive: {
                        k: adapt.k,
                        gamma: adapt.gamma,
                        alpha: adapt.alpha,
                        sigmaSimilarity: adapt.sigmaSimilarity
                    },
                    sync: {
                        Ksync: sync.Ksync
                    },
                    timestep: {
                        dt: timestep.dt,
                        dtMax: timestep.dtMax,
                        adaptive: timestep.adaptive
                    },
                    darkMatter: {
                        rho0: dmParams.rho0,
                        rs: dmParams.rs
                    }
                },
                // CST v2.0+ additive: Include recorded frames if available
                frames: determinism.recordedAudioFrames.length > 0 ? determinism.recordedAudioFrames.map((frame, idx) => ({
                    frameIndex: idx,
                    timestamp: frame.timestamp,
                    rms: frame.rmsEnergy,
                    dominantFreq: frame.frequencyData && frame.frequencyData.length > 0 ? frame.frequencyData[0].frequency : 0,
                    centroid: frame.spectralCentroid,
                    fftBins: frame.dataArray ? Array.from(frame.dataArray) : null,
                    harmonics: frame.harmonics || []
                })) : [],
                // CST v2.0+ additive: Include particle snapshots with full 11D data
                particles: particles.map(p => ({
                    id: p.id,
                    parent: p.parent || null,
                    createdAt: p.createdAt / 1000, // Convert to seconds
                    color: '#' + p.color.toString(16).padStart(6, '0'),
                    mass: parseFloat(p.mass.toFixed(3)),
                    frequency: parseFloat(p.frequency.toFixed(2)),
                    vi: parseFloat(p.vi.toFixed(2)),
                    theta: parseFloat(p.theta.toFixed(4)),
                    omega: parseFloat(p.omega.toFixed(6)),
                    x12: parseFloat(p.x12.toFixed(4)),
                    m12: parseFloat(p.m12.toFixed(4)),
                    Ec: parseFloat(p.Ec.toFixed(6)),
                    Ugrav: parseFloat(p.Ugrav.toFixed(6)),
                    Udm: parseFloat(p.Udm.toFixed(6)),
                    projection11D: {
                        pos11D: Array.from(p.projection11D.pos11D).map(v => parseFloat(v.toFixed(6))),
                        vel11D: Array.from(p.projection11D.vel11D).map(v => parseFloat(v.toFixed(6)))
                    },
                    trailCount: p.points ? p.points.length : 0
                })),
                tokens: tokens,
                // CST v2.0+ additive: Replay integrity hash for deterministic verification
                replayIntegrity: determinism.mode === 'replay' && determinism.recordedAudioFrames.length > 0 ? {
                    seed: determinism.seed,
                    frameCount: determinism.recordedAudioFrames.length,
                    tokenHash: tokens.length > 0 ? tokens.map(t => t.id).join('').substring(0, 32) : null,
                    // Simple hash of first 10 frames for verification
                    frameHash: determinism.recordedAudioFrames.slice(0, 10).map(f => 
                        `${f.rmsEnergy.toFixed(4)}_${f.spectralCentroid.toFixed(2)}`
                    ).join('|').substring(0, 100)
                } : null,
                // CST v2.0+ additive: Recording hash for deterministic verification
                recordingHash: computeRecordingHash(determinism.recordedAudioFrames, determinism.seed || projectionConfig.randomSeed)
            };
            
            const dataStr = JSON.stringify(exportData, null, compact ? 0 : 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `cosmic_tokens_${compact ? 'compact' : 'full'}_${Date.now()}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            updateStatus(`üì¶ Exported ${tokens.length} tokens (${tokenGenerationRate.toFixed(1)} tokens/sec) to ${compact ? 'compact' : 'full'} JSON file`);
        }

        function clearTokens() {
                tokens = [];
                tokenCount = 0;
                replicationCount = 0;
            tokenRateWindow.timestamps = [];
                particles.forEach(p => p.tokens = []);
                updateTokenDisplay();
                updateStatus('All tokens cleared');
        }

        // Event listeners - CST v2.0+ fix: Add null checks to prevent errors if elements don't exist
        const sigmaEl = document.getElementById('sigma');
        if (sigmaEl) {
            sigmaEl.addEventListener('input', (e) => {
                sigma = parseFloat(e.target.value);
                const displayEl = document.getElementById('sigma-display');
                if (displayEl) displayEl.textContent = sigma.toFixed(1);
            });
        }

        const rhoEl = document.getElementById('rho');
        if (rhoEl) {
            rhoEl.addEventListener('input', (e) => {
                rho = parseFloat(e.target.value);
                const displayEl = document.getElementById('rho-display');
                if (displayEl) displayEl.textContent = rho.toFixed(1);
            });
        }

        const betaEl = document.getElementById('beta');
        if (betaEl) {
            betaEl.addEventListener('input', (e) => {
                beta = parseFloat(e.target.value);
                const displayEl = document.getElementById('beta-display');
                if (displayEl) displayEl.textContent = beta.toFixed(3);
            });
        }

        const sensitivityEl = document.getElementById('sensitivity');
        if (sensitivityEl) {
            sensitivityEl.addEventListener('input', (e) => {
                audioSensitivity = parseFloat(e.target.value);
                const displayEl = document.getElementById('sensitivity-display');
                if (displayEl) displayEl.textContent = audioSensitivity.toFixed(1);
            });
        }

        const replicationEl = document.getElementById('replication');
        if (replicationEl) {
            replicationEl.addEventListener('input', (e) => {
                replicationThreshold = parseFloat(e.target.value);
                const displayEl = document.getElementById('replication-display');
                if (displayEl) displayEl.textContent = replicationThreshold.toFixed(0);
            });
        }

        // 12D CST Event Listeners
        const blendLorenzEl = document.getElementById('blend-lorenz');
        if (blendLorenzEl) {
            blendLorenzEl.addEventListener('input', (e) => {
                physics.blendLorenz = parseFloat(e.target.value);
                const displayEl = document.getElementById('blend-lorenz-display');
                if (displayEl) displayEl.textContent = physics.blendLorenz.toFixed(2);
            });
        }

        const gravEnabledEl = document.getElementById('grav-enabled');
        if (gravEnabledEl) {
            gravEnabledEl.addEventListener('change', (e) => {
                physics.gravEnabled = e.target.checked;
            });
        }

        const dmEnabledEl = document.getElementById('dm-enabled');
        if (dmEnabledEl) {
            dmEnabledEl.addEventListener('change', (e) => {
                physics.dmEnabled = e.target.checked;
            });
        }

        const rcutoffEl = document.getElementById('rcutoff');
        if (rcutoffEl) {
            rcutoffEl.addEventListener('input', (e) => {
                physics.rCutoff = parseFloat(e.target.value);
                const displayEl = document.getElementById('rcutoff-display');
                if (displayEl) displayEl.textContent = physics.rCutoff.toFixed(1);
            });
        }

        const epsilonEl = document.getElementById('epsilon');
        if (epsilonEl) {
            epsilonEl.addEventListener('input', (e) => {
                physics.epsilon = parseFloat(e.target.value);
                const displayEl = document.getElementById('epsilon-display');
                if (displayEl) displayEl.textContent = physics.epsilon.toFixed(2);
            });
        }

        const kEl = document.getElementById('k');
        if (kEl) {
            kEl.addEventListener('input', (e) => {
                adapt.k = parseFloat(e.target.value);
                const displayEl = document.getElementById('k-display');
                if (displayEl) displayEl.textContent = adapt.k.toFixed(1);
            });
        }

        const gammaEl = document.getElementById('gamma');
        if (gammaEl) {
            gammaEl.addEventListener('input', (e) => {
                adapt.gamma = parseFloat(e.target.value);
                const displayEl = document.getElementById('gamma-display');
                if (displayEl) displayEl.textContent = adapt.gamma.toFixed(2);
            });
        }

        const alphaEl = document.getElementById('alpha');
        if (alphaEl) {
            alphaEl.addEventListener('input', (e) => {
                adapt.alpha = parseFloat(e.target.value);
                const displayEl = document.getElementById('alpha-display');
                if (displayEl) displayEl.textContent = adapt.alpha.toFixed(2);
            });
        }

        const sigmaSimEl = document.getElementById('sigma-sim');
        if (sigmaSimEl) {
            sigmaSimEl.addEventListener('input', (e) => {
                adapt.sigmaSimilarity = parseFloat(e.target.value);
                const displayEl = document.getElementById('sigma-sim-display');
                if (displayEl) displayEl.textContent = adapt.sigmaSimilarity.toFixed(2);
            });
        }

        const ksyncEl = document.getElementById('ksync');
        if (ksyncEl) {
            ksyncEl.addEventListener('input', (e) => {
                sync.Ksync = parseFloat(e.target.value);
                const displayEl = document.getElementById('ksync-display');
                if (displayEl) displayEl.textContent = sync.Ksync.toFixed(2);
            });
        }

        const dtmaxEl = document.getElementById('dtmax');
        if (dtmaxEl) {
            dtmaxEl.addEventListener('input', (e) => {
                timestep.dtMax = parseFloat(e.target.value);
                const displayEl = document.getElementById('dtmax-display');
                if (displayEl) displayEl.textContent = timestep.dtMax.toFixed(3);
            });
        }

        const adaptiveDtEl = document.getElementById('adaptive-dt');
        if (adaptiveDtEl) {
            adaptiveDtEl.addEventListener('change', (e) => {
                timestep.adaptive = e.target.checked;
            });
        }

        const dmRho0El = document.getElementById('dm-rho0');
        if (dmRho0El) {
            dmRho0El.addEventListener('input', (e) => {
                dmParams.rho0 = parseFloat(e.target.value);
                const displayEl = document.getElementById('dm-rho0-display');
                if (displayEl) displayEl.textContent = dmParams.rho0.toFixed(1);
                // NEW: Update NFW profile plot when slider changes
                drawNfwProfile(dmParams.rho0, dmParams.rs);
            });
        }

        const dmRsEl = document.getElementById('dm-rs');
        if (dmRsEl) {
            dmRsEl.addEventListener('input', (e) => {
                dmParams.rs = parseFloat(e.target.value);
                const displayEl = document.getElementById('dm-rs-display');
                if (displayEl) displayEl.textContent = dmParams.rs.toFixed(1);
                // NEW: Update NFW profile plot when slider changes
                drawNfwProfile(dmParams.rho0, dmParams.rs);
            });
        }

        // CST v2.0+ additive: Projection mode selector event listener
        const projectionModeEl = document.getElementById('projection-mode');
        if (projectionModeEl) {
            projectionModeEl.addEventListener('change', (e) => {
                projectionConfig.mode = e.target.value;
                const statusEl = document.getElementById('projection-status');
                if (statusEl) statusEl.textContent = projectionConfig.mode;
                
                // Reset random projection matrix when switching modes (will regenerate on next use)
                if (projectionConfig.mode !== 'random_embedding') {
                    projectionConfig.randomR = null;
                } else {
                    // Force regeneration of random matrix with current seed
                    projectionConfig.randomR = null;
                }
                
                // Update all particles' projections immediately
                particles.forEach(p => p.update11DProjection());
                
                updateStatus(`Projection mode changed to: ${projectionConfig.mode}`);
            });
        }
        
        // CST v2.0+ additive: Cadence control (if element exists)
        const cadenceEl = document.getElementById('token-cadence');
        if (cadenceEl) {
            cadenceEl.addEventListener('input', (e) => {
                audioConfig.cadence = Math.max(1, Math.min(100, parseInt(e.target.value) || 100));
                const displayEl = document.getElementById('token-cadence-display');
                if (displayEl) displayEl.textContent = audioConfig.cadence;
                restartAudioProcessingLoop();
                restartReplayLoop();
                updateStatus(`Token cadence set to ${audioConfig.cadence}ms`);
            });
        }
        
        // CST v2.0+ additive: FFT size control (if element exists)
        const fftSizeEl = document.getElementById('fft-size');
        if (fftSizeEl) {
            fftSizeEl.addEventListener('change', (e) => {
                const validSizes = [256, 512, 1024, 2048, 4096, 8192];
                const newSize = parseInt(e.target.value);
                if (validSizes.includes(newSize)) {
                    audioConfig.fftSize = newSize;
                    // Restart audio if active
                    if (isAudioActive) {
                        const wasActive = isAudioActive;
                        stopAudio();
                        if (wasActive) {
                            setTimeout(() => toggleMicrophone(), 100);
                        }
                    }
                    updateStatus(`FFT size set to ${audioConfig.fftSize}`);
                }
            });
        }
        
        // CST v2.0+ additive: Token display limit control (if element exists)
        const tokenLimitEl = document.getElementById('token-display-limit');
        if (tokenLimitEl) {
            tokenLimitEl.addEventListener('input', (e) => {
                audioConfig.tokenDisplayLimit = Math.max(50, Math.min(1000, parseInt(e.target.value) || 200));
                const displayEl = document.getElementById('token-display-limit-display');
                if (displayEl) displayEl.textContent = audioConfig.tokenDisplayLimit;
                updateTokenDisplay();
                updateStatus(`Token display limit set to ${audioConfig.tokenDisplayLimit}`);
            });
        }

        // Recording and replay functions
        function toggleRecording() {
            determinism.isRecording = !determinism.isRecording;
            const btn = document.getElementById('record-btn');
            if (determinism.isRecording) {
                btn.textContent = '‚èπÔ∏è Stop Recording';
                determinism.recordedAudioFrames = [];
            } else {
                btn.textContent = 'üî¥ Start Recording';
            }
            reflectDeterminismUI();
        }

        function toggleReplay() {
            if (determinism.mode === 'replay') {
                determinism.mode = 'live';
                stopReplayProcessing();
                updateStatus('Replay mode disabled - back to live mode');
            } else {
                if (determinism.recordedAudioFrames.length > 0) {
                    toggleReplayMode({
                        recordedAudioFrames: determinism.recordedAudioFrames,
                        seed: determinism.seed || 12345
                    });
                    updateStatus(`Replay mode enabled - ${determinism.recordedAudioFrames.length} frames`);
                } else {
                    alert('No recorded frames available. Start recording first.');
                }
            }
            reflectDeterminismUI();
        }

        // CST v2.0: Initialize all UI display values on page load
        function initializeUIDisplays() {
            // Set initial display values for all sliders/controls
            const sigmaEl = document.getElementById('sigma-display');
            const rhoEl = document.getElementById('rho-display');
            const betaEl = document.getElementById('beta-display');
            const sensitivityEl = document.getElementById('sensitivity-display');
            const replicationEl = document.getElementById('replication-display');
            const blendLorenzEl = document.getElementById('blend-lorenz-display');
            const rcutoffEl = document.getElementById('rcutoff-display');
            const epsilonEl = document.getElementById('epsilon-display');
            const kEl = document.getElementById('k-display');
            const gammaEl = document.getElementById('gamma-display');
            const alphaEl = document.getElementById('alpha-display');
            const sigmaSimEl = document.getElementById('sigma-sim-display');
            const ksyncEl = document.getElementById('ksync-display');
            const dtmaxEl = document.getElementById('dtmax-display');
            const dmRho0El = document.getElementById('dm-rho0-display');
            const dmRsEl = document.getElementById('dm-rs-display');
            
            if (sigmaEl) sigmaEl.textContent = sigma.toFixed(1);
            if (rhoEl) rhoEl.textContent = rho.toFixed(1);
            if (betaEl) betaEl.textContent = beta.toFixed(3);
            if (sensitivityEl) sensitivityEl.textContent = audioSensitivity.toFixed(1);
            if (replicationEl) replicationEl.textContent = replicationThreshold.toFixed(0);
            if (blendLorenzEl) blendLorenzEl.textContent = physics.blendLorenz.toFixed(2);
            if (rcutoffEl) rcutoffEl.textContent = physics.rCutoff.toFixed(1);
            if (epsilonEl) epsilonEl.textContent = physics.epsilon.toFixed(2);
            if (kEl) kEl.textContent = adapt.k.toFixed(1);
            if (gammaEl) gammaEl.textContent = adapt.gamma.toFixed(2);
            if (alphaEl) alphaEl.textContent = adapt.alpha.toFixed(2);
            if (sigmaSimEl) sigmaSimEl.textContent = adapt.sigmaSimilarity.toFixed(2);
            if (ksyncEl) ksyncEl.textContent = sync.Ksync.toFixed(2);
            if (dtmaxEl) dtmaxEl.textContent = timestep.dtMax.toFixed(3);
            if (dmRho0El) dmRho0El.textContent = dmParams.rho0.toFixed(1);
            if (dmRsEl) dmRsEl.textContent = dmParams.rs.toFixed(1);
            
            // Set checkbox states
            const gravEnabledEl = document.getElementById('grav-enabled');
            const dmEnabledEl = document.getElementById('dm-enabled');
            const adaptiveDtEl = document.getElementById('adaptive-dt');
            if (gravEnabledEl) gravEnabledEl.checked = physics.gravEnabled;
            if (dmEnabledEl) dmEnabledEl.checked = physics.dmEnabled;
            if (adaptiveDtEl) adaptiveDtEl.checked = timestep.adaptive;
        }

        // === 12D CST: Drop-in completion block (additive, non-destructive) ===
        (function () {
            // Guarded define: helpers
            if (typeof safeNormalize !== 'function') {
                window.safeNormalize = function safeNormalize(value, ref) {
                    const r = (typeof ref === 'number' && ref !== 0) ? ref : 1;
                    const v = (typeof value === 'number' && isFinite(value)) ? value : 0;
                    return v / r;
                };
            }

            if (typeof computeLambdaTerm !== 'function') {
                window.computeLambdaTerm = function computeLambdaTerm(audioChaos, chaosDerivativeSum) {
                    const scale = 100;
                    const base = Math.log(Math.abs(chaosDerivativeSum) + 1) / scale;
                    return base + (isFinite(audioChaos) ? audioChaos : 0);
                };
            }

            if (typeof computeOmegaTerm !== 'function') {
                window.computeOmegaTerm = function computeOmegaTerm(particles, Eref) {
                    let sum = 0;
                    for (const p of particles) {
                        const normE = safeNormalize(p.Ec, Eref);
                        const omega = (typeof p.omega === 'number' && isFinite(p.omega)) ? p.omega : 0;
                        sum += omega * normE;
                    }
                    return sum;
                };
            }

            if (typeof computePotentialTerm !== 'function') {
                window.computePotentialTerm = function computePotentialTerm(particles, Eref) {
                    let sum = 0;
                    for (const p of particles) {
                        const U = ((p.Ugrav || 0) + (p.Udm || 0));
                        sum += safeNormalize(U, Eref);
                    }
                    return sum;
                };
            }

            if (typeof computeEnergyTerm !== 'function') {
                window.computeEnergyTerm = function computeEnergyTerm(particles, Eref) {
                    let sum = 0;
                    for (const p of particles) {
                        sum += phi * safeNormalize(p.Ec, Eref);
                    }
                    return sum;
                };
            }

            // Guarded define: œà normalized breakdown
            if (typeof updatePsiNormalized !== 'function') {
                window.updatePsiNormalized = function updatePsiNormalized(particles, refs, accum) {
                    const terms = {
                        energyTerm: 0,
                        lambdaTerm: 0,
                        velocityIntegralTerm: 0,
                        x12IntegralTerm: 0,
                        omegaTerm: 0,
                        potentialTerm: 0
                    };
                    if (!particles || particles.length === 0) {
                        return { terms, psiTotal: 0 };
                    }
                    let chaosDerivativeSum = 0;
                    particles.forEach((p) => {
                        const pid = p.id;
                        const vMag = Math.sqrt(p.velocity.x ** 2 + p.velocity.y ** 2 + p.velocity.z ** 2);
                        chaosDerivativeSum += Math.abs(vMag);
                        const vIntPrev = accum.velocityIntegral.get(pid) || 0;
                        const vIntNew = vIntPrev + safeNormalize(vMag, refs.vref) * timestep.dt;
                        accum.velocityIntegral.set(pid, vIntNew);
                        const x12Prev = accum.x12Previous.get(pid);
                        if (x12Prev !== undefined) {
                            const deltaX12 = Math.abs(p.x12 - x12Prev);
                            const x12IntPrev = accum.x12Integral.get(pid) || 0;
                            const x12IntNew = x12IntPrev + deltaX12 * timestep.dt;
                            accum.x12Integral.set(pid, x12IntNew);
                        } else {
                            accum.x12Integral.set(pid, 0);
                        }
                        accum.x12Previous.set(pid, p.x12);
                    });
                    terms.energyTerm = computeEnergyTerm(particles, refs.Eref);
                    terms.lambdaTerm = computeLambdaTerm(isAudioActive ? calculateAudioChaos() : 0, chaosDerivativeSum);
                    terms.velocityIntegralTerm = Array.from(accum.velocityIntegral.values()).reduce((a, b) => a + b, 0);
                    terms.x12IntegralTerm = Array.from(accum.x12Integral.values()).reduce((a, b) => a + b, 0);
                    terms.omegaTerm = computeOmegaTerm(particles, refs.Eref);
                    terms.potentialTerm = computePotentialTerm(particles, refs.Eref);
                    const psiTotal = terms.energyTerm + terms.lambdaTerm + terms.velocityIntegralTerm +
                                   terms.x12IntegralTerm + terms.omegaTerm + terms.potentialTerm;
                    return { terms, psiTotal };
                };
            }

            // Guarded define: entropy trace smoothing and draw
            if (typeof getSmoothedEntropy !== 'function') {
                window.entropyTrace = Array.isArray(window.entropyTrace) ? window.entropyTrace : [];
                window.entropyTraceConfig = window.entropyTraceConfig || { emaAlpha: 0.3 };
                window.entropyEma = window.entropyEma ?? null;
                window.getSmoothedEntropy = function getSmoothedEntropy(current) {
                    if (entropyEma === null || !isFinite(entropyEma)) {
                        entropyEma = current;
                        return current;
                    }
                    entropyEma = entropyTraceConfig.emaAlpha * current + (1 - entropyTraceConfig.emaAlpha) * entropyEma;
                    return entropyEma;
                };
            }

            if (typeof drawEntropyTrace !== 'function') {
                window.drawEntropyTrace = function drawEntropyTrace(entropyValue) {
                    if (!entropyState || !entropyState.traceCtx) return;
                    const ctx = entropyState.traceCtx;
                    const canvas = ctx.canvas;
                    const width = canvas.width || 400;
                    const height = canvas.height || 60;
                    const smoothed = getSmoothedEntropy(entropyValue);
                    if (typeof smoothed === 'number' && isFinite(smoothed)) {
                        entropyTrace.push(smoothed);
                    }
                    while (entropyTrace.length > width) entropyTrace.shift();
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
                    ctx.fillRect(0, 0, width, height);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, height / 2);
                    ctx.lineTo(width, height / 2);
                    ctx.stroke();
                    if (entropyTrace.length > 1) {
                        const valid = entropyTrace.filter(v => typeof v === 'number' && isFinite(v));
                        const min = valid.length ? Math.min(...valid) : 0;
                        const max = valid.length ? Math.max(...valid) : 1;
                        const range = Math.max(max - min, 1e-6);
                        const traceHeight = height * 0.8;
                        const baseline = height / 2;
                        ctx.beginPath();
                        ctx.strokeStyle = '#00ffcc';
                        ctx.lineWidth = 2;
                        let first = true;
                        for (let i = 0; i < entropyTrace.length; i++) {
                            const val = entropyTrace[i];
                            if (typeof val !== 'number' || !isFinite(val)) continue;
                            const norm = (val - min) / range;
                            const y = baseline + (traceHeight / 2) - (norm * traceHeight);
                            const clampedY = Math.max(0, Math.min(height, y));
                            if (first) { ctx.moveTo(i, clampedY); first = false; } else { ctx.lineTo(i, clampedY); }
                        }
                        ctx.stroke();
                    }
                };
            }

            // Guarded define: adaptive state canvas and trace
            if (typeof initAdaptiveStateCanvas !== 'function') {
                window.adaptiveStateCtx = null;
                window.x12History = [];
                window.initAdaptiveStateCanvas = function initAdaptiveStateCanvas() {
                    const canvas = document.getElementById('adaptiveStateCanvas');
                    if (!canvas) return;
                    adaptiveStateCtx = canvas.getContext('2d');
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 120;
                    window.addEventListener('resize', () => {
                        if (!adaptiveStateCtx) return;
                        const c = adaptiveStateCtx.canvas;
                        c.width = c.offsetWidth || 400;
                        c.height = 120;
                    });
                };
            }

            if (typeof updateAdaptiveStateTrace !== 'function') {
                window.updateAdaptiveStateTrace = function updateAdaptiveStateTrace() {
                    if (!adaptiveStateCtx || !Array.isArray(particles)) return;
                    const ctx = adaptiveStateCtx;
                    const c = ctx.canvas;
                    const width = c.width || 400;
                    const height = c.height || 120;
                    while (x12History.length < particles.length) x12History.push([]);
                    if (x12History.length > particles.length) x12History.length = particles.length;
                    particles.forEach((p, i) => {
                        const val = (typeof p.x12 === 'number' && isFinite(p.x12)) ? p.x12 : 0;
                        x12History[i].push(val);
                        while (x12History[i].length > width) x12History[i].shift();
                    });
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = 'rgba(10, 10, 26, 0.25)';
                    ctx.fillRect(0, 0, width, height);
                    const baseline = height / 2;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.beginPath();
                    ctx.moveTo(0, baseline);
                    ctx.lineTo(width, baseline);
                    ctx.stroke();
                    particles.forEach((p, i) => {
                        const colorHex = '#' + p.color.toString(16).padStart(6, '0');
                        ctx.strokeStyle = colorHex;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        let first = true;
                        const hist = x12History[i];
                        for (let x = 0; x < hist.length; x++) {
                            const y = baseline - (hist[x] * (height * 0.45));
                            const clampedY = Math.max(0, Math.min(height, y));
                            if (first) { ctx.moveTo(x, clampedY); first = false; } else { ctx.lineTo(x, clampedY); }
                        }
                        ctx.stroke();
                    });
                };
            }

            // Guarded define: theta std
            if (typeof computeThetaStd !== 'function') {
                window.computeThetaStd = function computeThetaStd(particles) {
                    if (!particles || particles.length === 0) return 0;
                    const thetas = particles.map(p => p.theta || 0);
                    const mean = thetas.reduce((a, b) => a + b, 0) / thetas.length;
                    const variance = thetas.reduce((a, b) => a + (b - mean) ** 2, 0) / thetas.length;
                    return Math.sqrt(variance);
                };
            }

            // Guarded define: dark matter profile canvas and draw
            if (typeof initDmProfileCanvas !== 'function') {
                window.dmProfileCtx = null;
                window.initDmProfileCanvas = function initDmProfileCanvas() {
                    const canvas = document.getElementById('dmProfileCanvas');
                    if (!canvas) return;
                    dmProfileCtx = canvas.getContext('2d');
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 120;
                    window.addEventListener('resize', () => {
                        if (!dmProfileCtx) return;
                        const c = dmProfileCtx.canvas;
                        c.width = c.offsetWidth || 400;
                        c.height = 120;
                    });
                };
            }

            if (typeof drawNfwProfile !== 'function') {
                window.drawNfwProfile = function drawNfwProfile(rho0, rs) {
                    if (!dmProfileCtx) return;
                    const ctx = dmProfileCtx;
                    const c = ctx.canvas;
                    const width = c.width || 400;
                    const height = c.height || 120;
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = 'rgba(10,10,26,0.25)';
                    ctx.fillRect(0, 0, width, height);
                    const samples = 200;
                    const rMin = Math.max(0.1 * rs, 1e-6);
                    const rMax = 10 * rs;
                    const values = [];
                    for (let i = 0; i < samples; i++) {
                        const t = i / (samples - 1);
                        const r = rMin * Math.pow(rMax / rMin, t);
                        const r_rs = r / rs;
                        const rho = r_rs > 0 ? rho0 / (r_rs * Math.pow(1 + r_rs, 2)) : 0;
                        values.push({ r, rho });
                    }
                    const rhoMax = Math.max(...values.map(v => v.rho), 1e-12);
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    values.forEach((v, i) => {
                        const x = (i / (samples - 1)) * width;
                        const y = height - (Math.log(v.rho + 1) / Math.log(rhoMax + 1)) * height;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                };
            }

            // Guarded define: replay validation updater
            if (typeof updateReplayValidation !== 'function') {
                window.updateReplayValidation = function updateReplayValidation(consStats, virial) {
                    if (!determinism || determinism.mode !== 'replay') return;
                    const edriftEl = document.getElementById('replay-edrift');
                    const pmagEl = document.getElementById('replay-pmag');
                    const lmagEl = document.getElementById('replay-lmag');
                    const virialEl = document.getElementById('replay-virial');
                    if (!edriftEl || !pmagEl || !lmagEl || !virialEl) return;
                    edriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
                    const Pmag = Math.sqrt(consStats.P.x ** 2 + consStats.P.y ** 2 + consStats.P.z ** 2);
                    const Lmag = Math.sqrt(consStats.L.x ** 2 + consStats.L.y ** 2 + consStats.L.z ** 2);
                    pmagEl.textContent = Pmag.toExponential(2);
                    lmagEl.textContent = Lmag.toExponential(2);
                    virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
                };
            }

            // Guarded define: psi snapshot for token enrichment
            if (typeof currentPsiSnapshot !== 'function') {
                window.currentPsiSnapshot = function currentPsiSnapshot() {
                    const psiResult = updatePsiNormalized(particles || [], physics, psiAccumulators);
                    return {
                        energyTerm: parseFloat(psiResult.terms.energyTerm.toFixed(6)),
                        lambdaTerm: parseFloat(psiResult.terms.lambdaTerm.toFixed(6)),
                        velocityIntegralTerm: parseFloat(psiResult.terms.velocityIntegralTerm.toFixed(6)),
                        x12IntegralTerm: parseFloat(psiResult.terms.x12IntegralTerm.toFixed(6)),
                        omegaTerm: parseFloat(psiResult.terms.omegaTerm.toFixed(6)),
                        potentialTerm: parseFloat(psiResult.terms.potentialTerm.toFixed(6)),
                        psiTotal: parseFloat(psiResult.psiTotal.toFixed(6))
                    };
                };
            }

            // Guarded patch: inject psiBreakdown into tokens if missing at runtime
            const originalGenerateParticleToken = window.generateParticleToken;
            if (typeof originalGenerateParticleToken === 'function' && !originalGenerateParticleToken.__patched) {
                window.generateParticleToken = function patchedGenerateParticleToken(particle, eventType) {
                    const token = originalGenerateParticleToken.call(this, particle, eventType);
                    if (token && token.psiBreakdown == null && typeof currentPsiSnapshot === 'function') {
                        token.psiBreakdown = currentPsiSnapshot();
                    }
                    return token;
                };
                window.generateParticleToken.__patched = true;
            }

            const originalGenerateAudioFrameToken = window.generateAudioFrameToken;
            if (typeof originalGenerateAudioFrameToken === 'function' && !originalGenerateAudioFrameToken.__patched) {
                window.generateAudioFrameToken = function patchedGenerateAudioFrameToken(frequencyData, rmsEnergy, spectralCentroid, harmonics) {
                    const token = originalGenerateAudioFrameToken.call(this, frequencyData, rmsEnergy, spectralCentroid, harmonics);
                    if (token && token.psiBreakdown == null && typeof currentPsiSnapshot === 'function') {
                        token.psiBreakdown = currentPsiSnapshot();
                    }
                    return token;
                };
                window.generateAudioFrameToken.__patched = true;
            }

            const originalGenerateHarmonicToken = window.generateHarmonicToken;
            if (typeof originalGenerateHarmonicToken === 'function' && !originalGenerateHarmonicToken.__patched) {
                window.generateHarmonicToken = function patchedGenerateHarmonicToken(harmonic, magnitude, index) {
                    const token = originalGenerateHarmonicToken.call(this, harmonic, magnitude, index);
                    if (token && token.psiBreakdown == null && typeof currentPsiSnapshot === 'function') {
                        token.psiBreakdown = currentPsiSnapshot();
                    }
                    return token;
                };
                window.generateHarmonicToken.__patched = true;
            }

            // Wire-ups (safe to call even if already wired elsewhere)
            const originalUpdateAdvancedUI = window.updateAdvancedUI;
            if (typeof originalUpdateAdvancedUI === 'function' && !originalUpdateAdvancedUI.__patched) {
                window.updateAdvancedUI = function patchedUpdateAdvancedUI(consStats, virial, psiResult, syncMetric) {
                    originalUpdateAdvancedUI.call(this, consStats, virial, psiResult, syncMetric);
                    // Ensure replay panel updates during replay
                    updateReplayValidation(consStats, virial);
                    // Ensure œà breakdown panel updates
                    if (typeof updatePsiBreakdown === 'function') updatePsiBreakdown();
                };
                window.updateAdvancedUI.__patched = true;
            }

            // Final sanity: ensure init is called after DOM is ready
            document.addEventListener('DOMContentLoaded', () => {
                if (typeof initAdaptiveStateCanvas === 'function') initAdaptiveStateCanvas();
                if (typeof initDmProfileCanvas === 'function') initDmProfileCanvas();
                if (typeof drawNfwProfile === 'function' && typeof dmParams !== 'undefined') {
                    drawNfwProfile(dmParams.rho0, dmParams.rs);
                }
            });
        })();

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            initThree();
            initFrequencyCanvas();
            initEntropyCanvas(); // CST v2.0+ additive: Initialize entropy canvas
            initAdaptiveStateCanvas(); // NEW: Initialize adaptive state canvas
            initDmProfileCanvas(); // NEW: Initialize dark matter profile canvas
            initializeUIDisplays(); // CST v2.0: Set all initial display values
            drawNfwProfile(dmParams.rho0, dmParams.rs); // NEW: Draw initial NFW profile
            updatePsi(0);
            updateStatus('üé§ System ready - Click START MICROPHONE for continuous audio‚Üítoken generation pipeline');
            animate(); // Start animation loop
        });
    </script>
</body>
</html>