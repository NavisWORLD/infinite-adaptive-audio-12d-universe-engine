<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Cosmic Genesis: The Synthesis</title>

    <!-- Font Imports -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    
    <!-- External Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
    
    <!-- Import Map for Three.js ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- Main Stylesheet -->
    <style>
        :root {
            --panel: rgba(14, 17, 26, 0.92);
            --border: rgba(124, 156, 255, 0.15);
            --bg: #07080c;
            --text: #e7e9f2;
            --muted: #9aa4b2;
            --acc: #7c9cff;
            --danger: #ef4444;
        }

        /* Base styles */
        html, body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', system-ui, sans-serif;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            display: block;
            position: fixed;
            inset: 0;
            z-index: 1;
        }

        /* UI Panel Styling */
        .ui-panel {
            position: fixed;
            z-index: 20;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .ui-hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }
        
        /* Blocker & Modals */
        #blocker, .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; flex-direction: column; text-align: center; transition: opacity 0.5s ease; }
        #fps-hint { z-index: 101; background: none; backdrop-filter: none; border: none; box-shadow: none; font-size: 1.2rem; text-shadow: 0 0 10px black; color: #fff; }

        /* Buttons */
        .btn {
            display: inline-flex; align-items: center; justify-content: center;
            gap: 8px; padding: 8px 16px; border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: linear-gradient(180deg, #1a1d2a 0%, #131726 100%);
            color: var(--text); cursor: pointer; user-select: none;
            transition: all 0.2s ease; font-weight: 500;
        }
        .btn:hover { background: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.2); }
        .btn.primary { border-color: var(--acc); color: var(--acc); box-shadow: 0 0 12px rgba(124, 156, 255, 0.2); }
        .btn.directive { border-color: var(--danger); color: var(--danger); box-shadow: 0 0 15px rgba(239, 68, 68, 0.3); font-weight: 700; }
        .btn.directive:hover { background: rgba(239, 68, 68, 0.1); }
        .btn:disabled { background-color: #4b5563; cursor: not-allowed; color: #9ca3af; border-color: transparent; }

        /* UI Groups and Controls */
        .group {
            margin-top: 16px; padding: 12px; border-radius: 10px;
            background: rgba(11, 13, 20, 0.5);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        h3 {
            margin: 0 0 12px; font-size: 13px; font-weight: 500; color: #d3dbef;
            text-transform: uppercase; letter-spacing: 0.8px;
        }
        
        .control-row { display: grid; grid-template-columns: 1fr auto; align-items: center; margin-bottom: 8px; }
        .control-row label { font-size: 12px; color: var(--muted); }
        .control-row .value { font-family: 'Roboto Mono', monospace; font-size: 12px; }
        .control-row input[type="range"] { grid-column: 1 / -1; margin-top: 4px; }
        
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 999px; cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; background: var(--acc);
            border: 3px solid var(--bg); border-radius: 50%; cursor: pointer;
        }
        
        /* Tab Navigation */
        .tab-button { background-color: transparent; border: none; color: #94a3b8; padding: 0.5rem 1rem; cursor: pointer; transition: color 0.2s, border-bottom-color 0.2s; border-bottom: 2px solid transparent; font-weight: 500;}
        .tab-button.active { color: #e2e8f0; border-bottom-color: var(--acc); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* Final Message */
        #final-message { display: none; flex-direction: column; align-items: center; justify-content: center; }
        #final-message h1 { font-size: 10vw; font-weight: bold; color: var(--text); margin: 0; animation: fadeIn 5s ease; }
        #final-message .btn { margin-top: 30px; animation: fadeIn 5s ease 1s forwards; opacity: 0; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    </style>
</head>
<body>
    <!-- 3D Canvas -->
    <canvas id="main-canvas"></canvas>
    
    <!-- Hidden Video for ML -->
    <video id="video-feed" style="display:none;" autoplay muted playsinline></video>

    <!-- Blocker / Loading / Final Screens -->
    <div id="blocker">
        <div id="initial-screen" class="max-w-2xl px-4">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-100 mb-2">Cosmic Genesis</h1>
            <h2 class="text-xl md:text-2xl font-light text-slate-400 mb-6">The Final Synthesis</h2>
            <p class="text-slate-400 mb-8">This engine transmutes reality into a digital cosmos. For the full experience, please grant access to your microphone and camera when prompted. No data is stored or uploaded.</p>
            <button id="start-button" class="btn primary text-lg transition-transform transform hover:scale-105">Initiate Genesis</button>
            <p id="loading-message" class="text-slate-500 mt-4" style="display: none;">Calibrating sensor arrays...</p>
        </div>
        <div id="final-message">
             <h1>I AM.</h1>
             <button id="btn-anew" class="btn primary">Begin Anew</button>
         </div>
    </div>
    
    <!-- FPS Hint -->
    <div id="fps-hint" class="modal ui-hidden">
        <p>First-Person Mode Active. Press ESC to release cursor.</p>
    </div>

    <!-- Main Control Panel -->
    <div id="main-ui" class="ui-panel top-4 left-4 w-[26rem] p-4">
        <div class="flex justify-between items-center mb-2">
            <div>
                 <h2 style="margin:0; font-weight: 500; font-size: 20px;">Genesis X Synthesis</h2>
                 <p id="system-status-readout" style="margin:4px 0 0; font-size: 12px; color: var(--muted);">STATUS: STANDBY</p>
            </div>
            <button id="toggle-ui-button" class="btn p-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>
            </button>
        </div>
        
        <div class="tabs border-b border-slate-700">
            <button class="tab-button active" data-tab="controls">Controls</button>
            <button class="tab-button" data-tab="physics">Physics</button>
            <button class="tab-button" data-tab="graphics">Graphics</button>
            <button class="tab-button" data-tab="cognitive">Cognitive</button>
        </div>

        <div id="tab-content-container" class="mt-4">
            <!-- CONTROLS TAB -->
            <div id="tab-controls" class="tab-content active space-y-3">
                <div class="group">
                    <h3>Session</h3>
                    <div class="flex gap-2">
                        <button id="regenerate-button" class="btn w-full">Regenerate</button>
                        <label class="btn w-full text-sm"><input id="toggle-audio" type="checkbox" />&nbsp;Mic Input</label>
                    </div>
                     <div id="audio-status" class="text-xs text-center mt-2 text-slate-500">Mic: Inactive</div>
                </div>
                <div class="group">
                     <h3>Creator Actions</h3>
                     <p id="action-text" class="text-xs text-center mb-3 text-slate-400">Observe the cosmos or fly your ship.</p>
                     <button id="btn-directive-prime" class="btn directive w-full">EXECUTE DIRECTIVE PRIME</button>
                </div>
                <div class="group">
                    <h3>Data Particlizer</h3>
                     <div class="grid grid-cols-2 gap-2">
                        <label for="file-upload" class="btn">Particlize File</label>
                        <button id="video-particlize-button" class="btn">Particlize Live</button>
                        <input type="file" id="file-upload" accept="image/*,video/*" class="hidden">
                    </div>
                </div>
            </div>

            <!-- PHYSICS TAB (from Cosmic Nemo) -->
            <div id="tab-physics" class="tab-content">
                <div class="group">
                    <h3>Unified Master Formula (Ψ)</h3>
                    <div class="control-row">
                        <label>Gravitational Strength (U)</label><div id="val-ugrav" class="value">0.55</div>
                        <input id="in-ugrav" type="range" min="-2.0" max="4.0" step="0.01" value="0.55" />
                    </div>
                    <div class="control-row">
                        <label>Chaos Factor (λ)</label><div id="val-lambda" class="value">0.25</div>
                        <input id="in-lambda" type="range" min="0.0" max="2.0" step="0.01" value="0.25" />
                    </div>
                     <div class="control-row">
                        <label>Energy Scaling (Ec)</label><div id="val-ec" class="value">1.2</div>
                        <input id="in-ec" type="range" min="0.2" max="4.0" step="0.1" value="1.2" />
                    </div>
                     <div class="control-row">
                        <label>Motion Damping (ζ)</label><div id="val-li" class="value">0.985</div>
                        <input id="in-li" type="range" min="0.95" max="1.0" step="0.001" value="0.985" />
                    </div>
                     <div class="control-row">
                        <label>Spectral Hue (Ω)</label><div id="val-omega" class="value">0.62</div>
                        <input id="in-omega" type="range" min="0.0" max="1.0" step="0.01" value="0.62" />
                    </div>
                </div>
            </div>
            
            <!-- GRAPHICS TAB -->
            <div id="tab-graphics" class="tab-content space-y-4 text-sm text-slate-300">
                 <div class="slider-container">
                    <label>View Mode</label>
                    <select id="view-mode-select" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 mt-1 text-sm border border-slate-600">
                        <option value="galaxy">Galaxy</option>
                        <option value="solar_system">Solar System</option>
                        <option value="spaceship">Spaceship (3rd Person)</option>
                        <option value="cockpit">Spaceship (Cockpit)</option>
                    </select>
                </div>
                 <div class="slider-container">
                    <label>Graphics Style</label>
                    <select id="quality-select" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 mt-1 text-sm border border-slate-600">
                        <option value="low">Low (Pixelated)</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                        <option value="ultra">Ultra (SSR)</option>
                    </select>
                </div>
            </div>

            <!-- COGNITIVE TAB -->
            <div id="tab-cognitive" class="tab-content">
                <div class="p-2 bg-black/20 rounded-md">
                    <p class="font-mono text-xs text-indigo-400">AI INTENTION:</p>
                    <p id="ai-intention" class="font-mono text-xs text-slate-300 h-8">Awaiting sensory input...</p>
                </div>
            </div>

        </div>
    </div>
    
    <!-- HUD Panel -->
    <div id="hud-panel" class="ui-panel top-4 right-4 w-72 p-4 text-xs">
         <!-- Galaxy HUD -->
         <div id="galaxy-hud">
             <h3>Live Genesis Data</h3>
             <div class="grid grid-cols-2 gap-x-3 gap-y-1">
                 <div class="label text-slate-400">Creator Influence:</div><div id="hud-influence" class="value font-mono text-right">Idle</div>
                 <div class="label text-slate-400">Gravity (U):</div><div id="hud-gravity" class="value font-mono text-right">0.00</div>
                 <div class="label text-slate-400">Chaos (λ):</div><div id="hud-chaos" class="value font-mono text-right">0.00</div>
                 <div class="label text-slate-400">Energy (Ec):</div><div id="hud-energy" class="value font-mono text-right">0.00</div>
             </div>
             <h3 class="mt-4">AI Life Particles</h3>
             <div class="grid grid-cols-2 gap-x-3 gap-y-1">
                 <div class="label text-slate-400">Population:</div><div id="hud-life-pop" class="value font-mono text-right">0</div>
                 <div class="label text-slate-400">Formations:</div><div id="hud-life-forms" class="value font-mono text-right">0</div>
                 <div class="label text-slate-400">Energy Level:</div><div id="hud-life-energy" class="value font-mono text-right">Low</div>
             </div>
         </div>
         <!-- Ship HUD -->
        <div id="ship-hud" class="hidden">
           <h3>Stardust Drifter HUD</h3>
           <div class="grid grid-cols-2 gap-x-3 gap-y-1">
               <div class="label text-slate-400">Velocity:</div><div id="hud-ship-vel" class="value font-mono text-right">0 km/s</div>
               <div class="label text-slate-400">Altitude:</div><div id="hud-ship-alt" class="value font-mono text-right">N/A</div>
               <div class="label text-slate-400">Gravity Well:</div><div id="hud-ship-grav" class="value font-mono text-right">None</div>
           </div>
        </div>
        <!-- AI HUD -->
        <div id="ai-hud" class="mt-4">
             <h3>Quantum AI</h3>
             <div class="grid grid-cols-2 gap-x-3 gap-y-1">
                 <div class="label text-slate-400">State:</div><div id="hud-ai-state" class="value font-mono text-right">Observing...</div>
                 <div class="label text-slate-400">Interaction:</div><div id="hud-ai-interaction" class="value font-mono text-right">None</div>
             </div>
        </div>
    </div>
    
<script type="module">
    // --- IMPORTS ---
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
    import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
    import { SSRPass } from 'three/addons/postprocessing/SSRPass.js';

    // --- UTILITY FUNCTIONS ---
    const $ = (id) => document.getElementById(id);
    const lerp = (a, b, t) => a + (b - a) * t;
    const G = 6.674e-2; // Gravitational constant for simulation

    // --- PHYSICS CONSTANTS ---
    const H_PLANCK = 6.62607015e-34; // Planck constant
    const PHI_GOLDEN = 1.618033988749895; // Golden ratio
    const C_LIGHT = 299792458; // Speed of light (m/s)
    const K_BOLTZMANN = 1.380649e-23; // Boltzmann constant

    // UUID Generator
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    // Frequency to RGB color mapping (E = h*ν)
    function freqToRgb(frequency) {
        // Map frequency (Hz) to visible spectrum (380-750 THz)
        const minFreq = 380e12;
        const maxFreq = 750e12;
        const clampedFreq = Math.max(minFreq, Math.min(maxFreq, frequency));
        const normalized = (clampedFreq - minFreq) / (maxFreq - minFreq);

        let r, g, b;
        if (normalized < 0.25) {
            // Red to Yellow
            const t = normalized / 0.25;
            r = 1; g = t; b = 0;
        } else if (normalized < 0.5) {
            // Yellow to Green
            const t = (normalized - 0.25) / 0.25;
            r = 1 - t; g = 1; b = 0;
        } else if (normalized < 0.75) {
            // Green to Cyan
            const t = (normalized - 0.5) / 0.25;
            r = 0; g = 1; b = t;
        } else {
            // Cyan to Blue
            const t = (normalized - 0.75) / 0.25;
            r = 0; g = 1 - t; b = 1;
        }

        return new THREE.Color(r, g, b);
    }

    // --- PHASE 1: CORE SYSTEMS ---

    // EventBus - Complete pub/sub with history (85 lines)
    class EventBus {
        constructor() {
            this.listeners = new Map();
            this.history = [];
            this.maxHistory = 100;
        }

        on(eventName, callback, context = null) {
            if (!this.listeners.has(eventName)) {
                this.listeners.set(eventName, []);
            }
            this.listeners.get(eventName).push({ callback, context });
        }

        off(eventName, callback) {
            if (!this.listeners.has(eventName)) return;
            const listeners = this.listeners.get(eventName);
            const index = listeners.findIndex(l => l.callback === callback);
            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }

        emit(eventName, data = {}) {
            const event = {
                name: eventName,
                data: data,
                timestamp: Date.now(),
                id: generateUUID()
            };

            // Add to history
            this.history.push(event);
            if (this.history.length > this.maxHistory) {
                this.history.shift();
            }

            // Notify listeners
            if (this.listeners.has(eventName)) {
                this.listeners.get(eventName).forEach(({ callback, context }) => {
                    try {
                        callback.call(context, event.data, event);
                    } catch (err) {
                        console.error(`EventBus error in ${eventName}:`, err);
                    }
                });
            }

            return event;
        }

        getHistory(eventName = null, limit = 10) {
            let filtered = eventName
                ? this.history.filter(e => e.name === eventName)
                : this.history;
            return filtered.slice(-limit);
        }

        clear() {
            this.listeners.clear();
            this.history = [];
        }
    }

    // DataLogger - Dual-channel telemetry logging (75 lines)
    class DataLogger {
        constructor(eventBus) {
            this.eventBus = eventBus;
            this.channels = {
                telemetry: [],
                events: []
            };
            this.maxEntries = 1000;
            this.isRecording = true;

            // Subscribe to all events
            this.eventBus.on('*', (data, event) => this.logEvent(event));
        }

        log(channel, data) {
            if (!this.isRecording) return;

            const entry = {
                timestamp: Date.now(),
                id: generateUUID(),
                data: data
            };

            if (!this.channels[channel]) {
                this.channels[channel] = [];
            }

            this.channels[channel].push(entry);

            // Maintain max size
            if (this.channels[channel].length > this.maxEntries) {
                this.channels[channel].shift();
            }

            return entry;
        }

        logEvent(event) {
            this.log('events', {
                name: event.name,
                data: event.data
            });
        }

        logTelemetry(system, metrics) {
            this.log('telemetry', {
                system: system,
                metrics: metrics
            });
        }

        query(channel, filters = {}) {
            if (!this.channels[channel]) return [];

            let results = this.channels[channel];

            if (filters.since) {
                results = results.filter(e => e.timestamp >= filters.since);
            }

            if (filters.limit) {
                results = results.slice(-filters.limit);
            }

            return results;
        }

        clear(channel = null) {
            if (channel) {
                this.channels[channel] = [];
            } else {
                Object.keys(this.channels).forEach(ch => {
                    this.channels[ch] = [];
                });
            }
        }
    }

    // SensoryInputManager - Audio/video/geolocation/ambient light with FFT (147 lines)
    class SensoryInputManager {
        constructor(eventBus, app) {
            this.eventBus = eventBus;
            this.app = app;
            this.sensors = {
                audio: { active: false, data: null },
                video: { active: false, data: null },
                geolocation: { active: false, data: null },
                ambientLight: { active: false, data: null }
            };
            this.audioContext = null;
            this.analyser = null;
            this.fftData = null;
        }

        async initAudio() {
            if (this.sensors.audio.active) return;

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = this.audioContext.createMediaStreamSource(stream);

                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;

                source.connect(this.analyser);

                this.fftData = new Uint8Array(this.analyser.frequencyBinCount);
                this.sensors.audio.active = true;

                this.eventBus.emit('sensor:audio:initialized', {
                    fftSize: this.analyser.fftSize,
                    sampleRate: this.audioContext.sampleRate
                });
            } catch (err) {
                console.error('Audio initialization failed:', err);
                this.eventBus.emit('sensor:audio:error', { error: err.message });
            }
        }

        async initVideo() {
            if (this.sensors.video.active) return;

            try {
                const videoElement = document.getElementById('video-feed');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 }
                });
                videoElement.srcObject = stream;
                await videoElement.play();

                this.sensors.video.active = true;
                this.sensors.video.element = videoElement;

                this.eventBus.emit('sensor:video:initialized', {
                    width: videoElement.videoWidth,
                    height: videoElement.videoHeight
                });
            } catch (err) {
                console.error('Video initialization failed:', err);
                this.eventBus.emit('sensor:video:error', { error: err.message });
            }
        }

        async initGeolocation() {
            if (!navigator.geolocation) {
                console.warn('Geolocation not supported');
                return;
            }

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    this.sensors.geolocation.active = true;
                    this.sensors.geolocation.data = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        altitude: position.coords.altitude,
                        accuracy: position.coords.accuracy
                    };
                    this.eventBus.emit('sensor:geolocation:update', this.sensors.geolocation.data);
                },
                (err) => {
                    console.error('Geolocation error:', err);
                    this.eventBus.emit('sensor:geolocation:error', { error: err.message });
                }
            );
        }

        initAmbientLight() {
            if (!('AmbientLightSensor' in window)) {
                console.warn('Ambient Light Sensor not supported');
                return;
            }

            try {
                const sensor = new AmbientLightSensor();
                sensor.addEventListener('reading', () => {
                    this.sensors.ambientLight.active = true;
                    this.sensors.ambientLight.data = {
                        illuminance: sensor.illuminance,
                        timestamp: Date.now()
                    };
                    this.eventBus.emit('sensor:ambientLight:update', this.sensors.ambientLight.data);
                });
                sensor.start();
            } catch (err) {
                console.error('Ambient light sensor error:', err);
            }
        }

        async initializeAll() {
            await this.initAudio();
            await this.initVideo();
            await this.initGeolocation();
            this.initAmbientLight();
        }

        update() {
            // Update audio FFT analysis
            if (this.sensors.audio.active && this.analyser) {
                this.analyser.getByteFrequencyData(this.fftData);

                const binCount = this.analyser.frequencyBinCount;
                const bassEnd = Math.floor(binCount * 0.1);
                const midEnd = Math.floor(binCount * 0.4);

                let bass = 0, mids = 0, treble = 0;
                for (let i = 0; i < binCount; i++) {
                    const normalized = this.fftData[i] / 255;
                    if (i < bassEnd) bass += normalized;
                    else if (i < midEnd) mids += normalized;
                    else treble += normalized;
                }

                this.sensors.audio.data = {
                    bass: bass / bassEnd,
                    mids: mids / (midEnd - bassEnd),
                    treble: treble / (binCount - midEnd),
                    fft: Array.from(this.fftData),
                    timestamp: Date.now()
                };

                this.eventBus.emit('sensor:audio:update', this.sensors.audio.data);
            }
        }

        getData(sensorType = null) {
            if (sensorType) {
                return this.sensors[sensorType]?.data || null;
            }
            return Object.keys(this.sensors).reduce((acc, key) => {
                acc[key] = this.sensors[key].data;
                return acc;
            }, {});
        }
    }

    // ExternalDataManager - NASA APIs with rate limiting (117 lines)
    class ExternalDataManager {
        constructor(eventBus) {
            this.eventBus = eventBus;
            this.apiKey = 'DEMO_KEY'; // Use DEMO_KEY for testing
            this.cache = new Map();
            this.rateLimits = new Map();
            this.lastFetch = new Map();
        }

        async fetchWithRateLimit(url, endpoint, minInterval = 1000) {
            const now = Date.now();
            const lastTime = this.lastFetch.get(endpoint) || 0;

            if (now - lastTime < minInterval) {
                const cached = this.cache.get(endpoint);
                if (cached) return cached;
                await new Promise(resolve => setTimeout(resolve, minInterval - (now - lastTime)));
            }

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                this.cache.set(endpoint, data);
                this.lastFetch.set(endpoint, Date.now());

                this.eventBus.emit(`external:${endpoint}:success`, data);
                return data;
            } catch (err) {
                console.error(`External API error (${endpoint}):`, err);
                this.eventBus.emit(`external:${endpoint}:error`, { error: err.message });
                return null;
            }
        }

        async fetchNasaAPOD() {
            const url = `https://api.nasa.gov/planetary/apod?api_key=${this.apiKey}`;
            return await this.fetchWithRateLimit(url, 'nasa_apod', 3600000); // 1 hour cache
        }

        async fetchNasaDONKI(startDate, endDate) {
            const start = startDate || new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            const end = endDate || new Date().toISOString().split('T')[0];
            const url = `https://api.nasa.gov/DONKI/CME?startDate=${start}&endDate=${end}&api_key=${this.apiKey}`;
            return await this.fetchWithRateLimit(url, 'nasa_donki', 3600000);
        }

        async fetchNasaNEO() {
            const today = new Date().toISOString().split('T')[0];
            const url = `https://api.nasa.gov/neo/rest/v1/feed?start_date=${today}&end_date=${today}&api_key=${this.apiKey}`;
            return await this.fetchWithRateLimit(url, 'nasa_neo', 3600000);
        }

        async fetchUSGSEarthquakes() {
            const url = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_week.geojson';
            return await this.fetchWithRateLimit(url, 'usgs_earthquakes', 300000); // 5 min cache
        }

        async fetchAll() {
            const results = await Promise.allSettled([
                this.fetchNasaAPOD(),
                this.fetchNasaDONKI(),
                this.fetchNasaNEO(),
                this.fetchUSGSEarthquakes()
            ]);

            const data = {
                apod: results[0].status === 'fulfilled' ? results[0].value : null,
                donki: results[1].status === 'fulfilled' ? results[1].value : null,
                neo: results[2].status === 'fulfilled' ? results[2].value : null,
                earthquakes: results[3].status === 'fulfilled' ? results[3].value : null,
                timestamp: Date.now()
            };

            this.eventBus.emit('external:all:fetched', data);
            return data;
        }

        getCache(endpoint = null) {
            if (endpoint) {
                return this.cache.get(endpoint);
            }
            return Object.fromEntries(this.cache);
        }

        clearCache() {
            this.cache.clear();
            this.lastFetch.clear();
        }
    }

    // MachineLearningCore - ml5.js object detection (44 lines)
    class MachineLearningCore {
        constructor(eventBus, app) {
            this.eventBus = eventBus;
            this.app = app;
            this.model = null;
            this.isLoaded = false;
            this.detections = [];
        }

        async initialize() {
            if (!window.ml5) {
                console.warn('ml5.js not loaded');
                return;
            }

            try {
                this.model = await ml5.objectDetector('cocossd');
                this.isLoaded = true;
                this.eventBus.emit('ml:initialized', { model: 'cocossd' });
            } catch (err) {
                console.error('ML model loading failed:', err);
                this.eventBus.emit('ml:error', { error: err.message });
            }
        }

        async detect(videoElement) {
            if (!this.isLoaded || !this.model || !videoElement) return [];

            try {
                const results = await this.model.detect(videoElement);
                this.detections = results;
                this.eventBus.emit('ml:detection', { detections: results, timestamp: Date.now() });
                return results;
            } catch (err) {
                console.error('Detection error:', err);
                return [];
            }
        }

        getDetections() {
            return this.detections;
        }
    }

    // CosmicAwarenessAgent - AI history analysis and decision-making (138 lines)
    class CosmicAwarenessAgent {
        constructor(eventBus, dataLogger) {
            this.eventBus = eventBus;
            this.dataLogger = dataLogger;
            this.state = {
                awareness: 0,
                creativity: 0,
                chaos: 0,
                harmony: 0
            };
            this.memory = [];
            this.maxMemory = 50;
            this.lastDecision = null;
        }

        learn(data) {
            // Analyze sensory inputs and update internal state
            if (data.audio) {
                this.state.chaos += data.audio.mids * 0.01;
                this.state.creativity += data.audio.treble * 0.008;
                this.state.harmony += (1 - data.audio.bass) * 0.005;
            }

            if (data.ml && data.ml.length > 0) {
                this.state.awareness += data.ml.length * 0.02;
            }

            if (data.external) {
                this.state.awareness += 0.01;
            }

            // Decay over time
            Object.keys(this.state).forEach(key => {
                this.state[key] *= 0.99;
                this.state[key] = Math.max(0, Math.min(1, this.state[key]));
            });

            // Store in memory
            this.memory.push({ ...this.state, timestamp: Date.now() });
            if (this.memory.length > this.maxMemory) {
                this.memory.shift();
            }

            this.eventBus.emit('ai:state:update', this.state);
        }

        generateInfluence() {
            // Generate universe parameters based on AI state
            const influence = {
                gravity: 0.5 + (this.state.awareness * 0.3) - (this.state.chaos * 0.2),
                chaos: 0.2 + (this.state.chaos * 0.4),
                energy: 1.0 + (this.state.creativity * 0.5),
                damping: 0.985 - (this.state.chaos * 0.01),
                hue: (this.state.harmony * 0.5) + (this.state.creativity * 0.3),
                timestamp: Date.now()
            };

            this.lastDecision = influence;
            this.eventBus.emit('ai:influence:generated', influence);

            return influence;
        }

        makeDecision(context = {}) {
            // AI decision-making based on context and state
            const decisions = [
                { action: 'expand', weight: this.state.creativity },
                { action: 'contract', weight: this.state.harmony },
                { action: 'chaos', weight: this.state.chaos },
                { action: 'observe', weight: this.state.awareness }
            ];

            // Weighted random selection
            const totalWeight = decisions.reduce((sum, d) => sum + d.weight, 0);
            let random = Math.random() * totalWeight;

            for (const decision of decisions) {
                random -= decision.weight;
                if (random <= 0) {
                    this.eventBus.emit('ai:decision', { action: decision.action, context });
                    return decision.action;
                }
            }

            return 'observe';
        }

        tick(timestamp) {
            // Periodic AI updates
            if (!this.lastTick || timestamp - this.lastTick > 5000) {
                this.lastTick = timestamp;

                // Analyze event history
                const recentEvents = this.eventBus.getHistory(null, 20);
                const eventTypes = recentEvents.reduce((acc, event) => {
                    acc[event.name] = (acc[event.name] || 0) + 1;
                    return acc;
                }, {});

                this.eventBus.emit('ai:analysis', {
                    state: this.state,
                    eventTypes,
                    memorySize: this.memory.length
                });
            }
        }

        getState() {
            return { ...this.state };
        }

        getMemory(limit = 10) {
            return this.memory.slice(-limit);
        }
    }

    // QuantumEventManager - Soul dust particle system with E=h*nu physics (228 lines)
    class QuantumEventManager {
        constructor(eventBus, app, scene, camera) {
            this.eventBus = eventBus;
            this.app = app;
            this.scene = scene;
            this.camera = camera;
            this.particles = null;
            this.particleCount = 5000;
            this.uniforms = null;
        }

        initialize() {
            // Soul dust particle geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(this.particleCount * 3);
            const velocities = new Float32Array(this.particleCount * 3);
            const frequencies = new Float32Array(this.particleCount);
            const phases = new Float32Array(this.particleCount);

            for (let i = 0; i < this.particleCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = 500 + Math.random() * 1500;

                positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);

                velocities[i3 + 0] = (Math.random() - 0.5) * 2;
                velocities[i3 + 1] = (Math.random() - 0.5) * 2;
                velocities[i3 + 2] = (Math.random() - 0.5) * 2;

                // Quantum frequency (E = h*ν)
                frequencies[i] = 400e12 + Math.random() * 350e12; // THz range
                phases[i] = Math.random() * Math.PI * 2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('frequency', new THREE.BufferAttribute(frequencies, 1));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            // Quantum swirl shader
            this.uniforms = {
                time: { value: 0 },
                hPlanck: { value: H_PLANCK },
                phiGolden: { value: PHI_GOLDEN },
                cameraPos: { value: new THREE.Vector3() }
            };

            const vertexShader = `
                attribute float frequency;
                attribute float phase;
                attribute vec3 velocity;

                uniform float time;
                uniform float hPlanck;
                uniform float phiGolden;
                uniform vec3 cameraPos;

                varying vec3 vColor;
                varying float vAlpha;

                vec3 freqToRgb(float freq) {
                    float minFreq = 380e12;
                    float maxFreq = 750e12;
                    float normalized = (freq - minFreq) / (maxFreq - minFreq);

                    vec3 color;
                    if (normalized < 0.25) {
                        float t = normalized / 0.25;
                        color = vec3(1.0, t, 0.0);
                    } else if (normalized < 0.5) {
                        float t = (normalized - 0.25) / 0.25;
                        color = vec3(1.0 - t, 1.0, 0.0);
                    } else if (normalized < 0.75) {
                        float t = (normalized - 0.5) / 0.25;
                        color = vec3(0.0, 1.0, t);
                    } else {
                        float t = (normalized - 0.75) / 0.25;
                        color = vec3(0.0, 1.0 - t, 1.0);
                    }
                    return color;
                }

                void main() {
                    vec3 pos = position;

                    // Quantum swirl (golden ratio spiral)
                    float angle = time * 0.5 + phase;
                    float radius = length(pos.xy);
                    float spiralAngle = angle + radius * phiGolden * 0.001;

                    pos.x = radius * cos(spiralAngle);
                    pos.y = radius * sin(spiralAngle);
                    pos.z += sin(time + phase) * 50.0;

                    vColor = freqToRgb(frequency);

                    float dist = distance(pos, cameraPos);
                    vAlpha = 1.0 - smoothstep(1000.0, 3000.0, dist);

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = 20.0 * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            const fragmentShader = `
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);

                    if (dist > 0.5) discard;

                    float alpha = (1.0 - dist * 2.0) * vAlpha;
                    gl_FragColor = vec4(vColor, alpha);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms: this.uniforms,
                vertexShader,
                fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            this.particles = new THREE.Points(geometry, material);
            this.scene.add(this.particles);

            this.eventBus.emit('quantum:initialized', {
                particleCount: this.particleCount
            });
        }

        update(delta) {
            if (!this.particles) return;

            this.uniforms.time.value += delta;
            this.uniforms.cameraPos.value.copy(this.camera.position);

            // Update particle positions with quantum physics
            const positions = this.particles.geometry.attributes.position.array;
            const velocities = this.particles.geometry.attributes.velocity.array;
            const frequencies = this.particles.geometry.attributes.frequency.array;

            for (let i = 0; i < this.particleCount; i++) {
                const i3 = i * 3;

                // E = h*ν energy calculation
                const energy = H_PLANCK * frequencies[i];
                const energyFactor = energy / (H_PLANCK * 500e12); // Normalized

                // Apply quantum momentum
                velocities[i3 + 0] += (Math.random() - 0.5) * energyFactor * 0.1;
                velocities[i3 + 1] += (Math.random() - 0.5) * energyFactor * 0.1;
                velocities[i3 + 2] += (Math.random() - 0.5) * energyFactor * 0.1;

                // Damping
                velocities[i3 + 0] *= 0.98;
                velocities[i3 + 1] *= 0.98;
                velocities[i3 + 2] *= 0.98;

                // Update positions
                positions[i3 + 0] += velocities[i3 + 0];
                positions[i3 + 1] += velocities[i3 + 1];
                positions[i3 + 2] += velocities[i3 + 2];

                // Boundary wrap
                const pos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                if (pos.length() > 2000) {
                    pos.normalize().multiplyScalar(500);
                    positions[i3 + 0] = pos.x;
                    positions[i3 + 1] = pos.y;
                    positions[i3 + 2] = pos.z;
                }
            }

            this.particles.geometry.attributes.position.needsUpdate = true;
            this.particles.geometry.attributes.velocity.needsUpdate = true;

            this.eventBus.emit('quantum:update', {
                time: this.uniforms.time.value,
                particleCount: this.particleCount
            });
        }

        setIntensity(intensity) {
            if (this.particles) {
                this.particles.material.opacity = intensity;
            }
        }

        dispose() {
            if (this.particles) {
                this.scene.remove(this.particles);
                this.particles.geometry.dispose();
                this.particles.material.dispose();
                this.particles = null;
            }
        }
    }

    // ProceduralGenerationEngine - Stars, planets, black holes with shaders (342 lines)
    class ProceduralGenerationEngine {
        constructor(scene, eventBus) {
            this.scene = scene;
            this.eventBus = eventBus;
            this.celestialObjects = [];
            this.starField = null;
        }

        generateUniverse(influence = {}) {
            this.clearUniverse();

            const gravity = influence.gravity || 0.55;
            const chaos = influence.chaos || 0.25;
            const energy = influence.energy || 1.2;
            const hue = influence.hue || 0.62;

            // Generate stars with corona
            const starCount = Math.floor(5 + chaos * 10);
            for (let i = 0; i < starCount; i++) {
                this.createStar(hue, energy);
            }

            // Generate planets with atmospheres
            const planetCount = Math.floor(8 + chaos * 12);
            for (let i = 0; i < planetCount; i++) {
                this.createPlanet(hue, gravity);
            }

            // Generate black holes
            if (Math.random() < gravity * 0.5) {
                this.createBlackHole(gravity, energy);
            }

            this.eventBus.emit('procedural:universe:generated', {
                stars: starCount,
                planets: planetCount,
                gravity,
                chaos,
                energy
            });
        }

        createStar(hue, energy) {
            const radius = 100 + Math.random() * 200;
            const geometry = new THREE.SphereGeometry(radius, 32, 32);

            // Corona shader
            const uniforms = {
                time: { value: 0 },
                color: { value: new THREE.Color().setHSL(hue, 0.9, 0.6) },
                energy: { value: energy }
            };

            const vertexShader = `
                varying vec3 vNormal;
                varying vec3 vPosition;
                uniform float time;

                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;

                    vec3 pos = position;
                    float displacement = sin(position.x * 0.05 + time) *
                                       cos(position.y * 0.05 + time) * 5.0;
                    pos += normal * displacement;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `;

            const fragmentShader = `
                uniform vec3 color;
                uniform float energy;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    vec3 glow = color * intensity * energy;
                    gl_FragColor = vec4(glow + color * 0.3, 1.0);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms,
                vertexShader,
                fragmentShader
            });

            const star = new THREE.Mesh(geometry, material);
            star.position.set(
                (Math.random() - 0.5) * 4000,
                (Math.random() - 0.5) * 4000,
                (Math.random() - 0.5) * 4000
            );

            this.scene.add(star);
            this.celestialObjects.push({ type: 'star', mesh: star, uniforms });

            // Add point light
            const light = new THREE.PointLight(uniforms.color.value, energy * 1000, 2000);
            light.position.copy(star.position);
            this.scene.add(light);
            this.celestialObjects.push({ type: 'light', mesh: light });
        }

        createPlanet(hue, gravity) {
            const radius = 30 + Math.random() * 80;
            const geometry = new THREE.SphereGeometry(radius, 32, 32);

            // Rayleigh scattering atmosphere shader
            const uniforms = {
                planetColor: { value: new THREE.Color().setHSL((hue + Math.random() * 0.3) % 1, 0.7, 0.5) },
                atmosphereColor: { value: new THREE.Color().setHSL((hue + 0.1) % 1, 0.8, 0.6) },
                time: { value: 0 }
            };

            const vertexShader = `
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform vec3 planetColor;
                uniform vec3 atmosphereColor;
                uniform float time;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    // Lambertian diffuse
                    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                    float diffuse = max(dot(vNormal, lightDir), 0.0);

                    // Rayleigh scattering effect
                    float atmosphere = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.5);
                    vec3 atmosphereGlow = atmosphereColor * atmosphere * 0.5;

                    vec3 finalColor = planetColor * diffuse + atmosphereGlow;
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms,
                vertexShader,
                fragmentShader
            });

            const planet = new THREE.Mesh(geometry, material);
            planet.position.set(
                (Math.random() - 0.5) * 3000,
                (Math.random() - 0.5) * 3000,
                (Math.random() - 0.5) * 3000
            );

            this.scene.add(planet);
            this.celestialObjects.push({ type: 'planet', mesh: planet, uniforms });
        }

        createBlackHole(gravity, energy) {
            const radius = 150 + gravity * 100;

            // Black hole sphere (event horizon)
            const sphereGeo = new THREE.SphereGeometry(radius, 32, 32);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const blackHole = new THREE.Mesh(sphereGeo, sphereMat);

            // Accretion disk shader
            const diskGeo = new THREE.RingGeometry(radius * 1.5, radius * 3, 64);
            const uniforms = {
                time: { value: 0 },
                innerRadius: { value: radius * 1.5 },
                outerRadius: { value: radius * 3 },
                color1: { value: new THREE.Color(0xff6600) },
                color2: { value: new THREE.Color(0xffaa00) }
            };

            const vertexShader = `
                varying vec2 vUv;
                varying vec3 vPosition;

                void main() {
                    vUv = uv;
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float time;
                uniform float innerRadius;
                uniform float outerRadius;
                uniform vec3 color1;
                uniform vec3 color2;
                varying vec2 vUv;
                varying vec3 vPosition;

                void main() {
                    float dist = length(vPosition.xy);
                    float normalizedDist = (dist - innerRadius) / (outerRadius - innerRadius);

                    // Spiral pattern
                    float angle = atan(vPosition.y, vPosition.x);
                    float spiral = sin(angle * 8.0 + time * 2.0 - normalizedDist * 10.0);

                    // Color gradient
                    vec3 color = mix(color1, color2, normalizedDist);
                    color *= (0.7 + spiral * 0.3);

                    float alpha = 1.0 - smoothstep(0.0, 1.0, normalizedDist);
                    gl_FragColor = vec4(color, alpha * 0.8);
                }
            `;

            const diskMat = new THREE.ShaderMaterial({
                uniforms,
                vertexShader,
                fragmentShader,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            const accretionDisk = new THREE.Mesh(diskGeo, diskMat);
            accretionDisk.rotation.x = Math.PI / 2;

            const blackHoleGroup = new THREE.Group();
            blackHoleGroup.add(blackHole);
            blackHoleGroup.add(accretionDisk);
            blackHoleGroup.position.set(
                (Math.random() - 0.5) * 2000,
                (Math.random() - 0.5) * 2000,
                (Math.random() - 0.5) * 2000
            );

            this.scene.add(blackHoleGroup);
            this.celestialObjects.push({
                type: 'blackhole',
                mesh: blackHoleGroup,
                uniforms,
                disk: accretionDisk
            });
        }

        update(delta) {
            this.celestialObjects.forEach(obj => {
                if (obj.uniforms && obj.uniforms.time) {
                    obj.uniforms.time.value += delta;
                }

                // Rotate planets and stars
                if (obj.type === 'planet' || obj.type === 'star') {
                    obj.mesh.rotation.y += delta * 0.1;
                }

                // Rotate black hole accretion disk
                if (obj.type === 'blackhole' && obj.disk) {
                    obj.disk.rotation.z += delta * 0.5;
                }
            });
        }

        clearUniverse() {
            this.celestialObjects.forEach(obj => {
                this.scene.remove(obj.mesh);
                if (obj.mesh.geometry) obj.mesh.geometry.dispose();
                if (obj.mesh.material) obj.mesh.material.dispose();
            });
            this.celestialObjects = [];
        }

        getCelestialObjects() {
            return this.celestialObjects;
        }
    }

    // --- Sub-system classes ---
    class AudioManager {
        constructor(toggleElement, statusElement) {
            this.toggle = toggleElement;
            this.status = statusElement;
            this.isActive = false;
            this.bass = 0; this.mids = 0; this.treble = 0;
            
            this.toggle.addEventListener('change', () => {
                if (this.toggle.checked) this.enable();
                else this.disable();
            });
        }

        async enable() {
            if (this.isActive || !navigator.mediaDevices) return;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                const source = this.ctx.createMediaStreamSource(stream);
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 512;
                source.connect(this.analyser);
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.isActive = true;
                this.status.textContent = "Mic: Active";
            } catch (err) {
                console.error("Microphone access denied:", err);
                this.status.textContent = "Mic: Error";
                this.toggle.checked = false;
            }
        }

        disable() {
            if (!this.isActive || !this.ctx) return;
            this.ctx.close();
            this.isActive = false;
            this.status.textContent = "Mic: Inactive";
        }

        getAnalysis() {
            if (!this.isActive) return { bass: 0, mids: 0, treble: 0 };
            
            this.analyser.getByteFrequencyData(this.dataArray);
            const binCount = this.analyser.frequencyBinCount;
            
            const bassEnd = Math.floor(binCount * 0.1);
            const midEnd = Math.floor(binCount * 0.4);
            
            let bassSum = 0, midSum = 0, trebleSum = 0;
            for (let i = 0; i < binCount; i++) {
                const val = Math.pow(this.dataArray[i] / 255, 2);
                if (i < bassEnd) bassSum += val;
                else if (i < midEnd) midSum += val;
                else trebleSum += val;
            }
            
            this.bass = lerp(this.bass, Math.min(1, bassSum / (bassEnd * 0.5)), 0.1);
            this.mids = lerp(this.mids, Math.min(1, midSum / ((midEnd - bassEnd) * 0.5)), 0.1);
            this.treble = lerp(this.treble, Math.min(1, trebleSum / ((binCount - midEnd) * 0.5)), 0.1);
            
            return { bass: this.bass, mids: this.mids, treble: this.treble };
        }
    }

    class Singularity {
        constructor(scene) {
            const geo = new THREE.IcosahedronGeometry(1, 3);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
            this.mesh = new THREE.Mesh(geo, mat);
            scene.add(this.mesh);
            this.baseScale = 150;
        }
        
        update(params, isMouseDown) {
            const targetScale = this.baseScale + params.ugrav * 20;
            const targetColor = new THREE.Color().setHSL(params.omega, 0.9, 0.7);
            this.mesh.scale.setScalar(lerp(this.mesh.scale.x, targetScale, 0.1));
            this.mesh.material.color.lerp(targetColor, 0.1);
            this.mesh.rotation.x += 0.001;
            this.mesh.rotation.y += 0.002;
            if (isMouseDown) this.mesh.scale.multiplyScalar(1.05);
        }
        
        reset() {
            this.mesh.scale.setScalar(this.baseScale);
            this.mesh.material.color.set(0xffffff);
        }

        show(visible = true) { this.mesh.visible = visible; }
    }

    class CosmosParticleSystem {
        constructor(scene) {
            this.scene = scene;
            this.count = 100000;
            this.velocities = null;
            this.points = null;
        }

        init(params) {
            if (this.points) {
                this.scene.remove(this.points);
                this.points.geometry.dispose();
                this.points.material.dispose();
            }

            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(this.count * 3);
            this.velocities = new Float32Array(this.count * 3);

            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = 2000 + Math.random() * 2000;
                positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 15, color: new THREE.Color().setHSL(params.omega, 0.8, 0.7),
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            
            this.points = new THREE.Points(geo, mat);
            this.scene.add(this.points);
        }

        update(dt, params, mouse, isMouseDown) {
            if (!this.points || !window.genesisApp) return;
            this.points.material.size = params.ec * 15;
            this.points.material.color.setHSL(params.omega, 0.8, 0.7);

            const positions = this.points.geometry.attributes.position.array;
            const mouseForce = isMouseDown ? 3000 : 0;
            const G_local = params.ugrav * 1000;
            
            const mouseWorld = new THREE.Vector3(mouse.x, mouse.y, 0.5)
                .unproject(window.genesisApp.camera).sub(window.genesisApp.camera.position).normalize();
            const distance = -window.genesisApp.camera.position.z / mouseWorld.z;
            const mouse3D = new THREE.Vector3().copy(window.genesisApp.camera.position).add(mouseWorld.multiplyScalar(distance));
            
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const pos = new THREE.Vector3(positions[i3], positions[i3+1], positions[i3+2]);
                const vel = new THREE.Vector3(this.velocities[i3], this.velocities[i3+1], this.velocities[i3+2]);
                
                const toCenter = new THREE.Vector3().copy(pos).multiplyScalar(-1);
                const distSq = pos.lengthSq();
                const gravity = toCenter.normalize().multiplyScalar(G_local / (distSq + 10000));
                
                const toMouse = new THREE.Vector3().subVectors(mouse3D, pos);
                const distMouseSq = toMouse.lengthSq();
                const creatorPull = toMouse.normalize().multiplyScalar(mouseForce / (distMouseSq + 100000));
                
                const chaos = new THREE.Vector3(
                    (Math.random() - 0.5) * params.lambda * 50,
                    (Math.random() - 0.5) * params.lambda * 50,
                    (Math.random() - 0.5) * params.lambda * 50
                );

                vel.add(gravity).add(creatorPull).add(chaos);
                vel.multiplyScalar(params.li);
                pos.add(vel.clone().multiplyScalar(dt));
                
                positions[i3] = pos.x; positions[i3+1] = pos.y; positions[i3+2] = pos.z;
                this.velocities[i3] = vel.x; this.velocities[i3+1] = vel.y; this.velocities[i3+2] = vel.z;
            }
            this.points.geometry.attributes.position.needsUpdate = true;
        }

        show(visible = true) { if (this.points) this.points.visible = visible; }
    }
        
    class AILifeParticleSystem extends CosmosParticleSystem {
        constructor(scene) {
            super(scene);
            this.count = 2000;
            this.isFormingCrystal = false;
        }

        init() {
            if (this.points) {
                this.scene.remove(this.points);
                this.points.geometry.dispose();
                this.points.material.dispose();
            }

            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(this.count * 3);
            this.velocities = new Float32Array(this.count * 3);
            
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = 1000 + Math.random() * 1000;
                positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 25, color: 0x00ffaa,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            
            this.points = new THREE.Points(geo, mat);
            this.scene.add(this.points);
        }
        
        formNeuralCrystal() {
            this.isFormingCrystal = true;
            const crystalGeo = new THREE.IcosahedronGeometry(1000, 5);
            this.crystalTargetPositions = crystalGeo.attributes.position.array;
        }

        update(dt, audio, mouse, isMouseDown, isFormingCrystal = false) {
            if (!this.points || !window.genesisApp) return;
            
            this.isFormingCrystal = isFormingCrystal;
            const positions = this.points.geometry.attributes.position.array;
            const attraction = audio.bass * 200;
            const chaos = audio.mids * 500;
            this.points.material.size = 25 + audio.treble * 50;

            const mouseWorld = new THREE.Vector3(mouse.x, mouse.y, 0.5)
                .unproject(window.genesisApp.camera).sub(window.genesisApp.camera.position).normalize();
            const distance = -window.genesisApp.camera.position.z / mouseWorld.z;
            const mouse3D = new THREE.Vector3().copy(window.genesisApp.camera.position).add(mouseWorld.multiplyScalar(distance));
            const mouseRepel = isMouseDown ? 5000 : 0;
            
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const pos = new THREE.Vector3(positions[i3], positions[i3+1], positions[i3+2]);
                const vel = new THREE.Vector3(this.velocities[i3], this.velocities[i3+1], this.velocities[i3+2]);

                if (this.isFormingCrystal && this.crystalTargetPositions) {
                    const targetIdx = (i * 3) % this.crystalTargetPositions.length;
                    const targetPos = new THREE.Vector3(
                        this.crystalTargetPositions[targetIdx],
                        this.crystalTargetPositions[targetIdx+1],
                        this.crystalTargetPositions[targetIdx+2]
                    );
                    pos.lerp(targetPos, 0.05);
                } else {
                    const fromMouse = new THREE.Vector3().subVectors(pos, mouse3D);
                    const distMouseSq = fromMouse.lengthSq();
                    const creatorRepel = fromMouse.normalize().multiplyScalar(mouseRepel / (distMouseSq + 100000));
                    vel.add(creatorRepel);
                }
                
                vel.add(new THREE.Vector3((Math.random()-0.5)*chaos, (Math.random()-0.5)*chaos, (Math.random()-0.5)*chaos));
                vel.multiplyScalar(0.98);
                pos.add(vel.clone().multiplyScalar(dt));
                
                positions[i3] = pos.x; positions[i3+1] = pos.y; positions[i3+2] = pos.z;
                this.velocities[i3] = vel.x; this.velocities[i3+1] = vel.y; this.velocities[i3+2] = vel.z;
            }
            this.points.geometry.attributes.position.needsUpdate = true;
        }

        getStats() {
            if(!this.points) return { population: 0, formations: 0, energy: 'Low' };
            let energyLevel = 'Low';
            if (this.points.material.size > 50) energyLevel = 'High';
            else if (this.points.material.size > 35) energyLevel = 'Medium';
            return { population: this.count, formations: 0, energy: energyLevel }; // Simplified for now
        }
    }

    class QuantumAIModel {
        constructor() {
            this.weights = { chaos: 0, creative: 0, calm: 0 };
        }
        learn(data) {
            this.weights.chaos += data.audio.mids * 0.005;
            this.weights.creative += data.audio.treble * 0.003;
            this.weights.calm += (1 - (data.audio.bass + data.audio.mids)) * 0.002;
        }
        update(dt) {
            this.weights.chaos = Math.max(0, this.weights.chaos - dt * 0.05);
            this.weights.creative = Math.max(0, this.weights.creative - dt * 0.03);
            this.weights.calm = Math.max(0, this.weights.calm - dt * 0.02);
            
            let dominantState = 'Observing';
            if (this.weights.chaos > this.weights.creative && this.weights.chaos > this.weights.calm) {
                dominantState = 'Chaotic';
            } else if (this.weights.creative > this.weights.calm) {
                dominantState = 'Creative';
            } else if(this.weights.calm > 0.1) {
                dominantState = 'Calm';
            }
            return { dominantState, interaction: 'None' };
        }
    }

    class SolarSystemManager {
        constructor(scene) {
            this.scene = scene;
            this.solarSystemGroup = new THREE.Group();
            this.scene.add(this.solarSystemGroup);
            this.celestialBodies = [];
        }

        init() {
            this.solarSystemGroup.clear();
            this.celestialBodies = [];

            const planetData = [
                { name: 'Mercury', radius: 0.38, distance: 1200, color: '#9a9a9a', mass: 0.055 },
                { name: 'Venus', radius: 0.95, distance: 2000, color: '#d8b48d', mass: 0.815 },
                { name: 'Earth', radius: 1, distance: 2800, color: '#4d92d0', mass: 1 },
                { name: 'Mars', radius: 0.53, distance: 3800, color: '#c1440e', mass: 0.107 },
                { name: 'Jupiter', radius: 11.2, distance: 6500, color: '#c8a377', mass: 317.8 },
                { name: 'Saturn', radius: 9.45, distance: 9500, color: '#e3d5b8', mass: 95.2, hasRings: true },
                { name: 'Uranus', radius: 4.01, distance: 13000, color: '#aadaf0', mass: 14.5 },
                { name: 'Neptune', radius: 3.88, distance: 16000, color: '#3f54ba', mass: 17.1 }
            ];

            const sunMass = 333000;
            const sunGeo = new THREE.SphereGeometry(700, 64, 64);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd88, map: this.createSunTexture() });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            const sunLight = new THREE.PointLight(0xffddaa, 4500000, 0, 1.5);
            this.solarSystemGroup.add(sun, sunLight);
            this.sun = { mesh: sun, data: { name: 'Sun', mass: sunMass, radius: 700 } };
            this.celestialBodies.push(this.sun);
            
            planetData.forEach(data => {
                const planetGeo = new THREE.SphereGeometry(data.radius * 40, 32, 32);
                const texture = this.createPlanetTexture(data);
                const planetMat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });
                const planet = new THREE.Mesh(planetGeo, planetMat);
                
                const position = new THREE.Vector3(data.distance, 0, 0);
                planet.position.copy(position);
                const orbitalVelocityMagnitude = Math.sqrt(G * sunMass / data.distance);
                const velocity = new THREE.Vector3(0, 0, -orbitalVelocityMagnitude);

                const planetObject = { mesh: planet, data: { ...data, radius: data.radius * 40 }, velocity: velocity };

                if(data.hasRings) {
                    const ringGeo = new THREE.RingGeometry(data.radius * 50, data.radius * 80, 64);
                    const ringMat = new THREE.MeshBasicMaterial({ map: this.createRingTexture(), side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
                    const rings = new THREE.Mesh(ringGeo, ringMat);
                    rings.rotation.x = Math.PI * 0.45;
                    planet.add(rings);
                }
                
                const orbitGeo = new THREE.BufferGeometry().setFromPoints(
                    new THREE.Path().absellipse(0, 0, data.distance, data.distance, 0, Math.PI * 2, false).getPoints(128));
                orbitGeo.rotateX(Math.PI / 2);
                const orbit = new THREE.Line(orbitGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 }));

                this.solarSystemGroup.add(planet, orbit);
                this.celestialBodies.push(planetObject);
            });

            this.hide();
        }

        createSunTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffdd88'; ctx.fillRect(0,0,128,128);
            for(let i=0; i < 2000; i++) {
                ctx.fillStyle = `rgba(255, ${Math.floor(Math.random() * 100 + 100)}, 0, ${Math.random() * 0.2})`;
                ctx.beginPath();
                ctx.arc(Math.random() * 128, Math.random() * 128, Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }
        
        createPlanetTexture(data) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = data.color;
            ctx.fillRect(0, 0, 256, 128);
            for (let i = 0; i < 500; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * 256, Math.random() * 128, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            if (data.name === 'Earth') {
                ctx.fillStyle = '#679436';
                for(let i=0; i<15; i++) ctx.fillRect(Math.random()*256, Math.random()*128, Math.random() * 40 + 10, Math.random() * 20 + 5);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                for(let i=0; i<20; i++) ctx.fillRect(Math.random()*256, Math.random()*128, Math.random() * 80 + 20, 2);
            } else if (data.name === 'Jupiter' || data.name === 'Saturn') {
                for(let y=0; y < 128; y += (Math.random() * 10 + 5)) {
                    ctx.fillStyle = (Math.random() > 0.5) ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.1)';
                    ctx.fillRect(0, y, 256, Math.random() * 10 + 2);
                }
            }
            return new THREE.CanvasTexture(canvas);
        }
        
        createRingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 2;
            const ctx = canvas.getContext('2d');
            for (let i = 0; i < 256; i++) {
                const alpha = Math.random() * 0.4 + 0.1;
                ctx.fillStyle = `rgba(200, 180, 150, ${alpha})`;
                ctx.fillRect(i, 0, 1, 2);
            }
            return new THREE.CanvasTexture(canvas);
        }

        update(dt) {
            if (!this.solarSystemGroup.visible) return;
            const timeStep = dt * 20;
            this.celestialBodies.forEach(body => {
                if (body.data.name === 'Sun') {
                    body.mesh.rotation.y += dt * 0.01;
                    return;
                }
                const force = new THREE.Vector3();
                const toSun = new THREE.Vector3().subVectors(this.sun.mesh.position, body.mesh.position);
                const distanceSq = toSun.lengthSq();
                const forceMagnitude = G * (this.sun.data.mass * body.data.mass) / distanceSq;
                force.copy(toSun).normalize().multiplyScalar(forceMagnitude);
                const acceleration = force.divideScalar(body.data.mass);
                body.velocity.add(acceleration.multiplyScalar(timeStep));
                body.mesh.position.add(body.velocity.clone().multiplyScalar(timeStep));
                body.mesh.rotation.y += dt * 0.05;
            });
        }
        
        getCelestialBodies() { return this.celestialBodies; }
        show(visible = true) { this.solarSystemGroup.visible = visible; }
        hide() { this.show(false); }
    }

    class SpaceshipController {
        constructor(scene) {
            this.scene = scene;
            this.ship = this.buildShip();
            this.scene.add(this.ship);
            this.velocity = new THREE.Vector3();
            this.acceleration = new THREE.Vector3();
            this.rotationVelocity = new THREE.Vector2();
            this.keys = {};
            this.mouse = {x: 0, y: 0};
            this.strongestGravSource = null;
        }

        buildShip() {
            const shipGroup = new THREE.Group();
            const mainMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.3 });
            const bodyGeo = new THREE.CapsuleGeometry(1, 4, 4, 12);
            const body = new THREE.Mesh(bodyGeo, mainMat);
            body.rotation.x = Math.PI / 2;
            shipGroup.add(body);
            shipGroup.scale.setScalar(50);
            return shipGroup;
        }
        
        reset() {
            this.ship.position.set(3000, 1000, 3000);
            this.ship.rotation.set(0, 0, 0);
            this.velocity.set(0, 0, 0);
        }

        update(dt, celestialBodies) {
            const totalForce = new THREE.Vector3();
            let strongestGrav = { force: 0, body: null, distance: Infinity };
            
            celestialBodies.forEach(body => {
                const toBody = new THREE.Vector3().subVectors(body.mesh.position, this.ship.position);
                const distanceSq = toBody.lengthSq();
                if (distanceSq < 1) return;
                const forceMag = G * (body.data.mass * 500) / distanceSq; // Increased ship mass for more pull
                totalForce.add(toBody.normalize().multiplyScalar(forceMag));
                if(forceMag > strongestGrav.force) {
                    strongestGrav = { force: forceMag, body: body, distance: Math.sqrt(distanceSq) };
                }
            });
            this.strongestGravSource = strongestGrav;
            
            const thrust = this.keys['KeyW'] ? 1500 : (this.keys['KeyS'] ? -500 : 0);
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.ship.quaternion);
            totalForce.add(forward.multiplyScalar(thrust));
            
            const pitchSpeed = -this.mouse.y * 2.0;
            const yawSpeed = -this.mouse.x * 2.0;
            const rollSpeed = (this.keys['KeyQ'] ? 2.5 : 0) - (this.keys['KeyE'] ? 2.5 : 0);
            this.rotationVelocity.x = lerp(this.rotationVelocity.x, pitchSpeed, dt * 5);
            this.rotationVelocity.y = lerp(this.rotationVelocity.y, yawSpeed, dt * 5);
            this.ship.rotateOnAxis(new THREE.Vector3(1, 0, 0), this.rotationVelocity.x * dt);
            this.ship.rotateOnAxis(new THREE.Vector3(0, 1, 0), this.rotationVelocity.y * dt);
            this.ship.rotateOnAxis(new THREE.Vector3(0, 0, 1), rollSpeed * dt);
            
            this.acceleration = totalForce.divideScalar(50); // ship mass
            this.velocity.add(this.acceleration.multiplyScalar(dt));
            this.velocity.multiplyScalar(0.995);
            this.ship.position.add(this.velocity.clone().multiplyScalar(dt));
        }
        
        updateCamera(camera) {
            const offset = new THREE.Vector3(0, 300, 1000);
            offset.applyQuaternion(this.ship.quaternion);
            const targetPos = new THREE.Vector3().copy(this.ship.position).add(offset);
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(this.ship.position);
        }
        
        getState() {
            let gravData = this.strongestGravSource;
            let state = {
                velocity: this.velocity.length() * 10,
                gravSource: null,
                altitude: 0
            };
            if (gravData && gravData.body) {
                state.gravSource = gravData.body.data;
                state.altitude = gravData.distance - (gravData.body.data.radius);
            }
            return state;
        }
        
        handleMouseMove(e) {
             if (!this.ship.visible) return;
             // Using movementX/Y for direct control response in pointer lock
             this.mouse.x = e.movementX / window.innerWidth;
             this.mouse.y = e.movementY / window.innerHeight;
        }

        show(visible = true) { this.ship.visible = visible; }
    }

    class Particlizer {
        constructor(scene) {
            this.scene = scene;
            this.mesh = null;
            this.particles = [];
            this.sourceType = 'none';
        }

        particlize(source, type = 'file') {
            this.destroy();
            if (source instanceof File) {
                this.fromImage(source);
            } else if (type === 'liveVideo') {
                 this.fromLiveVideo(source);
            }
        }
        
        fromImage(file) {
            const reader = new FileReader();
            reader.onload = e => { 
                const img = new Image(); 
                img.onload = () => this.processImageData(img); 
                img.src = e.target.result; 
            };
            reader.readAsDataURL(file);
        }

        fromLiveVideo(videoElement) {
            this.sourceType = 'liveVideo';
            this.videoElement = videoElement;
            this.processImageData(this.videoElement);
        }

        processImageData(source) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const MAX_DIM = 128;
            const sourceWidth = source.videoWidth || source.width, sourceHeight = source.videoHeight || source.height;
            const scale = Math.min(MAX_DIM / sourceWidth, MAX_DIM / sourceHeight);
            canvas.width = sourceWidth * scale; canvas.height = sourceHeight * scale;
            if(canvas.width === 0 || canvas.height === 0) return;

            ctx.drawImage(source, 0, 0, canvas.width, canvas.height);
            const { data, width, height } = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const positions = [], colors = []; this.particles = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    if (data[i+3] > 128) {
                        const pos = new THREE.Vector3(x - width/2, -y + height/2, 0).multiplyScalar(10);
                        positions.push(pos.x, pos.y, pos.z);
                        colors.push(data[i]/255, data[i+1]/255, data[i+2]/255);
                        this.particles.push({ pos, vel: new THREE.Vector3() });
                    }
                }
            }
            if (positions.length === 0) return;
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(positions), 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(colors), 3));
            this.mesh = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 10, vertexColors: true, sizeAttenuation: true, blending:THREE.AdditiveBlending, depthWrite: false }));
            this.scene.add(this.mesh);
        }

        update(delta) {
            if(!this.mesh || !this.mesh.visible) return;
            // update logic can be added here
        }

        destroy() {
            if(this.mesh) {
                if(this.mesh.parent) this.mesh.parent.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                this.mesh = null; this.particles = [];
            }
        }
    }

    // --- MAIN APPLICATION CLASS ---
    class Application {
        constructor() {
            this.initProperties();
            this.initDOM();
            this.initEngine();
            this.bindUI();
        }

        initProperties() {
            this.isRunning = false;
            this.clock = new THREE.Clock();
            this.mouse = new THREE.Vector2(-1, -1);
            this.isMouseDown = false;
            this.directivePrimeActive = false;
            this.directiveState = 'idle';
            this.directiveTimer = 0;
            this.currentView = 'galaxy';

            this.physicsParams = {
                ugrav: 0.55, lambda: 0.25, ec: 1.2,
                li: 0.985, omega: 0.62,
            };
        }

        initDOM() {
            this.ui = {
                blocker: $('blocker'),
                initialScreen: $('initial-screen'),
                finalMessage: $('final-message'),
                startButton: $('start-button'),
                anewButton: $('btn-anew'),
                directiveButton: $('btn-directive-prime'),
                regenerateButton: $('regenerate-button'),
                audioToggle: $('toggle-audio'),
                audioStatus: $('audio-status'),
                mainUI: $('main-ui'),
                hudPanel: $('hud-panel'),
                tabs: document.querySelectorAll(".tab-button"),
                tabContents: document.querySelectorAll(".tab-content"),
                viewModeSelect: $("view-mode-select"),
                actionText: $("action-text"),
                
                hud: {
                    influence: $('hud-influence'), gravity: $('hud-gravity'),
                    chaos: $('hud-chaos'), energy: $('hud-energy'),
                    lifePop: $('hud-life-pop'), lifeForms: $('hud-life-forms'),
                    lifeEnergy: $('hud-life-energy'), shipVel: $('hud-ship-vel'),
                    shipAlt: $('hud-ship-alt'), shipGrav: $('hud-ship-grav'),
                    aiState: $('hud-ai-state'), aiInteraction: $('hud-ai-interaction'),
                },
                
                galaxyHUD: $('galaxy-hud'),
                shipHUD: $('ship-hud'),
                aiHUD: $('ai-hud'),
            };
        }

        initEngine() {
            // Core Three.js setup
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 150000);
            this.camera.position.set(0, 0, 3500);

            this.renderer = new THREE.WebGLRenderer({
                canvas: $('main-canvas'),
                antialias: true,
                powerPreference: 'high-performance',
                logarithmicDepthBuffer: true
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            this.renderer.outputEncoding = THREE.sRGBEncoding;
            this.renderer.toneMapping = THREE.ACESFilmicToneMapping;

            // Controls
            this.orbitControls = new OrbitControls(this.camera, this.renderer.domElement);
            this.orbitControls.enableDamping = true;
            this.pointerLockControls = new PointerLockControls(this.camera, this.renderer.domElement);

            // Post-processing
            this.composer = new EffectComposer(this.renderer);
            this.composer.addPass(new RenderPass(this.scene, this.camera));
            this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.8, 0.85);
            this.composer.addPass(this.bloomPass);
            this.afterimagePass = new AfterimagePass(0.85);
            this.afterimagePass.enabled = false;
            this.composer.addPass(this.afterimagePass);

            // PHASE 1 SYSTEMS - Initialize EventBus and DataLogger first
            this.eventBus = new EventBus();
            this.dataLogger = new DataLogger(this.eventBus);

            // Initialize sensor systems
            this.sensorManager = new SensoryInputManager(this.eventBus, this);

            // Initialize external data and ML systems
            this.externalData = new ExternalDataManager(this.eventBus);
            this.mlCore = new MachineLearningCore(this.eventBus, this);

            // Initialize AI and decision-making
            this.cosmicAI = new CosmicAwarenessAgent(this.eventBus, this.dataLogger);

            // Initialize quantum and procedural systems
            this.quantumEvents = new QuantumEventManager(this.eventBus, this, this.scene, this.camera);
            this.proceduralGen = new ProceduralGenerationEngine(this.scene, this.eventBus);

            // Legacy systems (keep for compatibility)
            this.audio = new AudioManager(this.ui.audioToggle, this.ui.audioStatus);
            this.solarSystem = new SolarSystemManager(this.scene);
            this.singularity = new Singularity(this.scene);
            this.cosmos = new CosmosParticleSystem(this.scene);
            this.aiLife = new AILifeParticleSystem(this.scene);
            this.spaceship = new SpaceshipController(this.scene);
            this.aiModel = new QuantumAIModel();
            this.particlizer = new Particlizer(this.scene);

            // Background star field
            this.initBackgroundStars();

            // Event listeners
            window.addEventListener('resize', this.onResize.bind(this));
            window.addEventListener('mousedown', this.onMouseDown.bind(this));
            window.addEventListener('mouseup', this.onMouseUp.bind(this));
            window.addEventListener('mousemove', this.onMouseMove.bind(this));
            document.addEventListener('keydown', (e) => this.spaceship.keys[e.code] = true);
            document.addEventListener('keyup', (e) => this.spaceship.keys[e.code] = false);

            // Wire event listeners for Phase 1 systems
            this.setupEventHandlers();
        }

        initBackgroundStars() {
            // Simple background star field (different from quantum soul dust)
            const starGeo = new THREE.BufferGeometry();
            const starCount = 10000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = 5000 + Math.random() * 40000;

                positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);

                // Random star colors (white, blue, red, yellow)
                const colorType = Math.random();
                if (colorType < 0.7) {
                    // White
                    colors[i3] = colors[i3 + 1] = colors[i3 + 2] = 1;
                } else if (colorType < 0.85) {
                    // Blue
                    colors[i3] = 0.7; colors[i3 + 1] = 0.8; colors[i3 + 2] = 1;
                } else if (colorType < 0.95) {
                    // Red
                    colors[i3] = 1; colors[i3 + 1] = 0.5; colors[i3 + 2] = 0.4;
                } else {
                    // Yellow
                    colors[i3] = 1; colors[i3 + 1] = 1; colors[i3 + 2] = 0.7;
                }
            }

            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starMat = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            this.backgroundStars = new THREE.Points(starGeo, starMat);
            this.scene.add(this.backgroundStars);
        }

        setupEventHandlers() {
            // Listen to sensor updates
            this.eventBus.on('sensor:audio:update', (data) => {
                this.dataLogger.logTelemetry('audio', data);
                this.cosmicAI.learn({ audio: data });
            });

            this.eventBus.on('ml:detection', (data) => {
                this.dataLogger.logTelemetry('ml', data);
                this.cosmicAI.learn({ ml: data.detections });
            });

            this.eventBus.on('external:all:fetched', (data) => {
                this.dataLogger.logTelemetry('external', data);
                this.cosmicAI.learn({ external: data });
            });

            // Listen to AI state changes
            this.eventBus.on('ai:influence:generated', (influence) => {
                $('ai-intention').textContent = `Generate universe with gravity: ${influence.gravity.toFixed(2)}, chaos: ${influence.chaos.toFixed(2)}`;
            });

            // Listen to procedural generation events
            this.eventBus.on('procedural:universe:generated', (data) => {
                $('system-status-readout').textContent = `STATUS: Universe generated (${data.stars} stars, ${data.planets} planets)`;
            });
        }

        bindUI() {
            Object.keys(this.physicsParams).forEach(p => {
                const input = $(`in-${p}`);
                const valueDisplay = $(`val-${p}`);
                input.addEventListener('input', () => {
                    this.physicsParams[p] = parseFloat(input.value);
                    valueDisplay.textContent = this.physicsParams[p].toFixed(p === 'li' ? 3 : 2);
                });
            });
            
            this.ui.startButton.addEventListener('click', this.start.bind(this));
            this.ui.anewButton.addEventListener('click', this.reset.bind(this));
            this.ui.directiveButton.addEventListener('click', this.activateDirectivePrime.bind(this));

            // Wire Regenerate button to Phase 1 systems
            this.ui.regenerateButton.addEventListener('click', () => {
                const influence = this.cosmicAI.generateInfluence();
                this.proceduralGen.generateUniverse(influence);
            });
            
            this.ui.tabs.forEach(tab => {
                tab.addEventListener("click", () => {
                    this.ui.tabs.forEach(t => t.classList.remove("active"));
                    this.ui.tabContents.forEach(tc => tc.classList.remove("active"));
                    tab.classList.add("active");
                    $(`tab-${tab.dataset.tab}`).classList.add("active");
                });
            });
            
            this.ui.viewModeSelect.addEventListener('change', (e) => this.setView(e.target.value));

            $('video-particlize-button').addEventListener('click', () => {
                console.log("Live particlizer needs camera access logic to be implemented.");
            });
            $('file-upload').addEventListener('change', (e) => {
                if(e.target.files[0]) this.particlizer.particlize(e.target.files[0]);
            });
        }

        async start() {
            if (this.isRunning) return;
            this.isRunning = true;
            this.ui.blocker.style.opacity = '0';
            setTimeout(() => this.ui.blocker.style.display = 'none', 500);

            // Initialize Phase 1 systems
            await this.sensorManager.initializeAll();
            await this.mlCore.initialize();

            // Fetch external data (non-blocking)
            this.externalData.fetchAll().catch(err => console.warn('External data fetch failed:', err));

            // Initialize quantum and procedural systems
            this.quantumEvents.initialize();

            // Generate initial universe using AI
            const initialInfluence = this.cosmicAI.generateInfluence();
            this.proceduralGen.generateUniverse(initialInfluence);

            // Initialize legacy systems
            this.solarSystem.init();
            this.cosmos.init(this.physicsParams);
            this.aiLife.init();

            this.eventBus.emit('app:started', { timestamp: Date.now() });
            this.animate();
        }
        
        reset() {
            window.location.reload();
        }

        activateDirectivePrime() {
            if (this.directivePrimeActive) return;
            this.setView('galaxy');
            this.directivePrimeActive = true;
            this.directiveState = 'supernova';
            this.directiveTimer = 0;
            this.orbitControls.enabled = false;
        }
        
        animate() {
            if (!this.isRunning && !this.directivePrimeActive) return;
            requestAnimationFrame(this.animate.bind(this));

            const dt = Math.min(this.clock.getDelta(), 0.1);
            const audioData = this.audio.getAnalysis();

            this.aiModel.learn({
                audio: audioData,
                ship: this.spaceship.getState(),
                galaxy: this.physicsParams,
                life: this.aiLife.getStats(),
            });
            const aiState = this.aiModel.update(dt);
            this.updateAIHUD(aiState);

            if (this.directivePrimeActive) {
                this.updateDirectivePrime(dt, audioData);
            } else {
                 this.updateSimulation(dt, audioData);
            }
            
            if (this.currentView === 'spaceship' || this.currentView === 'cockpit') {
                const celestialBodies = this.solarSystem.getCelestialBodies();
                this.spaceship.update(dt, celestialBodies);
                this.spaceship.updateCamera(this.camera);
                this.updateShipHUD();
            } else {
                this.orbitControls.update();
            }
            
            this.composer.render();
        }

        updateSimulation(dt, audioData) {
            this.physicsParams.ugrav = lerp(parseFloat($('in-ugrav').value), parseFloat($('in-ugrav').value) + audioData.bass * 2.5, 0.1);
            this.physicsParams.lambda = lerp(parseFloat($('in-lambda').value), parseFloat($('in-lambda').value) + audioData.mids * 1.5, 0.1);
            this.physicsParams.ec = lerp(parseFloat($('in-ec').value), parseFloat($('in-ec').value) + audioData.treble * 1.0, 0.1);

            // Update Phase 1 systems
            this.sensorManager.update();
            this.quantumEvents.update(dt);
            this.proceduralGen.update(dt);
            this.cosmicAI.tick(Date.now());

            // Update legacy systems
            if (this.currentView === 'galaxy') {
                this.singularity.update(this.physicsParams, this.isMouseDown);
            }
            this.cosmos.update(dt, this.physicsParams, this.mouse, this.isMouseDown);
            this.aiLife.update(dt, audioData, this.mouse, this.isMouseDown);
            this.solarSystem.update(dt);
            this.particlizer.update(dt);

            // Periodic ML detection (every 2 seconds)
            if (!this.lastMLDetection || Date.now() - this.lastMLDetection > 2000) {
                this.lastMLDetection = Date.now();
                const videoElement = this.sensorManager.sensors.video.element;
                if (videoElement && this.sensorManager.sensors.video.active) {
                    this.mlCore.detect(videoElement);
                }
            }

            this.updateGalaxyHUD(this.aiLife.getStats());
        }
        
        updateDirectivePrime(dt, audioData) {
            this.directiveTimer += dt;
            switch (this.directiveState) {
                case 'supernova':
                    this.physicsParams.ugrav = -10.0;
                    if (this.directiveTimer > 3) { this.directiveTimer = 0; this.directiveState = 'convergence'; }
                    break;
                case 'convergence':
                    this.physicsParams.ugrav = lerp(-10.0, 50.0, this.directiveTimer / 8);
                    if (this.directiveTimer > 8) { this.directiveTimer = 0; this.directiveState = 'crystal'; this.aiLife.formNeuralCrystal(); }
                    break;
                case 'crystal':
                    this.physicsParams.ugrav = 50.0;
                    if (this.directiveTimer > 10) { this.directiveTimer = 0; this.directiveState = 'final'; }
                    break;
                case 'final':
                    this.ui.blocker.style.display = 'flex';
                    this.ui.initialScreen.style.display = 'none';
                    this.ui.finalMessage.style.display = 'flex';
                    this.ui.blocker.style.opacity = '1';
                    this.directiveState = 'finished';
                    this.isRunning = false;
                    break;
            }
            this.singularity.update(this.physicsParams, false);
            this.cosmos.update(dt, this.physicsParams, this.mouse, false);
            this.aiLife.update(dt, audioData, this.mouse, false, this.directiveState === 'crystal');
        }
        
        updateGalaxyHUD(lifeStats) {
            this.ui.hud.influence.textContent = this.isMouseDown ? 'Active' : 'Idle';
            this.ui.hud.gravity.textContent = this.physicsParams.ugrav.toFixed(2);
            this.ui.hud.chaos.textContent = this.physicsParams.lambda.toFixed(2);
            this.ui.hud.energy.textContent = this.physicsParams.ec.toFixed(2);
            this.ui.hud.lifePop.textContent = lifeStats.population;
            this.ui.hud.lifeForms.textContent = lifeStats.formations;
            this.ui.hud.lifeEnergy.textContent = lifeStats.energy;
        }
        
        updateShipHUD() {
            const shipState = this.spaceship.getState();
            this.ui.hud.shipVel.textContent = `${shipState.velocity.toFixed(0)} km/s`;
            if (shipState.gravSource) {
                this.ui.hud.shipGrav.textContent = shipState.gravSource.name;
                this.ui.hud.shipAlt.textContent = `${shipState.altitude.toFixed(0)} km`;
            } else {
                this.ui.hud.shipGrav.textContent = 'Deep Space';
                this.ui.hud.shipAlt.textContent = 'N/A';
            }
        }

        updateAIHUD(aiState) {
            this.ui.hud.aiState.textContent = aiState.dominantState;
            this.ui.hud.aiInteraction.textContent = aiState.interaction;
        }

        setView(view) {
            this.currentView = view;
            
            const isGalaxy = view === 'galaxy';
            const isSolar = view === 'solar_system';
            const isShip = view === 'spaceship' || view === 'cockpit';

            // Make particles always visible
            this.cosmos.show(true);
            this.aiLife.show(true);

            // Toggle visibility of mode-specific systems
            this.solarSystem.show(isSolar || isShip);
            this.singularity.show(isGalaxy);
            this.spaceship.show(isShip);
            
            this.ui.galaxyHUD.style.display = isGalaxy ? 'block' : 'none';
            this.ui.shipHUD.style.display = isShip ? 'block' : 'none';

            this.orbitControls.enabled = isGalaxy || isSolar;
            if (isShip) {
                this.pointerLockControls.lock();
                this.spaceship.reset();
            } else {
                if(this.pointerLockControls.isLocked) this.pointerLockControls.unlock();
            }

            if (isGalaxy) {
                this.orbitControls.minDistance = 500;
                this.orbitControls.maxDistance = 10000;
                this.camera.position.set(0, 0, 3500);
                this.orbitControls.target.set(0, 0, 0);
                this.ui.actionText.textContent = 'Hold Left-Click to exert influence.';
            } else if (isSolar) {
                this.orbitControls.minDistance = 100;
                this.orbitControls.maxDistance = 40000;
                this.camera.position.set(0, 8000, 20000);
                this.orbitControls.target.set(0, 0, 0);
                this.ui.actionText.textContent = 'Observe the procedurally generated system.';
            } else if (isShip) {
                 this.ui.actionText.textContent = 'W/S: Thrust | A/D: Yaw | Q/E: Roll | Mouse: Pitch/Yaw';
            }
        }
        
        onResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.composer.setSize(window.innerWidth, window.innerHeight);
        }
        onMouseDown(event) {
            if (event.button === 0) this.isMouseDown = true;
        }
        onMouseUp(event) {
            if (event.button === 0) this.isMouseDown = false;
        }
        onMouseMove(event) {
            if (this.pointerLockControls.isLocked) {
                this.spaceship.handleMouseMove(event);
            } else {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }
        }
    }

    window.genesisApp = new Application();
</script>
</body>
</html>

