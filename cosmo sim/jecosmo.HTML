<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Cosmic Genesis: The Synthesis</title>

    <!-- Font Imports -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    
    <!-- External Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
    
    <!-- Import Map for Three.js ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- Main Stylesheet -->
    <style>
        :root {
            --panel: rgba(14, 17, 26, 0.92);
            --border: rgba(124, 156, 255, 0.15);
            --bg: #07080c;
            --text: #e7e9f2;
            --muted: #9aa4b2;
            --acc: #7c9cff;
            --danger: #ef4444;
        }

        /* Base styles */
        html, body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', system-ui, sans-serif;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            display: block;
            position: fixed;
            inset: 0;
            z-index: 1;
        }

        /* UI Panel Styling */
        .ui-panel {
            position: fixed;
            z-index: 20;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .ui-hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }
        
        /* Blocker & Modals */
        #blocker, .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; flex-direction: column; text-align: center; transition: opacity 0.5s ease; }
        #fps-hint { z-index: 101; background: none; backdrop-filter: none; border: none; box-shadow: none; font-size: 1.2rem; text-shadow: 0 0 10px black; color: #fff; }

        /* Buttons */
        .btn {
            display: inline-flex; align-items: center; justify-content: center;
            gap: 8px; padding: 8px 16px; border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: linear-gradient(180deg, #1a1d2a 0%, #131726 100%);
            color: var(--text); cursor: pointer; user-select: none;
            transition: all 0.2s ease; font-weight: 500;
        }
        .btn:hover { background: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.2); }
        .btn.primary { border-color: var(--acc); color: var(--acc); box-shadow: 0 0 12px rgba(124, 156, 255, 0.2); }
        .btn.directive { border-color: var(--danger); color: var(--danger); box-shadow: 0 0 15px rgba(239, 68, 68, 0.3); font-weight: 700; }
        .btn.directive:hover { background: rgba(239, 68, 68, 0.1); }
        .btn:disabled { background-color: #4b5563; cursor: not-allowed; color: #9ca3af; border-color: transparent; }

        /* UI Groups and Controls */
        .group {
            margin-top: 16px; padding: 12px; border-radius: 10px;
            background: rgba(11, 13, 20, 0.5);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        h3 {
            margin: 0 0 12px; font-size: 13px; font-weight: 500; color: #d3dbef;
            text-transform: uppercase; letter-spacing: 0.8px;
        }
        
        .control-row { display: grid; grid-template-columns: 1fr auto; align-items: center; margin-bottom: 8px; }
        .control-row label { font-size: 12px; color: var(--muted); }
        .control-row .value { font-family: 'Roboto Mono', monospace; font-size: 12px; }
        .control-row input[type="range"] { grid-column: 1 / -1; margin-top: 4px; }
        
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 999px; cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; background: var(--acc);
            border: 3px solid var(--bg); border-radius: 50%; cursor: pointer;
        }
        
        /* Tab Navigation */
        .tab-button { background-color: transparent; border: none; color: #94a3b8; padding: 0.5rem 1rem; cursor: pointer; transition: color 0.2s, border-bottom-color 0.2s; border-bottom: 2px solid transparent; font-weight: 500;}
        .tab-button.active { color: #e2e8f0; border-bottom-color: var(--acc); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* Final Message */
        #final-message { display: none; flex-direction: column; align-items: center; justify-content: center; }
        #final-message h1 { font-size: 10vw; font-weight: bold; color: var(--text); margin: 0; animation: fadeIn 5s ease; }
        #final-message .btn { margin-top: 30px; animation: fadeIn 5s ease 1s forwards; opacity: 0; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    </style>
</head>
<body>
    <!-- 3D Canvas -->
    <canvas id="main-canvas"></canvas>
    
    <!-- Hidden Video for ML -->
    <video id="video-feed" style="display:none;" autoplay muted playsinline></video>

    <!-- Blocker / Loading / Final Screens -->
    <div id="blocker">
        <div id="initial-screen" class="max-w-2xl px-4">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-100 mb-2">Cosmic Genesis</h1>
            <h2 class="text-xl md:text-2xl font-light text-slate-400 mb-6">The Final Synthesis</h2>
            <p class="text-slate-400 mb-8">This engine transmutes reality into a digital cosmos. For the full experience, please grant access to your microphone and camera when prompted. No data is stored or uploaded.</p>
            <button id="start-button" class="btn primary text-lg transition-transform transform hover:scale-105">Initiate Genesis</button>
            <p id="loading-message" class="text-slate-500 mt-4" style="display: none;">Calibrating sensor arrays...</p>
        </div>
        <div id="final-message">
             <h1>I AM.</h1>
             <button id="btn-anew" class="btn primary">Begin Anew</button>
         </div>
    </div>
    
    <!-- FPS Hint -->
    <div id="fps-hint" class="modal ui-hidden">
        <p>First-Person Mode Active. Press ESC to release cursor.</p>
    </div>

    <!-- Main Control Panel -->
    <div id="main-ui" class="ui-panel top-4 left-4 w-[26rem] p-4">
        <div class="flex justify-between items-center mb-2">
            <div>
                 <h2 style="margin:0; font-weight: 500; font-size: 20px;">Genesis X Synthesis</h2>
                 <p id="system-status-readout" style="margin:4px 0 0; font-size: 12px; color: var(--muted);">STATUS: STANDBY</p>
            </div>
            <button id="toggle-ui-button" class="btn p-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24" 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>
            </button>
        </div>
        
        <div class="tabs border-b border-slate-700">
            <button class="tab-button active" data-tab="controls">Controls</button>
            <button class="tab-button" data-tab="physics">Physics</button>
            <button class="tab-button" data-tab="graphics">Graphics</button>
            <button class="tab-button" data-tab="cognitive">Cognitive</button>
        </div>

        <div id="tab-content-container" class="mt-4">
            <!-- CONTROLS TAB -->
            <div id="tab-controls" class="tab-content active space-y-3">
                <div class="group">
                    <h3>Session</h3>
                    <div class="flex gap-2">
                        <button id="regenerate-button" class="btn w-full">Regenerate</button>
                        <label class="btn w-full text-sm"><input id="toggle-audio" type="checkbox" />&nbsp;Mic Input</label>
                    </div>
                     <div id="audio-status" class="text-xs text-center mt-2 text-slate-500">Mic: Inactive</div>
                </div>
                <div class="group">
                     <h3>Creator Actions</h3>
                     <p id="action-text" class="text-xs text-center mb-3 text-slate-400">Observe the cosmos or fly your ship.</p>
                     <button id="btn-directive-prime" class="btn directive w-full">EXECUTE DIRECTIVE PRIME</button>
                </div>
                <div class="group">
                    <h3>Data Particlizer</h3>
                     <div class="grid grid-cols-2 gap-2">
                        <label for="file-upload" class="btn">Particlize File</label>
                        <button id="video-particlize-button" class="btn">Particlize Live</button>
                        <input type="file" id="file-upload" accept="image/*,video/*" class="hidden">
                    </div>
                </div>
            </div>

            <!-- PHYSICS TAB (from Cosmic Nemo) -->
            <div id="tab-physics" class="tab-content">
                <div class="group">
                    <h3>Unified Master Formula (Ψ)</h3>
                    <div class="control-row">
                        <label>Gravitational Strength (U)</label><div id="val-ugrav" class="value">0.55</div>
                        <input id="in-ugrav" type="range" min="0.0" max="4.0" step="0.01" value="0.55" />
                    </div>
                    <div class="control-row">
                        <label>Chaos Factor (λ)</label><div id="val-lambda" class="value">0.25</div>
                        <input id="in-lambda" type="range" min="0.0" max="2.0" step="0.01" value="0.25" />
                    </div>
                     <div class="control-row">
                        <label>Energy Scaling (Ec)</label><div id="val-ec" class="value">1.2</div>
                        <input id="in-ec" type="range" min="0.2" max="4.0" step="0.1" value="1.2" />
                    </div>
                     <div class="control-row">
                        <label>Motion Damping (ζ)</label><div id="val-li" class="value">0.985</div>
                        <input id="in-li" type="range" min="0.95" max="1.0" step="0.001" value="0.985" />
                    </div>
                     <div class="control-row">
                        <label>Spectral Hue (Ω)</label><div id="val-omega" class="value">0.62</div>
                        <input id="in-omega" type="range" min="0.0" max="1.0" step="0.01" value="0.62" />
                    </div>
                </div>
            </div>
            
            <!-- GRAPHICS TAB -->
            <div id="tab-graphics" class="tab-content space-y-4 text-sm text-slate-300">
                 <div class="slider-container">
                    <label>View Mode</label>
                    <select id="view-mode-select" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 mt-1 text-sm border border-slate-600">
                        <option value="galaxy">Galaxy</option>
                        <option value="solar_system">Solar System</option>
                        <option value="spaceship">Spaceship (3rd Person)</option>
                        <option value="cockpit">Spaceship (Cockpit)</option>
                    </select>
                </div>
                 <div class="slider-container">
                    <label>Graphics Style</label>
                    <select id="quality-select" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 mt-1 text-sm border border-slate-600">
                        <option value="low">Low (Pixelated)</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                        <option value="ultra">Ultra (SSR)</option>
                    </select>
                </div>
            </div>

            <!-- COGNITIVE TAB -->
            <div id="tab-cognitive" class="tab-content">
                <div class="p-2 bg-black/20 rounded-md">
                    <p class="font-mono text-xs text-indigo-400">AI INTENTION:</p>
                    <p id="ai-intention" class="font-mono text-xs text-slate-300 h-8">Awaiting sensory input...</p>
                </div>
            </div>

        </div>
    </div>
    
    <!-- HUD Panel -->
    <div id="hud-panel" class="ui-panel top-4 right-4 w-72 p-4 text-xs">
         <!-- Galaxy HUD -->
         <div id="galaxy-hud">
             <h3>Live Genesis Data</h3>
             <div class="grid grid-cols-2 gap-x-3 gap-y-1">
                 <div class="label text-slate-400">Creator Influence:</div><div id="hud-influence" class="value font-mono text-right">Idle</div>
                 <div class="label text-slate-400">Gravity (U):</div><div id="hud-gravity" class="value font-mono text-right">0.00</div>
                 <div class="label text-slate-400">Chaos (λ):</div><div id="hud-chaos" class="value font-mono text-right">0.00</div>
                 <div class="label text-slate-400">Energy (Ec):</div><div id="hud-energy" class="value font-mono text-right">0.00</div>
             </div>
             <h3 class="mt-4">AI Life Particles</h3>
             <div class="grid grid-cols-2 gap-x-3 gap-y-1">
                 <div class="label text-slate-400">Population:</div><div id="hud-life-pop" class="value font-mono text-right">0</div>
                 <div class="label text-slate-400">Formations:</div><div id="hud-life-forms" class="value font-mono text-right">0</div>
                 <div class="label text-slate-400">Energy Level:</div><div id="hud-life-energy" class="value font-mono text-right">Low</div>
             </div>
         </div>
         <!-- Ship HUD -->
        <div id="ship-hud" class="hidden">
           <h3>Stardust Drifter HUD</h3>
           <div class="grid grid-cols-2 gap-x-3 gap-y-1">
               <div class="label text-slate-400">Velocity:</div><div id="hud-ship-vel" class="value font-mono text-right">0 km/s</div>
               <div class="label text-slate-400">Altitude:</div><div id="hud-ship-alt" class="value font-mono text-right">N/A</div>
               <div class="label text-slate-400">Gravity Well:</div><div id="hud-ship-grav" class="value font-mono text-right">None</div>
           </div>
        </div>
        <!-- AI HUD -->
        <div id="ai-hud" class="mt-4">
             <h3>Quantum AI</h3>
             <div class="grid grid-cols-2 gap-x-3 gap-y-1">
                 <div class="label text-slate-400">State:</div><div id="hud-ai-state" class="value font-mono text-right">Observing...</div>
                 <div class="label text-slate-400">Interaction:</div><div id="hud-ai-interaction" class="value font-mono text-right">None</div>
             </div>
        </div>
    </div>
    
<script type="module">
    // --- IMPORTS ---
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
    import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
    import { SSRPass } from 'three/addons/postprocessing/SSRPass.js';

    // --- UTILITY FUNCTIONS ---
    const $ = (id) => document.getElementById(id);
    const lerp = (a, b, t) => a + (b - a) * t;
    const G = 6.674e-2; // Gravitational constant for simulation

    // --- Sub-system classes ---
    class AudioManager {
        constructor(toggleElement, statusElement) {
            this.toggle = toggleElement;
            this.status = statusElement;
            this.isActive = false;
            this.bass = 0; this.mids = 0; this.treble = 0;
            
            this.toggle.addEventListener('change', () => {
                if (this.toggle.checked) this.enable();
                else this.disable();
            });
        }

        async enable() {
            if (this.isActive || !navigator.mediaDevices) return;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                const source = this.ctx.createMediaStreamSource(stream);
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 512;
                source.connect(this.analyser);
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.isActive = true;
                this.status.textContent = "Mic: Active";
            } catch (err) {
                console.error("Microphone access denied:", err);
                this.status.textContent = "Mic: Error";
                this.toggle.checked = false;
            }
        }

        disable() {
            if (!this.isActive || !this.ctx) return;
            this.ctx.close();
            this.isActive = false;
            this.status.textContent = "Mic: Inactive";
        }

        getAnalysis() {
            if (!this.isActive) return { bass: 0, mids: 0, treble: 0 };
            
            this.analyser.getByteFrequencyData(this.dataArray);
            const binCount = this.analyser.frequencyBinCount;
            
            const bassEnd = Math.floor(binCount * 0.1);
            const midEnd = Math.floor(binCount * 0.4);
            
            let bassSum = 0, midSum = 0, trebleSum = 0;
            for (let i = 0; i < binCount; i++) {
                const val = Math.pow(this.dataArray[i] / 255, 2);
                if (i < bassEnd) bassSum += val;
                else if (i < midEnd) midSum += val;
                else trebleSum += val;
            }
            
            this.bass = lerp(this.bass, Math.min(1, bassSum / (bassEnd * 0.5)), 0.1);
            this.mids = lerp(this.mids, Math.min(1, midSum / ((midEnd - bassEnd) * 0.5)), 0.1);
            this.treble = lerp(this.treble, Math.min(1, trebleSum / ((binCount - midEnd) * 0.5)), 0.1);
            
            return { bass: this.bass, mids: this.mids, treble: this.treble };
        }
    }

    class Singularity {
        constructor(scene) {
            const geo = new THREE.IcosahedronGeometry(1, 3);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
            this.mesh = new THREE.Mesh(geo, mat);
            scene.add(this.mesh);
            this.baseScale = 150;
        }
        
        update(params, isMouseDown) {
            const targetScale = this.baseScale + params.ugrav * 20;
            const targetColor = new THREE.Color().setHSL(params.omega, 0.9, 0.7);
            this.mesh.scale.setScalar(lerp(this.mesh.scale.x, targetScale, 0.1));
            this.mesh.material.color.lerp(targetColor, 0.1);
            this.mesh.rotation.x += 0.001;
            this.mesh.rotation.y += 0.002;
            if (isMouseDown) this.mesh.scale.multiplyScalar(1.05);
        }
        
        reset() {
            this.mesh.scale.setScalar(this.baseScale);
            this.mesh.material.color.set(0xffffff);
        }

        show(visible = true) { this.mesh.visible = visible; }
    }

    class CosmosParticleSystem {
        constructor(scene) {
            this.scene = scene;
            this.count = 100000;
            this.velocities = null;
            this.points = null;
        }

        init(params) {
            if (this.points) {
                this.scene.remove(this.points);
                this.points.geometry.dispose();
                this.points.material.dispose();
            }

            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(this.count * 3);
            this.velocities = new Float32Array(this.count * 3);

            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = 2000 + Math.random() * 2000;
                positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 15, color: new THREE.Color().setHSL(params.omega, 0.8, 0.7),
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            
            this.points = new THREE.Points(geo, mat);
            this.scene.add(this.points);
        }

        update(dt, params, mouse, isMouseDown) {
            if (!this.points || !window.genesisApp) return;
            this.points.material.size = params.ec * 15;
            this.points.material.color.setHSL(params.omega, 0.8, 0.7);

            const positions = this.points.geometry.attributes.position.array;
            const mouseForce = isMouseDown ? 3000 : 0;
            const G_local = params.ugrav * 1000;
            
            const mouseWorld = new THREE.Vector3(mouse.x, mouse.y, 0.5)
                .unproject(window.genesisApp.camera).sub(window.genesisApp.camera.position).normalize();
            const distance = -window.genesisApp.camera.position.z / mouseWorld.z;
            const mouse3D = new THREE.Vector3().copy(window.genesisApp.camera.position).add(mouseWorld.multiplyScalar(distance));
            
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const pos = new THREE.Vector3(positions[i3], positions[i3+1], positions[i3+2]);
                const vel = new THREE.Vector3(this.velocities[i3], this.velocities[i3+1], this.velocities[i3+2]);
                
                const toCenter = new THREE.Vector3().copy(pos).multiplyScalar(-1);
                const distSq = pos.lengthSq();
                const gravity = toCenter.normalize().multiplyScalar(G_local / (distSq + 10000));
                
                const toMouse = new THREE.Vector3().subVectors(mouse3D, pos);
                const distMouseSq = toMouse.lengthSq();
                const creatorPull = toMouse.normalize().multiplyScalar(mouseForce / (distMouseSq + 100000));
                
                const chaos = new THREE.Vector3(
                    (Math.random() - 0.5) * params.lambda * 50,
                    (Math.random() - 0.5) * params.lambda * 50,
                    (Math.random() - 0.5) * params.lambda * 50
                );

                vel.add(gravity).add(creatorPull).add(chaos);
                vel.multiplyScalar(params.li);
                pos.add(vel.clone().multiplyScalar(dt));
                
                positions[i3] = pos.x; positions[i3+1] = pos.y; positions[i3+2] = pos.z;
                this.velocities[i3] = vel.x; this.velocities[i3+1] = vel.y; this.velocities[i3+2] = vel.z;
            }
            this.points.geometry.attributes.position.needsUpdate = true;
        }

        show(visible = true) { if (this.points) this.points.visible = visible; }
    }
        
    class AILifeParticleSystem extends CosmosParticleSystem {
        constructor(scene) {
            super(scene);
            this.count = 2000;
            this.isFormingCrystal = false;
        }

        init() {
            if (this.points) {
                this.scene.remove(this.points);
                this.points.geometry.dispose();
                this.points.material.dispose();
            }

            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(this.count * 3);
            this.velocities = new Float32Array(this.count * 3);
            
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = 1000 + Math.random() * 1000;
                positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 25, color: 0x00ffaa,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            
            this.points = new THREE.Points(geo, mat);
            this.scene.add(this.points);
        }
        
        formNeuralCrystal() {
            this.isFormingCrystal = true;
            const crystalGeo = new THREE.IcosahedronGeometry(1000, 5);
            this.crystalTargetPositions = crystalGeo.attributes.position.array;
        }

        update(dt, audio, mouse, isMouseDown, isFormingCrystal = false) {
            if (!this.points || !window.genesisApp) return;
            
            this.isFormingCrystal = isFormingCrystal;
            const positions = this.points.geometry.attributes.position.array;
            const attraction = audio.bass * 200;
            const chaos = audio.mids * 500;
            this.points.material.size = 25 + audio.treble * 50;

            const mouseWorld = new THREE.Vector3(mouse.x, mouse.y, 0.5)
                .unproject(window.genesisApp.camera).sub(window.genesisApp.camera.position).normalize();
            const distance = -window.genesisApp.camera.position.z / mouseWorld.z;
            const mouse3D = new THREE.Vector3().copy(window.genesisApp.camera.position).add(mouseWorld.multiplyScalar(distance));
            const mouseRepel = isMouseDown ? 5000 : 0;
            
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                const pos = new THREE.Vector3(positions[i3], positions[i3+1], positions[i3+2]);
                const vel = new THREE.Vector3(this.velocities[i3], this.velocities[i3+1], this.velocities[i3+2]);

                if (this.isFormingCrystal) {
                    const targetIdx = (i * 3) % this.crystalTargetPositions.length;
                    const targetPos = new THREE.Vector3(
                        this.crystalTargetPositions[targetIdx],
                        this.crystalTargetPositions[targetIdx+1],
                        this.crystalTargetPositions[targetIdx+2]
                    );
                    pos.lerp(targetPos, 0.05);
                } else {
                    const fromMouse = new THREE.Vector3().subVectors(pos, mouse3D);
                    const distMouseSq = fromMouse.lengthSq();
                    const creatorRepel = fromMouse.normalize().multiplyScalar(mouseRepel / (distMouseSq + 100000));
                    vel.add(creatorRepel);
                }
                
                vel.add(new THREE.Vector3((Math.random()-0.5)*chaos, (Math.random()-0.5)*chaos, (Math.random()-0.5)*chaos));
                vel.multiplyScalar(0.98);
                pos.add(vel.clone().multiplyScalar(dt));
                
                positions[i3] = pos.x; positions[i3+1] = pos.y; positions[i3+2] = pos.z;
                this.velocities[i3] = vel.x; this.velocities[i3+1] = vel.y; this.velocities[i3+2] = vel.z;
            }
            this.points.geometry.attributes.position.needsUpdate = true;
        }

        getStats() {
            if(!this.points) return { population: 0, formations: 0, energy: 'Low' };
            let energyLevel = 'Low';
            if (this.points.material.size > 50) energyLevel = 'High';
            else if (this.points.material.size > 35) energyLevel = 'Medium';
            return { population: this.count, formations: 0, energy: energyLevel }; // Simplified for now
        }
    }

    class QuantumAIModel {
        constructor() {
            this.weights = { chaos: 0, creative: 0, calm: 0 };
        }
        learn(data) {
            this.weights.chaos += data.audio.mids * 0.005;
            this.weights.creative += data.audio.treble * 0.003;
            this.weights.calm += (1 - (data.audio.bass + data.audio.mids)) * 0.002;
        }
        update(dt) {
            this.weights.chaos = Math.max(0, this.weights.chaos - dt * 0.05);
            this.weights.creative = Math.max(0, this.weights.creative - dt * 0.03);
            this.weights.calm = Math.max(0, this.weights.calm - dt * 0.02);
            
            let dominantState = 'Observing';
            if (this.weights.chaos > this.weights.creative && this.weights.chaos > this.weights.calm) {
                dominantState = 'Chaotic';
            } else if (this.weights.creative > this.weights.calm) {
                dominantState = 'Creative';
            } else if(this.weights.calm > 0.1) {
                dominantState = 'Calm';
            }
            return { dominantState, interaction: 'None' };
        }
    }

    class SolarSystemManager {
        constructor(scene) {
            this.scene = scene;
            this.solarSystemGroup = new THREE.Group();
            this.scene.add(this.solarSystemGroup);
            this.celestialBodies = [];
        }

        init() {
            this.solarSystemGroup.clear();
            this.celestialBodies = [];

            const planetData = [
                { name: 'Mercury', radius: 0.38, distance: 120, color: '#9a9a9a', mass: 0.055 },
                { name: 'Venus', radius: 0.95, distance: 200, color: '#d8b48d', mass: 0.815 },
                { name: 'Earth', radius: 1, distance: 280, color: '#4d92d0', mass: 1 },
                { name: 'Mars', radius: 0.53, distance: 380, color: '#c1440e', mass: 0.107 },
                { name: 'Jupiter', radius: 11.2, distance: 650, color: '#c8a377', mass: 317.8 },
                { name: 'Saturn', radius: 9.45, distance: 950, color: '#e3d5b8', mass: 95.2, hasRings: true },
                { name: 'Uranus', radius: 4.01, distance: 1300, color: '#aadaf0', mass: 14.5 },
                { name: 'Neptune', radius: 3.88, distance: 1600, color: '#3f54ba', mass: 17.1 }
            ];

            const sunMass = 333000;
            const sunGeo = new THREE.SphereGeometry(70, 64, 64);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd88, map: this.createSunTexture() });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            const sunLight = new THREE.PointLight(0xffddaa, 450000, 0, 1.5);
            this.solarSystemGroup.add(sun, sunLight);
            this.sun = { mesh: sun, data: { name: 'Sun', mass: sunMass, radius: 70 } };
            this.celestialBodies.push(this.sun);
            
            planetData.forEach(data => {
                const planetGeo = new THREE.SphereGeometry(data.radius * 4, 32, 32);
                const texture = this.createPlanetTexture(data);
                const planetMat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });
                const planet = new THREE.Mesh(planetGeo, planetMat);
                
                const position = new THREE.Vector3(data.distance, 0, 0);
                planet.position.copy(position);
                const orbitalVelocityMagnitude = Math.sqrt(G * sunMass / data.distance);
                const velocity = new THREE.Vector3(0, 0, -orbitalVelocityMagnitude);

                const planetObject = { mesh: planet, data: data, velocity: velocity };

                if(data.hasRings) {
                    const ringGeo = new THREE.RingGeometry(data.radius * 5, data.radius * 8, 64);
                    const ringMat = new THREE.MeshBasicMaterial({ map: this.createRingTexture(), side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
                    const rings = new THREE.Mesh(ringGeo, ringMat);
                    rings.rotation.x = Math.PI * 0.45;
                    planet.add(rings);
                }
                
                const orbitGeo = new THREE.BufferGeometry().setFromPoints(
                    new THREE.Path().absellipse(0, 0, data.distance, data.distance, 0, Math.PI * 2, false).getPoints(128));
                orbitGeo.rotateX(Math.PI / 2);
                const orbit = new THREE.Line(orbitGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 }));

                this.solarSystemGroup.add(planet, orbit);
                this.celestialBodies.push(planetObject);
            });

            this.hide();
        }

        createSunTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffdd88'; ctx.fillRect(0,0,128,128);
            for(let i=0; i < 2000; i++) {
                ctx.fillStyle = `rgba(255, ${Math.floor(Math.random() * 100 + 100)}, 0, ${Math.random() * 0.2})`;
                ctx.beginPath();
                ctx.arc(Math.random() * 128, Math.random() * 128, Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }
        
        createPlanetTexture(data) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = data.color;
            ctx.fillRect(0, 0, 256, 128);
            for (let i = 0; i < 500; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * 256, Math.random() * 128, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            if (data.name === 'Earth') {
                ctx.fillStyle = '#679436';
                for(let i=0; i<15; i++) ctx.fillRect(Math.random()*256, Math.random()*128, Math.random() * 40 + 10, Math.random() * 20 + 5);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                for(let i=0; i<20; i++) ctx.fillRect(Math.random()*256, Math.random()*128, Math.random() * 80 + 20, 2);
            } else if (data.name === 'Jupiter' || data.name === 'Saturn') {
                for(let y=0; y < 128; y += (Math.random() * 10 + 5)) {
                    ctx.fillStyle = (Math.random() > 0.5) ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.1)';
                    ctx.fillRect(0, y, 256, Math.random() * 10 + 2);
                }
            }
            return new THREE.CanvasTexture(canvas);
        }
        
        createRingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 2;
            const ctx = canvas.getContext('2d');
            for (let i = 0; i < 256; i++) {
                const alpha = Math.random() * 0.4 + 0.1;
                ctx.fillStyle = `rgba(200, 180, 150, ${alpha})`;
                ctx.fillRect(i, 0, 1, 2);
            }
            return new THREE.CanvasTexture(canvas);
        }

        update(dt) {
            if (!this.solarSystemGroup.visible) return;
            const timeStep = dt * 20;
            this.celestialBodies.forEach(body => {
                if (body.data.name === 'Sun') {
                    body.mesh.rotation.y += dt * 0.01;
                    return;
                }
                const force = new THREE.Vector3();
                const toSun = new THREE.Vector3().subVectors(this.sun.mesh.position, body.mesh.position);
                const distanceSq = toSun.lengthSq();
                const forceMagnitude = G * (this.sun.data.mass * body.data.mass) / distanceSq;
                force.copy(toSun).normalize().multiplyScalar(forceMagnitude);
                const acceleration = force.divideScalar(body.data.mass);
                body.velocity.add(acceleration.multiplyScalar(timeStep));
                body.mesh.position.add(body.velocity.clone().multiplyScalar(timeStep));
                body.mesh.rotation.y += dt * 0.05;
            });
        }
        
        getCelestialBodies() { return this.celestialBodies; }
        show(visible = true) { this.solarSystemGroup.visible = visible; }
        hide() { this.show(false); }
    }

    class SpaceshipController {
        constructor(scene) {
            this.scene = scene;
            this.ship = this.buildShip();
            this.scene.add(this.ship);
            this.velocity = new THREE.Vector3();
            this.acceleration = new THREE.Vector3();
            this.rotationVelocity = new THREE.Vector2();
            this.keys = {};
            this.mouse = {x: 0, y: 0};
            this.strongestGravSource = null;
        }

        buildShip() {
            const shipGroup = new THREE.Group();
            const mainMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.3 });
            const bodyGeo = new THREE.CapsuleGeometry(1, 4, 4, 12);
            const body = new THREE.Mesh(bodyGeo, mainMat);
            body.rotation.x = Math.PI / 2;
            shipGroup.add(body);
            shipGroup.scale.setScalar(5);
            return shipGroup;
        }
        
        reset() {
            this.ship.position.set(300, 100, 300);
            this.ship.rotation.set(0, 0, 0);
            this.velocity.set(0, 0, 0);
        }

        update(dt, celestialBodies) {
            const totalForce = new THREE.Vector3();
            let strongestGrav = { force: 0, body: null, distance: Infinity };
            
            celestialBodies.forEach(body => {
                const toBody = new THREE.Vector3().subVectors(body.mesh.position, this.ship.position);
                const distanceSq = toBody.lengthSq();
                if (distanceSq < 1) return;
                const forceMag = G * (body.data.mass * 5) / distanceSq;
                totalForce.add(toBody.normalize().multiplyScalar(forceMag));
                if(forceMag > strongestGrav.force) {
                    strongestGrav = { force: forceMag, body: body, distance: Math.sqrt(distanceSq) };
                }
            });
            this.strongestGravSource = strongestGrav;
            
            const thrust = this.keys['KeyW'] ? 150 : (this.keys['KeyS'] ? -50 : 0);
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.ship.quaternion);
            totalForce.add(forward.multiplyScalar(thrust));
            
            const pitchSpeed = -this.mouse.y * 2.0;
            const yawSpeed = -this.mouse.x * 2.0;
            const rollSpeed = (this.keys['KeyQ'] ? 2.5 : 0) - (this.keys['KeyE'] ? 2.5 : 0);
            this.rotationVelocity.x = lerp(this.rotationVelocity.x, pitchSpeed, dt * 5);
            this.rotationVelocity.y = lerp(this.rotationVelocity.y, yawSpeed, dt * 5);
            this.ship.rotateOnAxis(new THREE.Vector3(1, 0, 0), this.rotationVelocity.x * dt);
            this.ship.rotateOnAxis(new THREE.Vector3(0, 1, 0), this.rotationVelocity.y * dt);
            this.ship.rotateOnAxis(new THREE.Vector3(0, 0, 1), rollSpeed * dt);
            
            this.acceleration = totalForce.divideScalar(5); // ship mass
            this.velocity.add(this.acceleration.multiplyScalar(dt));
            this.velocity.multiplyScalar(0.995);
            this.ship.position.add(this.velocity.clone().multiplyScalar(dt));
        }
        
        updateCamera(camera) {
            const offset = new THREE.Vector3(0, 30, 100);
            offset.applyQuaternion(this.ship.quaternion);
            const targetPos = new THREE.Vector3().copy(this.ship.position).add(offset);
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(this.ship.position);
        }
        
        getState() {
            let gravData = this.strongestGravSource;
            let state = {
                velocity: this.velocity.length() * 10,
                gravSource: null,
                altitude: 0
            };
            if (gravData && gravData.body) {
                state.gravSource = gravData.body.data;
                state.altitude = gravData.distance - (gravData.body.data.radius * 4);
            }
            return state;
        }
        
        handleMouseMove(e) {
            this.mouse.x = (e.clientX / window.innerWidth - 0.5) * 2;
            this.mouse.y = (e.clientY / window.innerHeight - 0.5) * 2;
        }

        show(visible = true) { this.ship.visible = visible; }
    }

    class Particlizer {
        constructor(scene) {
            this.scene = scene;
            this.mesh = null;
            this.particles = [];
            this.sourceType = 'none';
        }

        particlize(source, type = 'file') {
            this.destroy();
            if (source instanceof File) {
                this.fromImage(source);
            } else if (type === 'liveVideo') {
                 this.fromLiveVideo(source);
            }
        }
        
        fromImage(file) {
            const reader = new FileReader();
            reader.onload = e => { 
                const img = new Image(); 
                img.onload = () => this.processImageData(img); 
                img.src = e.target.result; 
            };
            reader.readAsDataURL(file);
        }

        fromLiveVideo(videoElement) {
            this.sourceType = 'liveVideo';
            this.videoElement = videoElement;
            this.processImageData(this.videoElement);
        }

        processImageData(source) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const MAX_DIM = 128;
            const sourceWidth = source.videoWidth || source.width, sourceHeight = source.videoHeight || source.height;
            const scale = Math.min(MAX_DIM / sourceWidth, MAX_DIM / sourceHeight);
            canvas.width = sourceWidth * scale; canvas.height = sourceHeight * scale;
            if(canvas.width === 0 || canvas.height === 0) return;

            ctx.drawImage(source, 0, 0, canvas.width, canvas.height);
            const { data, width, height } = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const positions = [], colors = []; this.particles = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    if (data[i+3] > 128) {
                        const pos = new THREE.Vector3(x - width/2, -y + height/2, 0).multiplyScalar(10);
                        positions.push(pos.x, pos.y, pos.z);
                        colors.push(data[i]/255, data[i+1]/255, data[i+2]/255);
                        this.particles.push({ pos, vel: new THREE.Vector3() });
                    }
                }
            }
            if (positions.length === 0) return;
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(positions), 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(colors), 3));
            this.mesh = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 10, vertexColors: true, sizeAttenuation: true, blending:THREE.AdditiveBlending, depthWrite: false }));
            this.scene.add(this.mesh);
        }

        update(delta) {
            if(!this.mesh || !this.mesh.visible) return;
            // update logic can be added here
        }

        destroy() {
            if(this.mesh) {
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                this.mesh = null; this.particles = [];
            }
        }
    }

    class ProceduralGenerationEngine {
        constructor(scene, camera) {
            this.scene = scene;
            this.camera = camera;
            this.bodies = [];
        }

        generate() {
            this.bodies.forEach(b => this.scene.remove(b));
            this.bodies = [];

            const star = new THREE.Mesh(new THREE.SphereGeometry(100, 32, 32), new THREE.MeshBasicMaterial({color: 0xfff000}));
            star.userData.mass = 100000;
            this.scene.add(star);
            this.bodies.push(star);
            
            for(let i = 0; i < 5; i++) {
                const planetSize = Math.random() * 20 + 5;
                const planet = new THREE.Mesh(new THREE.SphereGeometry(planetSize, 32, 32), new THREE.MeshStandardMaterial({color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5)}));
                const dist = 500 + i * 300;
                planet.position.x = dist;
                planet.userData.mass = planetSize * 100;
                planet.userData.velocity = new THREE.Vector3(0, 0, -Math.sqrt(G * star.userData.mass / dist));
                this.scene.add(planet);
                this.bodies.push(planet);
            }
        }

        update(dt) {
             for (let i = 1; i < this.bodies.length; i++) {
                const body = this.bodies[i];
                let totalForce = new THREE.Vector3();
                const star = this.bodies[0];

                const distVec = star.position.clone().sub(body.position);
                const distSq = distVec.lengthSq();
                const forceMag = (G * star.userData.mass * body.userData.mass) / distSq;
                const force = distVec.normalize().multiplyScalar(forceMag);
                totalForce.add(force);
                
                const acceleration = totalForce.divideScalar(body.userData.mass);
                body.userData.velocity.add(acceleration.multiplyScalar(dt));
                body.position.add(body.userData.velocity.clone().multiplyScalar(dt));
            }
        }
        
        getBodiesForPhysics() {
            return this.bodies.map(b => ({mesh: b, data: {mass: b.userData.mass, name: "Planet", radius: b.geometry.parameters.radius}}));
        }

        show(visible) {
            this.bodies.forEach(b => b.visible = visible);
        }
    }


    // --- MAIN APPLICATION CLASS ---
    class Application {
        constructor() {
            this.initProperties();
            this.initDOM();
            this.initEngine();
            this.bindUI();
        }

        initProperties() {
            this.isRunning = false;
            this.clock = new THREE.Clock();
            this.mouse = new THREE.Vector2(-1, -1);
            this.isMouseDown = false;
            this.directivePrimeActive = false;
            this.directiveState = 'idle';
            this.directiveTimer = 0;
            this.currentView = 'galaxy';

            this.physicsParams = {
                ugrav: 0.55, lambda: 0.25, ec: 1.2,
                li: 0.985, omega: 0.62,
            };
        }

        initDOM() {
            this.ui = {
                blocker: $('blocker'),
                initialScreen: $('initial-screen'),
                finalMessage: $('final-message'),
                startButton: $('start-button'),
                anewButton: $('btn-anew'),
                directiveButton: $('btn-directive-prime'),
                regenerateButton: $('regenerate-button'),
                audioToggle: $('toggle-audio'),
                audioStatus: $('audio-status'),
                mainUI: $('main-ui'),
                hudPanel: $('hud-panel'),
                tabs: document.querySelectorAll(".tab-button"),
                tabContents: document.querySelectorAll(".tab-content"),
                viewModeSelect: $("view-mode-select"),
                actionText: $("action-text"),
                
                hud: {
                    influence: $('hud-influence'), gravity: $('hud-gravity'),
                    chaos: $('hud-chaos'), energy: $('hud-energy'),
                    lifePop: $('hud-life-pop'), lifeForms: $('hud-life-forms'),
                    lifeEnergy: $('hud-life-energy'), shipVel: $('hud-ship-vel'),
                    shipAlt: $('hud-ship-alt'), shipGrav: $('hud-ship-grav'),
                    aiState: $('hud-ai-state'), aiInteraction: $('hud-ai-interaction'),
                },
                
                galaxyHUD: $('galaxy-hud'),
                shipHUD: $('ship-hud'),
                aiHUD: $('ai-hud'),
            };
        }

        initEngine() {
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 150000);
            this.camera.position.set(0, 0, 3500);
            
            this.renderer = new THREE.WebGLRenderer({
                canvas: $('main-canvas'),
                antialias: true,
                powerPreference: 'high-performance',
                logarithmicDepthBuffer: true
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            this.renderer.outputEncoding = THREE.sRGBEncoding;
            this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            
            this.orbitControls = new OrbitControls(this.camera, this.renderer.domElement);
            this.orbitControls.enableDamping = true;
            this.pointerLockControls = new PointerLockControls(this.camera, this.renderer.domElement);
            
            this.composer = new EffectComposer(this.renderer);
            this.composer.addPass(new RenderPass(this.scene, this.camera));
            this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.8, 0.85);
            this.composer.addPass(this.bloomPass);
            this.afterimagePass = new AfterimagePass(0.85);
            this.afterimagePass.enabled = false;
            this.composer.addPass(this.afterimagePass);

            this.audio = new AudioManager(this.ui.audioToggle, this.ui.audioStatus);
            this.solarSystem = new SolarSystemManager(this.scene);
            this.singularity = new Singularity(this.scene);
            this.cosmos = new CosmosParticleSystem(this.scene);
            this.aiLife = new AILifeParticleSystem(this.scene);
            this.spaceship = new SpaceshipController(this.scene);
            this.aiModel = new QuantumAIModel();
            this.particlizer = new Particlizer(this.scene);

            window.addEventListener('resize', this.onResize.bind(this));
            window.addEventListener('mousedown', this.onMouseDown.bind(this));
            window.addEventListener('mouseup', this.onMouseUp.bind(this));
            window.addEventListener('mousemove', this.onMouseMove.bind(this));
            document.addEventListener('keydown', (e) => this.spaceship.keys[e.code] = true);
            document.addEventListener('keyup', (e) => this.spaceship.keys[e.code] = false);
        }

        bindUI() {
            Object.keys(this.physicsParams).forEach(p => {
                const input = $(`in-${p}`);
                const valueDisplay = $(`val-${p}`);
                input.addEventListener('input', () => {
                    this.physicsParams[p] = parseFloat(input.value);
                    valueDisplay.textContent = this.physicsParams[p].toFixed(p === 'li' ? 3 : 2);
                });
            });
            
            this.ui.startButton.addEventListener('click', this.start.bind(this));
            this.ui.anewButton.addEventListener('click', this.reset.bind(this));
            this.ui.directiveButton.addEventListener('click', this.activateDirectivePrime.bind(this));
            this.ui.regenerateButton.addEventListener('click', () => this.solarSystem.init());
            
            this.ui.tabs.forEach(tab => {
                tab.addEventListener("click", () => {
                    this.ui.tabs.forEach(t => t.classList.remove("active"));
                    this.ui.tabContents.forEach(tc => tc.classList.remove("active"));
                    tab.classList.add("active");
                    $(`tab-${tab.dataset.tab}`).classList.add("active");
                });
            });
            
            this.ui.viewModeSelect.addEventListener('change', (e) => this.setView(e.target.value));

            $('video-particlize-button').addEventListener('click', () => {
                // Simplified: needs camera access setup for this to fully work
                console.log("Live particlizer needs camera access logic to be implemented.");
            });
            $('file-upload').addEventListener('change', (e) => {
                if(e.target.files[0]) this.particlizer.particlize(e.target.files[0]);
            });
        }

        start() {
            if (this.isRunning) return;
            this.isRunning = true;
            this.ui.blocker.style.opacity = '0';
            setTimeout(() => this.ui.blocker.style.display = 'none', 500);
            
            this.solarSystem.init();
            this.cosmos.init(this.physicsParams);
            this.aiLife.init();
            
            this.animate();
        }
        
        reset() {
            window.location.reload();
        }

        activateDirectivePrime() {
            if (this.directivePrimeActive) return;
            this.setView('galaxy');
            this.directivePrimeActive = true;
            this.directiveState = 'supernova';
            this.directiveTimer = 0;
            this.orbitControls.enabled = false;
        }
        
        animate() {
            if (!this.isRunning && !this.directivePrimeActive) return;
            requestAnimationFrame(this.animate.bind(this));

            const dt = Math.min(this.clock.getDelta(), 0.1);
            const audioData = this.audio.getAnalysis();

            this.aiModel.learn({
                audio: audioData,
                ship: this.spaceship.getState(),
                galaxy: this.physicsParams,
                life: this.aiLife.getStats(),
            });
            const aiState = this.aiModel.update(dt);
            this.updateAIHUD(aiState);

            if (this.directivePrimeActive) {
                this.updateDirectivePrime(dt, audioData);
            } else {
                 this.updateSimulation(dt, audioData);
            }
            
            if (this.currentView === 'spaceship' || this.currentView === 'cockpit') {
                const celestialBodies = this.solarSystem.getCelestialBodies();
                this.spaceship.update(dt, celestialBodies);
                this.spaceship.updateCamera(this.camera);
                this.updateShipHUD();
            } else {
                this.orbitControls.update();
            }
            
            this.composer.render();
        }

        updateSimulation(dt, audioData) {
            this.physicsParams.ugrav = lerp(parseFloat($('in-ugrav').value), parseFloat($('in-ugrav').value) + audioData.bass * 2.5, 0.1);
            this.physicsParams.lambda = lerp(parseFloat($('in-lambda').value), parseFloat($('in-lambda').value) + audioData.mids * 1.5, 0.1);
            this.physicsParams.ec = lerp(parseFloat($('in-ec').value), parseFloat($('in-ec').value) + audioData.treble * 1.0, 0.1);

            this.singularity.update(this.physicsParams, this.isMouseDown);
            this.cosmos.update(dt, this.physicsParams, this.mouse, this.isMouseDown);
            this.aiLife.update(dt, audioData, this.mouse, this.isMouseDown);
            this.solarSystem.update(dt);
            this.particlizer.update(dt);

            this.updateGalaxyHUD(this.aiLife.getStats());
        }
        
        updateDirectivePrime(dt, audioData) {
            this.directiveTimer += dt;
            switch (this.directiveState) {
                case 'supernova':
                    this.physicsParams.ugrav = -10.0;
                    if (this.directiveTimer > 3) { this.directiveTimer = 0; this.directiveState = 'convergence'; }
                    break;
                case 'convergence':
                    this.physicsParams.ugrav = lerp(-10.0, 50.0, this.directiveTimer / 8);
                    if (this.directiveTimer > 8) { this.directiveTimer = 0; this.directiveState = 'crystal'; this.aiLife.formNeuralCrystal(); }
                    break;
                case 'crystal':
                    this.physicsParams.ugrav = 50.0;
                    if (this.directiveTimer > 10) { this.directiveTimer = 0; this.directiveState = 'final'; }
                    break;
                case 'final':
                    this.ui.blocker.style.display = 'flex';
                    this.ui.initialScreen.style.display = 'none';
                    this.ui.finalMessage.style.display = 'flex';
                    this.ui.blocker.style.opacity = '1';
                    this.directiveState = 'finished';
                    this.isRunning = false;
                    break;
            }
            this.singularity.update(this.physicsParams, false);
            this.cosmos.update(dt, this.physicsParams, this.mouse, false);
            this.aiLife.update(dt, audioData, this.mouse, false, this.directiveState === 'crystal');
        }
        
        updateGalaxyHUD(lifeStats) {
            this.ui.hud.influence.textContent = this.isMouseDown ? 'Active' : 'Idle';
            this.ui.hud.gravity.textContent = this.physicsParams.ugrav.toFixed(2);
            this.ui.hud.chaos.textContent = this.physicsParams.lambda.toFixed(2);
            this.ui.hud.energy.textContent = this.physicsParams.ec.toFixed(2);
            this.ui.hud.lifePop.textContent = lifeStats.population;
            this.ui.hud.lifeForms.textContent = lifeStats.formations;
            this.ui.hud.lifeEnergy.textContent = lifeStats.energy;
        }
        
        updateShipHUD() {
            const shipState = this.spaceship.getState();
            this.ui.hud.shipVel.textContent = `${shipState.velocity.toFixed(0)} km/s`;
            if (shipState.gravSource) {
                this.ui.hud.shipGrav.textContent = shipState.gravSource.name;
                this.ui.hud.shipAlt.textContent = `${shipState.altitude.toFixed(0)} km`;
            } else {
                this.ui.hud.shipGrav.textContent = 'Deep Space';
                this.ui.hud.shipAlt.textContent = 'N/A';
            }
        }

        updateAIHUD(aiState) {
            this.ui.hud.aiState.textContent = aiState.dominantState;
            this.ui.hud.aiInteraction.textContent = aiState.interaction;
        }

        setView(view) {
            this.currentView = view;
            
            const isGalaxy = view === 'galaxy';
            const isSolar = view === 'solar_system';
            const isShip = view === 'spaceship' || view === 'cockpit';

            this.solarSystem.show(isSolar || isShip);
            this.singularity.show(isGalaxy);
            this.cosmos.show(isGalaxy);
            this.aiLife.show(isGalaxy);
            this.spaceship.show(isShip);
            
            this.ui.galaxyHUD.style.display = isGalaxy ? 'block' : 'none';
            this.ui.shipHUD.style.display = isShip ? 'block' : 'none';

            this.orbitControls.enabled = isGalaxy || isSolar;
            if (isShip) {
                this.pointerLockControls.lock();
                this.spaceship.reset();
            } else {
                if(this.pointerLockControls.isLocked) this.pointerLockControls.unlock();
            }

            if (isGalaxy) {
                this.orbitControls.minDistance = 500;
                this.orbitControls.maxDistance = 10000;
                this.camera.position.set(0, 0, 3500);
                this.orbitControls.target.set(0, 0, 0);
                this.ui.actionText.textContent = 'Hold Left-Click to exert influence.';
            } else if (isSolar) {
                this.orbitControls.minDistance = 100;
                this.orbitControls.maxDistance = 20000;
                this.camera.position.set(0, 800, 2000);
                this.orbitControls.target.set(0, 0, 0);
                this.ui.actionText.textContent = 'Observe the procedurally generated system.';
            } else if (isShip) {
                 this.ui.actionText.textContent = 'W/S: Thrust | A/D: Yaw | Q/E: Roll | Mouse: Pitch/Yaw';
            }
        }
        
        onResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.composer.setSize(window.innerWidth, window.innerHeight);
        }
        onMouseDown(event) {
            if (event.button === 0) this.isMouseDown = true;
        }
        onMouseUp(event) {
            if (event.button === 0) this.isMouseDown = false;
        }
        onMouseMove(event) {
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            if (this.pointerLockControls.isLocked) {
                this.spaceship.handleMouseMove(event);
            }
        }
    }

    window.genesisApp = new Application();
</script>
</body>
</html>

