<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibraLight Cosmic Universe (CST v2 - Advanced)</title>
    
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 3. Load OrbitControls for 3D navigation -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        /* 4. Set Inter font and dark mode */
        html, body {
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        /* Custom scrollbar for control panel */
        ::-webkit-scrollbar {
            width: 5px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #718096; /* gray-500 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0; /* gray-400 */
        }
    </style>
    <!-- 5. Preload Inter font -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap">
</head>
<body>
    <!-- 6. Canvas for the 3D simulation -->
    <canvas id="simulationCanvas"></canvas>

    <!-- 7. Control Panel Overlay (Upgraded) -->
    <div class="absolute top-4 left-4 bg-gray-900 bg-opacity-80 backdrop-blur-md p-6 rounded-lg shadow-lg max-w-sm max-h-[95vh] overflow-y-auto">
        <h1 class="text-2xl font-bold text-white mb-4">VibraLight Cosmic Universe</h1>
        <p class="text-sm text-gray-300 mb-6">Based on Cosmic Synapse Theory v2. Drag to rotate. Scroll to zoom. Speak to drive cosmic chaos.</p>

        <!-- Mic Button -->
        <button id="toggleMicButton" class="w-full bg-cyan-500 hover:bg-cyan-400 text-black font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-md mb-4">
            Toggle VibraLight (Mic)
        </button>
        <div id="micStatus" class="text-center text-gray-400 text-xs mb-6">Mic OFF. Using Baseline Chaos.</div>

        <!-- Particle Controls -->
        <div class="grid grid-cols-2 gap-4 mb-2">
            <button id="addParticlesButton" class="bg-blue-600 hover:bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg transition-all">
                Add 10k 'Soul Dust'
            </button>
            <button id="clearParticlesButton" class="bg-red-700 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg transition-all">
                Clear 'Soul Dust'
            </button>
        </div>
        <div class="grid grid-cols-2 gap-4 mb-6">
            <button id="addAttractorButton" class="bg-purple-600 hover:bg-purple-500 text-white font-semibold py-2 px-4 rounded-lg transition-all">
                Add Black Hole
            </button>
            <button id="clearAllButton" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all">
                Clear Universe
            </button>
        </div>


        <!-- Simulation Parameters -->
        <div class="space-y-4">
            <!-- Swirl (Omega) -->
            <div>
                <label for="swirlSlider" class="block text-sm font-medium text-gray-200">Swirl ($\Omega$)</label>
                <input id="swirlSlider" type="range" min="0" max="1" step="0.01" value="0.3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="swirlValue" class="text-xs text-gray-400">0.3</span>
            </div>
            <!-- Gravity (G) -->
            <div>
                <label for="gravitySlider" class="block text-sm font-medium text-gray-200">Gravity ($G$)</label>
                <input id="gravitySlider" type="range" min="0" max="10000" step="100" value="3000" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="gravityValue" class="text-xs text-gray-400">3000</span>
            </div>
            <!-- Damping (zeta) -->
            <div>
                <label for="dampingSlider" class="block text-sm font-medium text-gray-200">Damping ($\zeta$)</label>
                <input id="dampingSlider" type="range" min="0.001" max="0.1" step="0.001" value="0.02" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="dampingValue" class="text-xs text-gray-400">0.02</span>
            </div>
            <!-- Baseline Chaos (lambda) -->
            <div>
                <label for="lambdaSlider" class="block text-sm font-medium text-gray-200">Baseline Chaos ($\lambda$)</label>
                <input id="lambdaSlider" type="range" min="0" max="20" step="0.1" value="3.0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="lambdaValue" class="text-xs text-gray-400">3.0</span>
            </div>
        </div>

        <!-- Debug Info -->
        <div class="mt-6 border-t border-gray-700 pt-4">
            <h3 class="text-lg font-semibold text-white mb-2">Live Data</h3>
            <div class="text-sm text-gray-300">
                <div>Attractors: <span id="attractorCount">0</span></div>
                <div>'Soul Dust' Particles: <span id="particleCount">0</span></div>
                <div>Avg. PSD (norm): <span id="psdValue">0.00</span></div>
                <div>Final Chaos ($\sigma$): <span id="sigmaValue">0.00</span></div>
            </div>
        </div>
    </div>
    
    <!-- 8. JavaScript Logic (Upgraded with Shaders and Multi-Attractor) -->
    
    <!-- 8a. GLSL Shader Code for 'Soul Dust' Particles -->
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vColor;
        void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            // Scale point size by distance to camera for perspective
            gl_PointSize = 150.0 / -mvPosition.z;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        void main() {
            // Create a soft, glowing circular point
            float d = distance(gl_PointCoord, vec2(0.5, 0.5));
            if (d > 0.5) discard; // Make it a circle
            // Fade out at the edges
            float alpha = 1.0 - d * 2.0;
            gl_FragColor = vec4(vColor, alpha);
        }
    </script>
    
    <!-- 8b. Main Simulation Script -->
    <script type="module">
        // === Setup: Canvas, 3D Scene, and State ===
        const canvas = document.getElementById('simulationCanvas');
        let width = window.innerWidth;
        let height = window.innerHeight;

        let scene, camera, renderer, controls, clock;
        let points; // The THREE.Points object for 'Soul Dust'
        let attractors = [];
        let attractorMeshes; // A THREE.Group to hold attractor visuals
        let particleCount = 0;

        // Particle data buffers
        let positions, velocities, colors;

        // Audio State (identical to before)
        let audioContext = null;
        let analyser = null;
        let micOn = false;
        let psdNormalized = 0.0;
        const micColor = new THREE.Color(); // For visual feedback

        // === Physics Parameters (from CST v2) ===
        const PHI = 1.618;
        const K_HARMONIC = 0.01; // $\alpha \Phi E_c$ combined
        const SOFTENING = 100; // $\epsilon^2$
        const SIGMA_LAMBDA = 1.0; // Multiplier for baseline chaos
        const SIGMA_PSD = 80.0; // Multiplier for mic-driven chaos (increased impact)
        const GALAXY_RADIUS = 2000; // Boundary for particles
        const PARTICLE_MASS = 1.0;
        const SWIRL_AXIS = new THREE.Vector3(0, 1, 0); // Swirl around Y axis

        // These are the *variables* controlled by sliders
        let G_CONST = 3000;
        let SWIRL_CONST = 0.3;
        let DAMPING = 0.02;
        let LAMBDA_CONST = 3.0;
        let SIGMA_FINAL = 0; // The final $\sigma$ used in physics
        
        // === Physics Helper Vectors ===
        const particlePos = new THREE.Vector3();
        const particleVel = new THREE.Vector3();
        const force = new THREE.Vector3();
        const f_harmonic = new THREE.Vector3();
        const f_grav = new THREE.Vector3();
        const f_swirl = new THREE.Vector3();
        const f_damp = new THREE.Vector3();
        const f_noise = new THREE.Vector3();
        const accel = new THREE.Vector3();

        // === 3D Scene Initialization ===
        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.001); // Add fog for depth
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 10000);
            camera.position.set(0, 400, 900);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(width, height);

            // Need THREE.OrbitControls from the script tag
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 5000;

            // Group to hold attractor visuals
            attractorMeshes = new THREE.Group();
            scene.add(attractorMeshes);

            // Add the central attractor
            addAttractor(new THREE.Vector3(0, 0, 0), 1000, true);
            
            // Initial particle setup
            addParticles(10000); // Start with 10k particles
        }
        
        // === NEW: Add Attractor Function ===
        function addAttractor(position, mass, isCentral = false) {
            attractors.push({ pos: position, mass: mass });
            
            const geometry = new THREE.SphereGeometry(isCentral ? 10 : 7, 32, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: isCentral ? 0xffffff : 0xff00ff, // Central is white, others are magenta
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });
            const attractorMesh = new THREE.Mesh(geometry, material);
            attractorMesh.position.copy(position);
            
            attractorMeshes.add(attractorMesh);
        }

        // === Particle & Attractor Setup ===
        function setupParticles() {
            // If points object exists, remove it from scene
            if (points) {
                scene.remove(points);
                points.geometry.dispose();
                points.material.dispose();
            }
            
            if (particleCount === 0) return; // Nothing to draw

            // Create new buffers
            positions = new Float32Array(particleCount * 3);
            velocities = new Float32Array(particleCount * 3);
            colors = new Float32Array(particleCount * 3);

            const color = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
                // Initial position (spherical shell)
                const r = Math.random() * GALAXY_RADIUS * 0.5 + 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1); // Spherical distribution
                
                positions[i * 3] = Math.sin(phi) * Math.cos(theta) * r;
                positions[i * 3 + 1] = Math.cos(phi) * r;
                positions[i * 3 + 2] = Math.sin(phi) * Math.sin(theta) * r;

                // Initial velocity
                velocities[i * 3] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
                
                // Color
                color.setHSL(Math.random(), 1.0, 0.75); // Vibrant colors
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // === NEW: ShaderMaterial for glowing particles ===
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: new THREE.TextureLoader().load( 'https://threejs.org/examples/textures/sprites/spark1.png' ) } // Fallback, but fragment shader is better
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false, // For better blending
                vertexColors: true
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
        }

        // === Physics Update (Now supports Multi-Attractor) ===
        function updatePhysics(dt) {
            if (particleCount === 0) return;

            const posAttr = points.geometry.getAttribute('position');
            const velAttr = points.geometry.getAttribute('velocity');

            for (let i = 0; i < particleCount; i++) {
                particlePos.fromArray(posAttr.array, i * 3);
                particleVel.fromArray(velAttr.array, i * 3);
                force.set(0, 0, 0);

                // --- NEW: Iterate over ALL attractors ---
                for (const a of attractors) {
                    // 1. F_cons = F_harmonic + F_grav
                    f_harmonic.subVectors(particlePos, a.pos); 
                    
                    const r_sq = f_harmonic.lengthSq();
                    const r_sq_eps = r_sq + SOFTENING;
                    const r = Math.sqrt(r_sq_eps);
                    const r_cubed = r_sq_eps * r;

                    const f_grav_mag = -(G_CONST * a.mass * PARTICLE_MASS) / r_cubed;
                    f_grav.copy(f_harmonic).multiplyScalar(f_grav_mag);

                    f_harmonic.multiplyScalar(-K_HARMONIC);
                    
                    // 2. F_swirl = k_omega * R * (x - x0)
                    f_swirl.crossVectors(f_harmonic, SWIRL_AXIS).multiplyScalar(SWIRL_CONST * (a.mass / 1000)); // Swirl stronger near heavy objects

                    force.add(f_harmonic).add(f_grav).add(f_swirl);
                }

                // 3. F_damp = -zeta * velocity
                f_damp.copy(particleVel).multiplyScalar(-DAMPING);
                force.add(f_damp);

                // 4. F_noise = sigma * random_vec
                f_noise.set(
                    (Math.random() - 0.5), 
                    (Math.random() - 0.5), 
                    (Math.random() - 0.5)
                ).multiplyScalar(SIGMA_FINAL);
                force.add(f_noise);

                // --- Apply Forces (Integration) ---
                accel.copy(force).divideScalar(PARTICLE_MASS);
                particleVel.add(accel.multiplyScalar(dt));
                particlePos.add(particleVel.multiplyScalar(dt));

                // --- NEW: Boundary (Recycle at center) ---
                if (particlePos.lengthSq() > GALAXY_RADIUS * GALAXY_RADIUS) {
                   // Re-spawn near center, like a galactic fountain
                   particlePos.set(
                       (Math.random() - 0.5) * 20,
                       (Math.random() - 0.5) * 20,
                       (Math.random() - 0.5) * 20
                   );
                   particleVel.set(
                       (Math.random() - 0.5) * 0.1,
                       (Math.random() - 0.5) * 0.1,
                       (Math.random() - 0.5) * 0.1
                   );
                }

                posAttr.setXYZ(i, particlePos.x, particlePos.y, particlePos.z);
                velAttr.setXYZ(i, particlePos.x, particlePos.y, particleVel.z);
            }
            
            posAttr.needsUpdate = true;
            velAttr.needsUpdate = true;
        }

        // === Control Panel and UI ===
        const toggleMicButton = document.getElementById('toggleMicButton');
        const micStatus = document.getElementById('micStatus');
        const addParticlesButton = document.getElementById('addParticlesButton');
        const clearParticlesButton = document.getElementById('clearParticlesButton');
        const addAttractorButton = document.getElementById('addAttractorButton');
        const clearAllButton = document.getElementById('clearAllButton');
        
        const swirlSlider = document.getElementById('swirlSlider');
        const gravitySlider = document.getElementById('gravitySlider');
        const dampingSlider = document.getElementById('dampingSlider');
        const lambdaSlider = document.getElementById('lambdaSlider');
        
        const swirlValue = document.getElementById('swirlValue');
        const gravityValue = document.getElementById('gravityValue');
        const dampingValue = document.getElementById('dampingValue');
        const lambdaValue = document.getElementById('lambdaValue');
        
        const uiParticleCount = document.getElementById('particleCount');
        const uiAttractorCount = document.getElementById('attractorCount');
        const psdValue = document.getElementById('psdValue');
        const sigmaValue = document.getElementById('sigmaValue');

        // Event Listeners for Controls
        toggleMicButton.addEventListener('click', initAudio);
        
        addParticlesButton.addEventListener('click', () => {
            addParticles(10000); // Add 10k particles
        });
        clearParticlesButton.addEventListener('click', () => {
            particleCount = 0;
            setupParticles();
        });
        
        addAttractorButton.addEventListener('click', () => {
            const pos = new THREE.Vector3(
                (Math.random() - 0.5) * GALAXY_RADIUS,
                (Math.random() - 0.5) * (GALAXY_RADIUS * 0.2), // Flatter distribution
                (Math.random() - 0.5) * GALAXY_RADIUS
            );
            const mass = Math.random() * 2000 + 500; // Random mass
            addAttractor(pos, mass, false);
        });
        
        clearAllButton.addEventListener('click', () => {
            // Clear particles
            particleCount = 0;
            setupParticles();
            
            // Clear attractors (except central one)
            attractors = [attractors[0]]; // Keep central
            // Remove meshes
            for (let i = attractorMeshes.children.length - 1; i > 0; i--) {
                attractorMeshes.remove(attractorMeshes.children[i]);
            }
        });


        swirlSlider.addEventListener('input', (e) => {
            SWIRL_CONST = parseFloat(e.target.value);
            swirlValue.textContent = SWIRL_CONST.toFixed(2);
        });
        gravitySlider.addEventListener('input', (e) => {
            G_CONST = parseFloat(e.target.value);
            gravityValue.textContent = G_CONST.toFixed(0);
        });
        dampingSlider.addEventListener('input', (e) => {
            DAMPING = parseFloat(e.target.value);
            dampingValue.textContent = DAMPING.toFixed(3);
        });
        lambdaSlider.addEventListener('input', (e) => {
            LAMBDA_CONST = parseFloat(e.target.value);
            lambdaValue.textContent = LAMBDA_CONST.toFixed(1);
        });

        // === Helper Functions ===
        function addParticles(count) {
            particleCount += count;
            setupParticles(); // Rebuild the geometry
        }

        // Handle window resizing
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        // === Audio Logic (VibraLight / Stochastic Resonance) ===
        // This logic is identical to the 2D version.
        function initAudio() {
            if (micOn) {
                // Turn off
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
                micOn = false;
                analyser = null;
                micStatus.textContent = "Mic OFF. Using Baseline Chaos.";
                toggleMicButton.classList.remove('bg-red-600', 'hover:bg-red-500');
                toggleMicButton.classList.add('bg-cyan-500', 'hover:bg-cyan-400');
                psdNormalized = 0;
            } else {
                // Turn on - Request permission
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        micOn = true;
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        analyser = audioContext.createAnalyser();
                        const source = audioContext.createMediaStreamSource(stream);
                        source.connect(analyser);
                        
                        analyser.fftSize = 256;
                        analyser.smoothingTimeConstant = 0.3;
                        
                        micStatus.textContent = "Mic ON. Driving chaos with PSD.";
                        toggleMicButton.classList.add('bg-red-600', 'hover:bg-red-500');
                        toggleMicButton.classList.remove('bg-cyan-500', 'hover:bg-cyan-400');
                    })
                    .catch(err => {
                        console.error('Microphone access denied:', err);
                        micStatus.textContent = "Mic access denied. Using Baseline Chaos.";
                        micOn = false;
                    });
            }
        }

        function updateSigma() {
            if (micOn && analyser) {
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Float32Array(bufferLength);
                analyser.getFloatFrequencyData(dataArray);

                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const normalized_db = (dataArray[i] + 100) / 100;
                    sum += normalized_db * normalized_db; // Use power (amplitude squared)
                }
                const avgPower = sum / bufferLength;
                
                psdNormalized = Math.min(avgPower * 5, 1.0); 
                SIGMA_FINAL = SIGMA_PSD * psdNormalized;
                
                psdValue.textContent = psdNormalized.toFixed(2);
            } else {
                SIGMA_FINAL = SIGMA_LAMBDA * LAMBDA_CONST;
                psdValue.textContent = "N/A";
            }
            sigmaValue.textContent = SIGMA_FINAL.toFixed(2);
        }

        // === Main Animation Loop ===
        function animate() {
            requestAnimationFrame(animate); // Loop
            
            const dt = clock.getDelta() * 10; // Get time delta and scale it
            
            updateSigma(); // Update chaos from mic or slider
            
            if(particleCount > 0) {
                updatePhysics(dt); // Update all particle positions
            }
            
            controls.update(); // Update 3D camera controls
            renderer.render(scene, camera); // Render the scene

            // === NEW: Visual Feedback for Mic Input ===
            if (attractorMeshes.children.length > 0) {
                const centralAttractorMesh = attractorMeshes.children[0];
                // Hue: 0.7 (blue) -> 0.0 (red)
                const hue = 0.7 - (psdNormalized * 0.7);
                micColor.setHSL(hue, 1.0, 0.7);
                centralAttractorMesh.material.color = micColor;
            }

            // Update UI Stats
            uiParticleCount.textContent = particleCount.toLocaleString();
            uiAttractorCount.textContent = attractors.length;
        }

        // === Initialization ===
        function init() {
            init3D();
            
            // Set initial slider values
            swirlValue.textContent = SWIRL_CONST.toFixed(2);
            gravityValue.textContent = G_CONST.toFixed(0);
            dampingValue.textContent = DAMPING.toFixed(3);
            lambdaValue.textContent = LAMBDA_CONST.toFixed(1);

            animate();
        }

        init();
    </script>
</body>
</html>


