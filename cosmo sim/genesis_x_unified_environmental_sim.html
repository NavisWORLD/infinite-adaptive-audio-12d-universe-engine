<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Genesis X ‚Äî Unified Environmental Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        /* Inline Tailwind-like utilities for production */
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .justify-between { justify-content: space-between; }
        .flex-wrap { flex-wrap: wrap; }
        .gap-2 { gap: 0.5rem; }
        .gap-3 { gap: 0.75rem; }
        .top-3 { top: 0.75rem; }
        .left-3 { left: 0.75rem; }
        .right-3 { right: 0.75rem; }
        .w-400 { width: 400px; }
        .max-w-xl { max-width: 36rem; }
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 0.75rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .px-8 { padding-left: 2rem; padding-right: 2rem; }
        .mt-1 { margin-top: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mt-3 { margin-top: 0.75rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
        .text-4xl { font-size: 2.25rem; line-height: 2.5rem; }
        .font-bold { font-weight: 700; }
        .font-semibold { font-weight: 600; }
        .font-light { font-weight: 300; }
        .text-slate-100 { color: #f1f5f9; }
        .text-slate-400 { color: #94a3b8; }
        .rounded { border-radius: 0.5rem; }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.08);
            background: linear-gradient(180deg, #1a1d2a 0%, #131726 100%);
            color: #e7e9f2;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(255,255,255,0.05); }
        .btn.primary { border-color: rgba(124,156,255,0.45); box-shadow: 0 0 0 3px rgba(124,156,255,0.09); }
        .btn.success { border-color: #10b981; color: #10b981; }
        .btn.danger { border-color: #ef4444; color: #ef4444; }
        .btn.cyber { border-color: #00ffff; color: #00ffff; }
        .hidden { display: none; }
    </style>
    <style>
        :root {
            --panel: rgba(14,17,26,.92);
            --border: rgba(124,156,255,.10);
            --bg: #07080c;
            --text: #e7e9f2;
            --muted: #9aa4b2;
            --acc: #7c9cff;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --cyber: #00ffff;
            --purple: #a855f7;
            --pink: #ec4899;
        }

        html,body {
            height:100%;
            margin:0;
            background:var(--bg);
            color:var(--text);
            font-family: 'Inter', system-ui, sans-serif;
            overflow:hidden;
        }

        canvas { display:block; position:fixed; inset:0; }

        .ui-panel {
            position:fixed;
            z-index:20;
            background:var(--panel);
            border:1px solid var(--border);
            border-radius:12px;
            box-shadow:0 10px 30px rgba(0,0,0,.35);
            backdrop-filter:blur(8px);
        }

        .btn {
            display:inline-flex;
            align-items:center;
            justify-content:center;
            gap:8px;
            padding:8px 12px;
            border-radius:8px;
            border:1px solid rgba(255,255,255,0.08);
            background:linear-gradient(180deg, #1a1d2a 0%, #131726 100%);
            color:var(--text);
            cursor:pointer;
            user-select:none;
            transition: all 0.2s;
        }

        .btn:hover { background: rgba(255,255,255,0.05); }
        .btn.primary { border-color:rgba(124,156,255,0.45); box-shadow:0 0 0 3px rgba(124,156,255,0.09); }
        .btn.success { border-color:var(--success); color:var(--success); }
        .btn.danger { border-color:var(--danger); color:var(--danger); }
        .btn.cyber { border-color:var(--cyber); color:var(--cyber); }

        .group {
            margin:12px 0;
            padding:10px;
            border-radius:10px;
            background:rgba(11,13,20,.5);
            box-shadow:inset 0 0 0 1px rgba(255,255,255,0.05);
        }

        h3 {
            margin:0 0 8px;
            font-size:13px;
            color:#d3dbef;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        label {
            display:block;
            font-size:12px;
            color:var(--muted);
            margin-bottom:4px;
        }

        .row {
            display:grid;
            grid-template-columns:1fr 70px;
            gap:8px;
            align-items:center;
            margin:8px 0;
        }

        .val {
            text-align:right;
            color:#cfd6e6;
            font-variant-numeric:tabular-nums;
            font-size:12px;
        }

        .small {
            font-size:12px;
            color:var(--muted);
        }

        input[type="range"]{
            -webkit-appearance:none;
            appearance:none;
            width:100%;
            height:4px;
            background:rgba(255,255,255,0.1);
            border-radius:999px;
        }

        input[type="range"]::-webkit-slider-thumb{
            -webkit-appearance:none;
            appearance:none;
            width:16px;
            height:16px;
            background:var(--acc);
            border:2px solid var(--panel);
            border-radius:50%;
        }

        /* Tab System */
        .tab-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .tab-buttons {
            display: flex;
            gap: 2px;
            margin-bottom: 12px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 8px;
        }

        .tab-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255,255,255,0.05);
            border: 1px solid transparent;
            border-radius: 6px 6px 0 0;
            color: var(--muted);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .tab-btn.active {
            background: var(--panel);
            border-color: var(--border);
            color: var(--acc);
        }

        .tab-btn:hover {
            background: rgba(255,255,255,0.08);
            color: var(--text);
        }

        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 4px 0;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        /* Special Elements */
        #crosshair {
            position:fixed;
            left:50%;
            top:50%;
            width:18px;
            height:18px;
            margin-left:-9px;
            margin-top:-9px;
            border-radius:50%;
            box-shadow:0 0 0 2px rgba(255,255,255,0.22);
            pointer-events:none;
            opacity:0;
            transition:opacity .2s ease;
        }

        #blocker {
            position:fixed;
            inset:0;
            z-index:100;
            background:rgba(0,0,0,.86);
            display:flex;
            justify-content:center;
            align-items:center;
            flex-direction:column;
            text-align:center;
        }

        .panel {
            right:12px;
            bottom:12px;
            max-width: 420px;
            padding:12px;
        }

        .grid{
            display:grid;
            grid-template-columns:auto 1fr;
            column-gap:10px;
            row-gap:6px;
            font-family:ui-monospace, monospace;
            font-size:12px;
        }

        .k{color:#9db8ff}
        .v{color:#cfe8ff; text-align:right}

        .close-x{
            position:absolute;
            right:8px;
            top:6px;
            border:0;
            background:transparent;
            color:#9db8ff;
            font-weight:700;
            cursor:pointer;
        }

        .hidden{display:none}

        /* God-Tier Leveling */
        .level-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--cyber);
            color: black;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
            margin: 4px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--cyber);
            transition: width 0.3s ease;
        }

        /* Environmental Effects */
        .weather-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .rain-particle {
            position: absolute;
            width: 1px;
            height: 20px;
            background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.6));
            animation: rain-fall 0.5s linear infinite;
        }

        @keyframes rain-fall {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(100vh); opacity: 1; }
        }

        /* VR Indicator */
        .vr-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: var(--cyber);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            display: none;
        }
    </style>

    <script type="importmap">
        { "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    
    <!-- Fallback Three.js CDN -->
    <script>
        // Fallback for Three.js if module loading fails
        if (typeof THREE === 'undefined') {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/three@0.160.0/build/three.min.js';
            script.onload = () => {
                console.log('‚úÖ Three.js loaded via fallback CDN');
            };
            script.onerror = () => {
                console.error('‚ùå Failed to load Three.js from CDN');
                document.body.innerHTML = `
                    <div style="display: flex; justify-content: center; align-items: center; height: 100vh; background: #0a0a0a; color: #ff6b6b; font-family: monospace; text-align: center;">
                        <div>
                            <h1>Three.js Loading Failed</h1>
                            <p>Unable to load Three.js library. Please check your internet connection.</p>
                        </div>
                    </div>
                `;
            };
            document.head.appendChild(script);
        }
    </script>
</head>

<body>
    <!-- MAIN UI PANEL -->
    <div id="main-ui" class="ui-panel top-3 left-3 w-[420px] h-[calc(100vh-24px)]">
        <div class="flex items-center justify-between mb-3">
            <div>
                <div class="text-sm text-cyan-400">Genesis X</div>
                <div class="text-lg font-semibold">Environmental Sim</div>
            </div>
            <div class="level-indicator" id="godLevel">Level 1</div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="levelProgress" style="width: 0%"></div>
        </div>

        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="core">Core</button>
                <button class="tab-btn" data-tab="physics">Physics</button>
                <button class="tab-btn" data-tab="environment">Environment</button>
                <button class="tab-btn" data-tab="ai">AI Creator</button>
                <button class="tab-btn" data-tab="controls">Controls</button>
                <button class="tab-btn" data-tab="advanced">Advanced</button>
            </div>

            <div class="tab-content">
                <!-- CORE TAB -->
                <div class="tab-panel active" id="core-tab">
                    <div class="group">
                        <h3>Session Control</h3>
                        <div class="flex gap-2 flex-wrap">
                            <button id="btnStart" class="btn primary">Initiate Universe</button>
                            <button id="btnReset" class="btn">Reset</button>
                            <button id="btnSave" class="btn success">Save State</button>
                            <button id="btnLoad" class="btn cyber">Load State</button>
                        </div>
                        <div class="flex gap-3 items-center mt-2">
                            <label class="small flex items-center gap-2">
                                <input id="toggleAudio" type="checkbox" checked />
                                Soul Audio
                            </label>
                            <label class="small flex items-center gap-2">
                                <input id="toggleVR" type="checkbox" />
                                WebXR VR
                            </label>
                        </div>
                        <div id="audioStatus" class="small mt-2">Audio: Initializing...</div>
                    </div>

                    <div class="group">
                        <h3>View Mode</h3>
                        <div class="flex gap-2 flex-wrap">
                            <button id="btnOrbit" class="btn primary">Galaxy Orbit</button>
                            <button id="btnShip" class="btn">Spaceship</button>
                            <button id="btnSurface" class="btn">Planet Surface</button>
                            <button id="btnCloudFP" class="btn">Cloud First-Person</button>
                            <button id="btnVoid" class="btn">Void Walker</button>
                        </div>
                        <p class="small mt-2">
                            <b>Movement:</b> WASD+QE ‚Ä¢ Shift=Boost ‚Ä¢ Mouse=Look<br>
                            <b>Special:</b> M=Lamp ‚Ä¢ R/F=Roll ‚Ä¢ Space=Jump
                        </p>
                    </div>
                </div>

                <!-- PHYSICS TAB -->
                <div class="tab-panel" id="physics-tab">
                    <div class="group">
                        <h3>Unified Master Formula (Œ®)</h3>
                        <div class="row">
                            <label>Energy Scaling (Ec)</label>
                            <div id="ecVal" class="val">1.2</div>
                            <input id="ec" type="range" min="0.2" max="4.0" step="0.1" value="1.2" />
                        </div>
                        <div class="row">
                            <label>Chaos Factor (Œª)</label>
                            <div id="lambdaVal" class="val">0.25</div>
                            <input id="lambda" type="range" min="0.0" max="1.0" step="0.01" value="0.25" />
                        </div>
                        <div class="row">
                            <label>Motion Damping (Œ∂)</label>
                            <div id="liVal" class="val">0.985</div>
                            <input id="li" type="range" min="0.9" max="1.0" step="0.001" value="0.985" />
                        </div>
                        <div class="row">
                            <label>Spectral Hue (Œ©)</label>
                            <div id="omegaVal" class="val">0.62</div>
                            <input id="omega" type="range" min="0.0" max="1.0" step="0.01" value="0.62" />
                        </div>
                        <div class="row">
                            <label>Gravitational Strength (U)</label>
                            <div id="ugravVal" class="val">0.55</div>
                            <input id="ugrav" type="range" min="0.0" max="2.0" step="0.01" value="0.55" />
                        </div>
                    </div>

                    <div class="group">
                        <h3>Particle System</h3>
                        <div class="row">
                            <label>Particle Count</label>
                            <div id="particleCountVal" class="val">50K</div>
                            <input id="particleCount" type="range" min="10000" max="200000" step="5000" value="50000" />
                        </div>
                        <div class="row">
                            <label>Attractor Strength</label>
                            <div id="attractorStrengthVal" class="val">1.0</div>
                            <input id="attractorStrength" type="range" min="0.1" max="5.0" step="0.1" value="1.0" />
                        </div>
                        <div class="row">
                            <label>Time Scale</label>
                            <div id="timeScaleVal" class="val">1.0</div>
                            <input id="timeScale" type="range" min="0.1" max="3.0" step="0.1" value="1.0" />
                        </div>
                    </div>
                </div>

                <!-- ENVIRONMENT TAB -->
                <div class="tab-panel" id="environment-tab">
                    <div class="group">
                        <h3>Atmospheric Conditions</h3>
                        <div class="row">
                            <label>Weather Intensity</label>
                            <div id="weatherVal" class="val">0.5</div>
                            <input id="weatherIntensity" type="range" min="0.0" max="1.0" step="0.01" value="0.5" />
                        </div>
                        <div class="row">
                            <label>Cloud Density</label>
                            <div id="cloudDensityVal" class="val">0.3</div>
                            <input id="cloudDensity" type="range" min="0.0" max="1.0" step="0.01" value="0.3" />
                        </div>
                        <div class="row">
                            <label>Ocean Roughness</label>
                            <div id="oceanRoughnessVal" class="val">0.05</div>
                            <input id="oceanRoughness" type="range" min="0.0" max="0.5" step="0.01" value="0.05" />
                        </div>
                        <div class="row">
                            <label>Wind Strength</label>
                            <div id="windStrengthVal" class="val">0.2</div>
                            <input id="windStrength" type="range" min="0.0" max="1.0" step="0.01" value="0.2" />
                        </div>
                    </div>

                    <div class="group">
                        <h3>Time & Lighting</h3>
                        <div class="row">
                            <label>Time of Day</label>
                            <div id="timeOfDayVal" class="val">12:00</div>
                            <input id="timeOfDay" type="range" min="0" max="24" step="0.5" value="12" />
                        </div>
                        <div class="row">
                            <label>Season</label>
                            <div id="seasonVal" class="val">Spring</div>
                            <input id="season" type="range" min="0" max="3" step="1" value="0" />
                        </div>
                        <div class="row">
                            <label>Light Intensity</label>
                            <div id="lightIntensityVal" class="val">1.0</div>
                            <input id="lightIntensity" type="range" min="0.1" max="2.0" step="0.1" value="1.0" />
                        </div>
                    </div>

                    <div class="group">
                        <h3>Biomes & Vegetation</h3>
                        <div class="row">
                            <label>Vegetation Density</label>
                            <div id="vegetationVal" class="val">0.8</div>
                            <input id="vegetationDensity" type="range" min="0.0" max="1.0" step="0.01" value="0.8" />
                        </div>
                        <div class="row">
                            <label>Biome Diversity</label>
                            <div id="biomeVal" class="val">0.6</div>
                            <input id="biomeDiversity" type="range" min="0.0" max="1.0" step="0.01" value="0.6" />
                        </div>
                        <div class="row">
                            <label>Life Forms</label>
                            <div id="lifeFormsVal" class="val">0.4</div>
                            <input id="lifeForms" type="range" min="0.0" max="1.0" step="0.01" value="0.4" />
                        </div>
                    </div>
                </div>

                <!-- AI CREATOR TAB -->
                <div class="tab-panel" id="ai-tab">
                    <div class="group">
                        <h3>Sentient AI</h3>
                        <div class="flex gap-2 flex-wrap">
                            <button id="btnSpawnStar" class="btn">Create Star</button>
                            <button id="btnSpawnPlanet" class="btn">Create Planet</button>
                            <button id="btnSpawnEarth" class="btn">Earth-like</button>
                            <button id="btnSpawnGasGiant" class="btn">Gas Giant</button>
                            <button id="btnSpawnBlackHole" class="btn">Black Hole</button>
                            <button id="btnSpawnMoon" class="btn">Create Moon</button>
                            <button id="btnSpawnAsteroid" class="btn">Asteroid Field</button>
                        </div>
                        <div id="aiStatus" class="small mt-2 p-2" style="background:rgba(0,0,0,.2); border-radius:8px">
                            AI: Analyzing environmental data...
                        </div>
                    </div>

                    <div class="group">
                        <h3>Neural Crystal</h3>
                        <div class="flex gap-2 flex-wrap">
                            <button id="btnCreateCrystal" class="btn cyber">Forge Crystal</button>
                            <button id="btnBindData" class="btn success">Bind Soul Data</button>
                            <button id="btnEvolve" class="btn danger">Evolve Universe</button>
                        </div>
                        <div id="crystalStatus" class="small mt-2">
                            Neural Network: Dormant
                        </div>
                    </div>

                    <div class="group">
                        <h3>AI Evolution</h3>
                        <div class="row">
                            <label>Consciousness Level</label>
                            <div id="consciousnessVal" class="val">0.1</div>
                            <input id="consciousness" type="range" min="0.0" max="1.0" step="0.01" value="0.1" />
                        </div>
                        <div class="row">
                            <label>Creativity</label>
                            <div id="creativityVal" class="val">0.3</div>
                            <input id="creativity" type="range" min="0.0" max="1.0" step="0.01" value="0.3" />
                        </div>
                        <div class="row">
                            <label>Adaptability</label>
                            <div id="adaptabilityVal" class="val">0.2</div>
                            <input id="adaptability" type="range" min="0.0" max="1.0" step="0.01" value="0.2" />
                        </div>
                    </div>
                </div>

                <!-- CONTROLS TAB -->
                <div class="tab-panel" id="controls-tab">
                    <div class="group">
                        <h3>Camera Controls</h3>
                        <div class="flex gap-2 flex-wrap">
                            <button id="btnResetCamera" class="btn">Reset Position</button>
                            <button id="btnTopView" class="btn">Top View</button>
                            <button id="btnSideView" class="btn">Side View</button>
                            <button id="btnFollowObject" class="btn">Follow Selected</button>
                        </div>
                        <div class="row">
                            <label>Camera Speed</label>
                            <div id="cameraSpeedVal" class="val">1.0</div>
                            <input id="cameraSpeed" type="range" min="0.1" max="5.0" step="0.1" value="1.0" />
                        </div>
                        <div class="row">
                            <label>FOV</label>
                            <div id="fovVal" class="val">75¬∞</div>
                            <input id="fov" type="range" min="30" max="120" step="5" value="75" />
                        </div>
                    </div>

                    <div class="group">
                        <h3>Interaction Modes</h3>
                        <div class="flex gap-2 flex-wrap">
                            <button id="btnInfluence" class="btn">Gravity Influence</button>
                            <button id="btnTerraform" class="btn">Terraform</button>
                            <button id="btnScan" class="btn">Scan Environment</button>
                            <button id="btnTeleport" class="btn">Teleport</button>
                        </div>
                        <p class="small mt-2">
                            <b>Influence Mode:</b> Left-click to attract particles<br>
                            <b>Terraform:</b> Modify terrain and atmosphere<br>
                            <b>Scan:</b> Analyze celestial objects
                        </p>
                    </div>

                    <div class="group">
                        <h3>God Powers</h3>
                        <div class="flex gap-2 flex-wrap">
                            <button id="btnSupernova" class="btn danger">Trigger Supernova</button>
                            <button id="btnBigBang" class="btn cyber">New Big Bang</button>
                            <button id="btnTimeControl" class="btn">Time Control</button>
                            <button id="btnRealityBend" class="btn purple">Reality Bend</button>
                        </div>
                        <div id="powerStatus" class="small mt-2">
                            Divine Energy: 100%
                        </div>
                    </div>
                </div>

                <!-- ADVANCED TAB -->
                <div class="tab-panel" id="advanced-tab">
                    <div class="group">
                        <h3>Rendering</h3>
                        <div class="flex gap-3 items-center">
                            <label class="small flex items-center gap-2">
                                <input id="toggleBloom" type="checkbox" checked />
                                Bloom Effects
                            </label>
                            <label class="small flex items-center gap-2">
                                <input id="toggleShadows" type="checkbox" />
                                Dynamic Shadows
                            </label>
                            <label class="small flex items-center gap-2">
                                <input id="toggleParticles" type="checkbox" checked />
                                Particle System
                            </label>
                        </div>
                        <div class="row">
                            <label>Quality Level</label>
                            <div id="qualityVal" class="val">High</div>
                            <input id="quality" type="range" min="1" max="4" step="1" value="3" />
                        </div>
                        <div class="row">
                            <label>LOD Distance</label>
                            <div id="lodVal" class="val">1000</div>
                            <input id="lodDistance" type="range" min="100" max="10000" step="100" value="1000" />
                        </div>
                    </div>

                    <div class="group">
                        <h3>Diagnostics</h3>
                        <div class="flex gap-2 flex-wrap">
                            <button id="btnScreenshot" class="btn">Screenshot</button>
                            <button id="btnRecord" class="btn">Record Session</button>
                            <button id="btnExport" class="btn">Export Data</button>
                            <button id="btnDebug" class="btn">Debug Mode</button>
                        </div>
                        <div id="debugInfo" class="small mt-2">
                            <div>FPS: <span id="debugFps">--</span></div>
                            <div>Objects: <span id="debugObjects">--</span></div>
                            <div>Memory: <span id="debugMemory">--</span> MB</div>
                        </div>
                    </div>

                    <div class="group">
                        <h3>God-Tier Progression</h3>
                        <div class="row">
                            <label>Experience Multiplier</label>
                            <div id="xpMultiplierVal" class="val">1.0x</div>
                            <input id="xpMultiplier" type="range" min="0.5" max="3.0" step="0.1" value="1.0" />
                        </div>
                        <div class="small mt-2">
                            <div>Level: <span id="currentLevel">1</span></div>
                            <div>Experience: <span id="currentXP">0</span> / <span id="nextLevelXP">1000</span></div>
                            <div>Divine Powers Unlocked: <span id="powersUnlocked">0</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- HUD PANEL -->
    <div id="hud" class="ui-panel top-3 right-3 text-sm p-3" style="font-family:ui-monospace, monospace; min-width: 300px;">
        <div class="flex justify-between items-center mb-2">
            <span>Genesis X HUD</span>
            <span id="hudTime">--:--</span>
        </div>
        <div>Mode: <b id="hudMode">Galaxy</b></div>
        <div>Chaos (Œª): <b id="hudChaos">0.25</b></div>
        <div>Audio PSD: <b id="hudPSD">0.000</b></div>
        <div>Objects: <b id="hudObjects">0</b></div>
        <div>FPS: <b id="hudFps">--</b></div>
        <div id="surface-hud" class="hidden mt-2">
            <div>Ocean Roughness: <b id="hudOcean">--</b></div>
            <div>Cloud Coverage: <b id="hudCloud">--%</b></div>
            <div>Vegetation: <b id="hudVeg">--%</b></div>
            <div>Wind: <b id="hudWind">--</b></div>
        </div>
        <div id="ai-hud" class="hidden mt-2">
            <div>AI Consciousness: <b id="hudConsciousness">--</b></div>
            <div>Creativity: <b id="hudCreativity">--</b></div>
            <div>Neural Links: <b id="hudNeural">--</b></div>
        </div>
    </div>

    <!-- PSI OVERLAY PANEL -->
    <div id="psiPanel" class="ui-panel panel hidden">
        <button class="close-x" id="psiClose">√ó</button>
        <h3>CST œà ‚Äî Live Mathematical Soul</h3>
        <div class="grid">
            <div class="k">c¬≤¬∑œÜ¬∑E_c</div><div class="v" id="vEc">‚Äì</div>
            <div class="k">Œª (chaos)</div><div class="v" id="vLam">‚Äì</div>
            <div class="k">L (history)</div><div class="v" id="vLen">‚Äì</div>
            <div class="k">Œ©¬∑E_c</div><div class="v" id="vOm">‚Äì</div>
            <div class="k">U_grav</div><div class="v" id="vGrav">‚Äì</div>
            <div class="k">Œ£œÅ_sd</div><div class="v" id="vRho">‚Äì</div>
            <div class="k">œà (total)</div><div class="v" id="vPsi">‚Äì</div>
            <div class="k">AI_consciousness</div><div class="v" id="vAI">‚Äì</div>
            <div class="k">Divine_power</div><div class="v" id="vDivine">‚Äì</div>
        </div>
    </div>

    <!-- F1-F5 CONTROL PANELS -->
    <div id="controlPanel" class="ui-panel panel hidden" style="top: 100px; left: 50px;">
        <button class="close-x" onclick="this.parentElement.classList.add('hidden')">√ó</button>
        <h3>Main Controls (F1)</h3>
        <div class="space-y-3">
            <div class="flex gap-2">
                <button id="btnStart" class="btn primary">Start Simulation</button>
                <button id="btnReset" class="btn danger">Reset</button>
            </div>
            <div class="flex gap-2">
                <button id="btnSave" class="btn">Save State</button>
                <button id="btnLoad" class="btn">Load State</button>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <button id="btnOrbit" class="btn">Orbit Mode</button>
                <button id="btnShip" class="btn">Ship Mode</button>
                <button id="btnSurface" class="btn">Surface Mode</button>
                <button id="btnCloudFP" class="btn">Cloud FP</button>
            </div>
        </div>
    </div>

    <div id="audioPanel" class="ui-panel panel hidden" style="top: 100px; right: 50px;">
        <button class="close-x" onclick="this.parentElement.classList.add('hidden')">√ó</button>
        <h3>Soul Dust Audio (F2)</h3>
        <div class="space-y-3">
            <div id="audioStatus" class="text-sm">Audio: Initializing...</div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="text-sm">Bass Energy</label>
                    <div id="bassLevel" class="w-full bg-gray-700 h-2 rounded">
                        <div class="bg-green-500 h-2 rounded" style="width: 0%"></div>
                    </div>
                </div>
                <div>
                    <label class="text-sm">Mids Energy</label>
                    <div id="midsLevel" class="w-full bg-gray-700 h-2 rounded">
                        <div class="bg-blue-500 h-2 rounded" style="width: 0%"></div>
                    </div>
                </div>
                <div>
                    <label class="text-sm">Treble Energy</label>
                    <div id="trebleLevel" class="w-full bg-gray-700 h-2 rounded">
                        <div class="bg-purple-500 h-2 rounded" style="width: 0%"></div>
                    </div>
                </div>
                <div>
                    <label class="text-sm">Overall Energy</label>
                    <div id="energyLevel" class="w-full bg-gray-700 h-2 rounded">
                        <div class="bg-yellow-500 h-2 rounded" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="text-xs text-gray-400">
                Speak into microphone to create cosmic energy
            </div>
        </div>
    </div>

    <div id="worldPanel" class="ui-panel panel hidden" style="top: 200px; left: 50px;">
        <button class="close-x" onclick="this.parentElement.classList.add('hidden')">√ó</button>
        <h3>World Physics (F3)</h3>
        <div class="space-y-3">
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="text-sm">Particle Count</label>
                    <div id="particleCountVal" class="val">50K</div>
                    <input id="particleCount" type="range" min="1000" max="250000" step="1000" value="50000" />
                </div>
                <div>
                    <label class="text-sm">Attractor Strength</label>
                    <div id="attractorStrengthVal" class="val">1.0</div>
                    <input id="attractorStrength" type="range" min="0" max="5" step="0.1" value="1.0" />
                </div>
                <div>
                    <label class="text-sm">Time Scale</label>
                    <div id="timeScaleVal" class="val">1.0</div>
                    <input id="timeScale" type="range" min="0.1" max="10" step="0.1" value="1.0" />
                </div>
                <div>
                    <label class="text-sm">Weather Intensity</label>
                    <div id="weatherVal" class="val">0.5</div>
                    <input id="weatherIntensity" type="range" min="0" max="2" step="0.1" value="0.5" />
                </div>
            </div>
        </div>
    </div>

    <div id="aiPanel" class="ui-panel panel hidden" style="top: 200px; right: 50px;">
        <button class="close-x" onclick="this.parentElement.classList.add('hidden')">√ó</button>
        <h3>AI Consciousness (F4)</h3>
        <div class="space-y-3">
            <div id="aiStatus" class="text-sm">AI: Initializing consciousness...</div>
            <div class="grid grid-cols-2 gap-2">
                <button id="btnSpawnStar" class="btn">Spawn Star</button>
                <button id="btnSpawnPlanet" class="btn">Spawn Planet</button>
                <button id="btnSpawnEarth" class="btn">Spawn Earth</button>
                <button id="btnSpawnGasGiant" class="btn">Spawn Gas Giant</button>
                <button id="btnSpawnBlackHole" class="btn">Spawn Black Hole</button>
                <button id="btnSpawnMoon" class="btn">Spawn Moon</button>
            </div>
            <div class="text-xs text-gray-400">
                AI autonomously learns and creates cosmic entities
            </div>
        </div>
    </div>

    <div id="settingsPanel" class="ui-panel panel hidden" style="bottom: 100px; left: 50px;">
        <button class="close-x" onclick="this.parentElement.classList.add('hidden')">√ó</button>
        <h3>Settings (F5)</h3>
        <div class="space-y-3">
            <div>
                <label class="text-sm">Quality Level</label>
                <select id="qualityLevel" class="w-full p-2 bg-gray-800 border border-gray-600 rounded">
                    <option value="1">Low (25K particles)</option>
                    <option value="2">Medium (50K particles)</option>
                    <option value="3" selected>High (100K particles)</option>
                    <option value="4">Ultra (250K particles)</option>
                </select>
            </div>
            <div>
                <label class="text-sm">LOD Distance</label>
                <div id="lodDistanceVal" class="val">1000</div>
                <input id="lodDistance" type="range" min="100" max="10000" step="100" value="1000" />
            </div>
            <div class="flex gap-2">
                <button id="btnToggleDebug" class="btn">Toggle Debug</button>
                <button id="btnPsiHUD" class="btn">Psi Overlay</button>
            </div>
        </div>
    </div>

    <!-- CROSSHAIR -->
    <div id="crosshair"></div>

    <!-- WEATHER EFFECTS -->
    <div id="weatherOverlay" class="weather-overlay"></div>

    <!-- VR INDICATOR -->
    <div id="vrIndicator" class="vr-indicator">
        <div>üåå VR MODE ACTIVE üåå</div>
        <div class="small mt-2">Use VR controllers to interact with the universe</div>
    </div>

    <!-- START BLOCKER -->
    <div id="blocker">
        <div class="max-w-xl p-4">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-100 mb-2">Genesis X</h1>
            <h2 class="text-xl md:text-2xl font-light text-slate-400 mb-6">Unified Environmental Simulation</h2>
            <div class="text-sm text-slate-300 mb-4">
                Experience the ultimate god-tier environmental simulation.<br>
                Shape reality, evolve consciousness, and witness cosmic creation.
            </div>
            <button id="start-button" class="btn primary text-lg py-3 px-8">Begin Creation</button>
            <p class="text-slate-400 text-sm mt-3">
                Features: AI Evolution ‚Ä¢ Dynamic Weather ‚Ä¢ Neural Networks ‚Ä¢ VR Support ‚Ä¢ God Powers
            </p>
        </div>
    </div>

    <!-- CANVAS -->
    <canvas id="canvas"></canvas>

    <!-- MAIN SCRIPT -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        // Wait for DOM to be ready
        document.addEventListener('DOMContentLoaded', () => {
            try {
                console.log('üåå Initializing Genesis X Unified Environmental Simulation...');
                window.__app = initializeGenesisX();
                console.log('‚úÖ Genesis X Unified Environmental Simulation initialized successfully!');
            } catch (error) {
                console.error('‚ùå Failed to initialize Genesis X:', error);
                document.body.innerHTML = `
                    <div style="display: flex; justify-content: center; align-items: center; height: 100vh; background: #0a0a0a; color: #ff6b6b; font-family: monospace; text-align: center;">
                        <div>
                            <h1>Genesis X Initialization Failed</h1>
                            <p>Error: ${error.message}</p>
                            <p>Please refresh the page and try again.</p>
                        </div>
                    </div>
                `;
            }
        });

        function initializeGenesisX() {
            // ==================== UTILITY FUNCTIONS ====================
            const $ = id => document.getElementById(id);

            function cyrb128(str) {
            let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
            for (let i = 0, k; i < str.length; i++) {
                k = str.charCodeAt(i);
                h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
                h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
                h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
                h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
            }
            h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
            h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
            h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
            h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
            return [(h1 ^ h2 ^ h3 ^ h4) >>> 0, (h2 ^ h1) >>> 0, (h3 ^ h1) >>> 0, (h4 ^ h1) >>> 0];
        }

        function sfc32(a, b, c, d) {
            return function() {
                a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
                const t = (a + b) | 0;
                a = b ^ b >>> 9;
                b = c + (c << 3) | 0;
                c = (c << 21 | c >>> 11);
                d = d + 1 | 0;
                c = c + t | 0;
                return (t >>> 0) / 4294967296;
            };
        }

        // ==================== EVENT BUS ====================
        class EventBus {
            constructor() {
                this.map = new Map();
            }
            on(name, handler) {
                if (!this.map.has(name)) this.map.set(name, new Set());
                this.map.get(name).add(handler);
            }
            emit(name, payload) {
                const handlers = this.map.get(name);
                if (handlers) for (const h of handlers) h(payload);
            }
        }

        // ==================== GOD-TIER LEVELING SYSTEM ====================
        class GodLevelingSystem {
            constructor(bus) {
                this.bus = bus;
                this.level = 1;
                this.experience = 0;
                this.experienceToNext = 1000;
                this.powers = new Set();
                this.multipliers = {
                    creation: 1.0,
                    influence: 1.0,
                    consciousness: 1.0,
                    reality: 1.0
                };

                // Experience sources
                this.bus.on('experience:gain', (amount) => this.gainExperience(amount));
                this.bus.on('power:unlock', (power) => this.unlockPower(power));
            }

            gainExperience(amount) {
                this.experience += amount;
                this.checkLevelUp();
                this.updateUI();
            }

            checkLevelUp() {
                while (this.experience >= this.experienceToNext) {
                    this.level++;
                    this.experience -= this.experienceToNext;
                    this.experienceToNext = Math.floor(this.experienceToNext * 1.5);
                    this.onLevelUp();
                }
            }

            onLevelUp() {
                // Unlock powers based on level
                const powerUnlocks = {
                    2: 'basic_influence',
                    3: 'terraform',
                    5: 'time_control',
                    7: 'reality_bend',
                    10: 'supernova',
                    15: 'neural_crystal',
                    20: 'consciousness_boost',
                    25: 'universe_master'
                };

                if (powerUnlocks[this.level]) {
                    this.unlockPower(powerUnlocks[this.level]);
                }

                // Increase multipliers
                Object.keys(this.multipliers).forEach(key => {
                    this.multipliers[key] *= 1.1;
                });

                this.bus.emit('level:up', { level: this.level, powers: Array.from(this.powers) });
            }

            unlockPower(power) {
                this.powers.add(power);
                this.bus.emit('power:unlocked', power);
            }

            updateUI() {
                $('godLevel').textContent = `Level ${this.level}`;
                const progress = (this.experience / this.experienceToNext) * 100;
                $('levelProgress').style.width = `${progress}%`;
                $('currentLevel').textContent = this.level;
                $('currentXP').textContent = Math.floor(this.experience);
                $('nextLevelXP').textContent = this.experienceToNext;
                $('powersUnlocked').textContent = this.powers.size;
            }
        }

        // ==================== UNIFIED ENVIRONMENTAL SIMULATION ====================
        class GenesisXSimulation {
            constructor() {
                try {
                    this.bus = new EventBus();
                    this.leveling = new GodLevelingSystem(this.bus);
                    this.clock = new THREE.Clock();
                this.state = 'idle';

                // Core parameters
                this.params = {
                    ec: 1.2, lambda: 0.25, li: 0.985, omega: 0.62, ugrav: 0.55,
                    particleCount: 50000, timeScale: 1.0, attractorStrength: 1.0,
                    weatherIntensity: 0.5, cloudDensity: 0.3, oceanRoughness: 0.05, windStrength: 0.2,
                    timeOfDay: 12, season: 0, lightIntensity: 1.0,
                    vegetationDensity: 0.8, biomeDiversity: 0.6, lifeForms: 0.4,
                    consciousness: 0.1, creativity: 0.3, adaptability: 0.2,
                    cameraSpeed: 1.0, fov: 75, quality: 3, lodDistance: 1000,
                    xpMultiplier: 1.0
                };

                this.init();
                this.bindEvents();
                this.start();
                } catch (error) {
                    console.error('‚ùå Failed to initialize GenesisXSimulation:', error);
                    throw error;
                }
            }

            init() {
                try {
                    // Initialize all systems
                    this.ui = new UIManager(this.bus);
                    this.audio = new AudioSystem(this.bus);
                this.renderer = new RendererSystem(this.bus);
                this.player = new PlayerSystem(this.bus, this.renderer.camera, this.renderer.renderer.domElement);
                this.cosmos = new CosmosSystem(this.bus, this.renderer.scene);
                this.environment = new EnvironmentSystem(this.bus, this.renderer.scene);

                // Apply initial environmental parameters
                this.bus.emit('param:changed', { param: 'timeOfDay', value: this.params.timeOfDay });
                this.bus.emit('param:changed', { param: 'season', value: this.params.season });
                this.bus.emit('param:changed', { param: 'vegetationDensity', value: this.params.vegetationDensity });
                this.bus.emit('param:changed', { param: 'biomeDiversity', value: this.params.biomeDiversity });
                this.bus.emit('param:changed', { param: 'lifeForms', value: this.params.lifeForms });

                this.ai = new AISystem(this.bus, this.renderer.scene);
                this.sensors = new SensorSystem(this.bus);
                this.weather = new WeatherSystem(this.bus, this.renderer.scene, this.player.camera, this.renderer.renderer);
                this.clouds = new VolumetricClouds(this.bus, this.renderer.scene, this.player.camera);
                this.nebulaSky = new NebulaSky(this.bus, this.renderer.scene, this.player.camera);
                this.galaxy = new GalaxyBackdrop(this.bus, this.renderer.scene);
                this.vr = new VRSystem(this.bus);
                this.psi = new PsiOverlay(this.bus, this.player, this);

                // Initialize tab system
                this.initTabs();
                } catch (error) {
                    console.error('‚ùå Failed to initialize GenesisXSimulation systems:', error);
                    throw error;
                }
            }

            initTabs() {
                const tabButtons = document.querySelectorAll('.tab-btn');
                const tabPanels = document.querySelectorAll('.tab-panel');

                tabButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Remove active class from all buttons and panels
                        tabButtons.forEach(b => b.classList.remove('active'));
                        tabPanels.forEach(p => p.classList.remove('active'));

                        // Add active class to clicked button and corresponding panel
                        btn.classList.add('active');
                        const tabId = btn.dataset.tab + '-tab';
                        const panel = $(tabId);
                        if (panel) panel.classList.add('active');
                    });
                });
            }

            bindEvents() {
                // Core session controls
                this.bus.on('ui:start', () => this.startSimulation());
                this.bus.on('ui:reset', () => this.resetSimulation());

                // Parameter bindings
                this.bindRange('ec', 'ecVal', 'ec', v => v.toFixed(1));
                this.bindRange('lambda', 'lambdaVal', 'lambda');
                this.bindRange('li', 'liVal', 'li', v => v.toFixed(3));
                this.bindRange('omega', 'omegaVal', 'omega');
                this.bindRange('ugrav', 'ugravVal', 'ugrav');
                this.bindRange('particleCount', 'particleCountVal', 'particleCount', v => `${Math.floor(v/1000)}K`);
                this.bindRange('timeScale', 'timeScaleVal', 'timeScale', v => v.toFixed(1));
                this.bindRange('attractorStrength', 'attractorStrengthVal', 'attractorStrength', v => v.toFixed(1));

                // Environment parameters
                this.bindRange('weatherIntensity', 'weatherVal', 'weatherIntensity');
                this.bindRange('cloudDensity', 'cloudDensityVal', 'cloudDensity');
                this.bindRange('oceanRoughness', 'oceanRoughnessVal', 'oceanRoughness', v => v.toFixed(2));
                this.bindRange('windStrength', 'windStrengthVal', 'windStrength');
                this.bindRange('timeOfDay', 'timeOfDayVal', 'timeOfDay', v => {
                    const hour = Math.floor(v);
                    const minute = Math.floor((v % 1) * 60);
                    return `${hour.toString().padStart(2,'0')}:${minute.toString().padStart(2,'0')}`;
                });
                this.bindRange('season', 'seasonVal', 'season', v => ['Spring','Summer','Autumn','Winter'][v]);
                this.bindRange('lightIntensity', 'lightIntensityVal', 'lightIntensity', v => v.toFixed(1));
                this.bindRange('vegetationDensity', 'vegetationVal', 'vegetationDensity');
                this.bindRange('biomeDiversity', 'biomeVal', 'biomeDiversity');
                this.bindRange('lifeForms', 'lifeFormsVal', 'lifeForms');

                // AI parameters
                this.bindRange('consciousness', 'consciousnessVal', 'consciousness');
                this.bindRange('creativity', 'creativityVal', 'creativity');
                this.bindRange('adaptability', 'adaptabilityVal', 'adaptability');

                // Control parameters
                this.bindRange('cameraSpeed', 'cameraSpeedVal', 'cameraSpeed', v => v.toFixed(1));
                this.bindRange('fov', 'fovVal', 'fov', v => `${v}¬∞`);
                this.bindRange('quality', 'qualityVal', 'quality', v => ['Low','Medium','High','Ultra'][v-1]);
                this.bindRange('lodDistance', 'lodVal', 'lodDistance');
                this.bindRange('xpMultiplier', 'xpMultiplierVal', 'xpMultiplier', v => `${v.toFixed(1)}x`);

                // Mode switches
                this.bus.on('ui:setMode', mode => this.setMode(mode));
            }

            bindRange(id, displayId, param, formatter = v => v.toFixed(2)) {
                const el = $(id);
                const display = $(displayId);
                if (!el) return;

                const update = () => {
                    const val = parseFloat(el.value);
                    this.params[param] = val;
                    display.textContent = formatter(val);
                    this.bus.emit('param:changed', { param, value: val });
                };

                el.addEventListener('input', update);
                update();
            }

            start() {
                try {
                    // Start environmental sensors
                    if (this.sensors) {
                        this.sensors.startAdvancedSensors();
                    }

                    this.animate();
                } catch (error) {
                    console.error('‚ùå Failed to start GenesisXSimulation:', error);
                    throw error;
                }
            }

            startSimulation() {
                $('blocker').style.opacity = '0';
                setTimeout(() => $('blocker').style.display = 'none', 500);
                this.state = 'running';
                this.bus.emit('simulation:start');
            }

            resetSimulation() {
                this.state = 'idle';
                // Reset all systems
                this.bus.emit('simulation:reset');
            }

            setMode(mode) {
                this.bus.emit('mode:changed', mode);
                const hudMode = $('hudMode');
                if (hudMode) hudMode.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);

                // Handle mode switching for visual systems
                if (this.environment) {
                    const isSurface = mode === 'surface';
                    this.environment.show(isSurface);
                    $('surface-hud').style.display = isSurface ? 'block' : 'none';
                }

                // Handle cloud visibility for Cloud FP mode
                if (this.clouds) {
                    const showClouds = mode === 'cloudfp' || mode === 'surface';
                    this.clouds.enabled = showClouds;
                    if (this.clouds.group) {
                        this.clouds.group.visible = showClouds;
                    }
                }

                // Handle nebula sky for space modes
                if (this.nebulaSky) {
                    const showNebula = mode !== 'surface';
                    this.nebulaSky.enabled = showNebula;
                    if (this.nebulaSky.mesh) {
                        this.nebulaSky.mesh.visible = showNebula;
                    }
                }

                // Handle galaxy backdrop for space modes
                if (this.galaxy) {
                    const showGalaxy = mode === 'orbit' || mode === 'ship' || mode === 'void';
                    if (this.galaxy.group) {
                        this.galaxy.group.visible = showGalaxy;
                    }
                }

                // Special Void Walker mode: enhanced space atmosphere and world connections
                if (mode === 'void') {
                    this.enableVoidAtmosphere();
                    this.enableVoidConnectivity();
                } else {
                    this.disableVoidAtmosphere();
                    this.disableVoidConnectivity();
                }
            }

            // Save/Load functionality
            saveState() {
                const state = {
                    version: '1.0',
                    timestamp: Date.now(),
                    params: { ...this.params },
                    level: this.leveling.level,
                    experience: this.leveling.experience,
                    seed: this.cosmos.prng ? this.cosmos.prng() : Math.random(),
                    objects: this.ai.objects.map(obj => ({
                        type: obj.type,
                        position: obj.mesh.position.toArray(),
                        scale: obj.mesh.scale.toArray()
                    }))
                };

                const dataStr = JSON.stringify(state, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `genesis_x_state_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.bus.emit('experience:gain', 25); // Experience for saving
            }

            loadState() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const state = JSON.parse(event.target.result);
                                this.applyState(state);
                                this.bus.emit('experience:gain', 50); // Experience for loading
                            } catch (error) {
                                console.error('Failed to load state:', error);
                                alert('Failed to load state file');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }

            applyState(state) {
                if (state.params) {
                    Object.assign(this.params, state.params);
                    // Update all parameter displays
                    Object.keys(state.params).forEach(key => {
                        this.bus.emit('param:changed', { param: key, value: state.params[key] });
                    });
                }

                if (state.level && this.leveling) {
                    this.leveling.level = state.level;
                    this.leveling.experience = state.experience || 0;
                    this.leveling.updateUI();
                }

                if (state.seed && this.cosmos) {
                    // Reinitialize with seed
                    this.cosmos.prng = sfc32(state.seed, state.seed * 2, state.seed * 3, state.seed * 4);
                    this.cosmos.generateGalaxy();
                }
            }

            // Screenshot functionality
            takeScreenshot() {
                if (!this.renderer || !this.renderer.renderer) return;

                const renderer = this.renderer.renderer;
                const canvas = renderer.domElement;

                // Create download link
                const link = document.createElement('a');
                link.download = `genesis_x_screenshot_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                link.href = canvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                this.bus.emit('experience:gain', 10); // Experience for screenshot
            }

            // Recording functionality (placeholder)
            toggleRecording() {
                this.isRecording = !this.isRecording;
                const btn = $('btnRecord');
                if (btn) {
                    btn.textContent = this.isRecording ? 'Stop Recording' : 'Record Session';
                    btn.classList.toggle('danger', this.isRecording);
                }

                if (this.isRecording) {
                    console.log('Recording started');
                    // Implement actual recording logic here
                } else {
                    console.log('Recording stopped');
                    // Stop recording and save file
                }
            }

            // Data export functionality
            exportData() {
                const data = {
                    timestamp: new Date().toISOString(),
                    sessionDuration: this.clock.getElapsedTime(),
                    parameters: this.params,
                    statistics: {
                        fps: this.psi ? this.psi.fps : 0,
                        objectsCreated: this.ai ? this.ai.objects.length : 0,
                        level: this.leveling ? this.leveling.level : 1,
                        experience: this.leveling ? this.leveling.experience : 0,
                        psiHistory: this.psi ? this.psi.history.slice(-50) : []
                    }
                };

                const dataStr = JSON.stringify(data, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `genesis_x_data_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.bus.emit('experience:gain', 15); // Experience for data export
            }

            // Debug functionality
            toggleDebug() {
                this.debugMode = !this.debugMode;
                const debugInfo = $('debugInfo');
                if (debugInfo) {
                    debugInfo.style.display = this.debugMode ? 'block' : 'none';
                }

                const btn = $('btnDebug');
                if (btn) {
                    btn.textContent = this.debugMode ? 'Debug: ON' : 'Debug Mode';
                    btn.classList.toggle('success', this.debugMode);
                }
            }

            // Camera controls
            resetCamera() {
                if (this.player) {
                    this.player.resetCamera();
                }
            }

            setTopView() {
                if (this.player && this.player.camera) {
                    this.player.camera.position.set(0, 1000, 0);
                    this.player.camera.lookAt(0, 0, 0);
                    if (this.player.orbit) {
                        this.player.orbit.target.set(0, 0, 0);
                    }
                }
            }

            setSideView() {
                if (this.player && this.player.camera) {
                    this.player.camera.position.set(1000, 0, 0);
                    this.player.camera.lookAt(0, 0, 0);
                    if (this.player.orbit) {
                        this.player.orbit.target.set(0, 0, 0);
                    }
                }
            }

            toggleFollowMode() {
                this.followMode = !this.followMode;
                const btn = $('btnFollowObject');
                if (btn) {
                    btn.textContent = this.followMode ? 'Following: ON' : 'Follow Selected';
                    btn.classList.toggle('primary', this.followMode);
                }
            }

            // God powers
            triggerSupernova() {
                if (!this.leveling || this.leveling.level < 10) {
                    alert('Supernova requires Level 10+');
                    return;
                }

                console.log('üåü INITIATING SUPERNOVA SEQUENCE üåü');

                // Find the largest star to supernova
                let targetStar = null;
                let maxSize = 0;

                if (this.ai && this.ai.objects) {
                    this.ai.objects.forEach(obj => {
                        if (obj.type === 'star' && obj.mesh) {
                            const size = obj.mesh.scale.x;
                            if (size > maxSize) {
                                maxSize = size;
                                targetStar = obj;
                            }
                        }
                    });
                }

                if (!targetStar) {
                    alert('No stars available for supernova!');
                    return;
                }

                // Create supernova effect
                this.createSupernovaEffect(targetStar);
                this.bus.emit('experience:gain', 100);
            }

            createSupernovaEffect(targetStar) {
                const position = targetStar.mesh.position.clone();
                console.log('üåü SUPERNOVA at:', position);

                // Remove the original star
                this.renderer.scene.remove(targetStar.light);
                this.renderer.scene.remove(targetStar.mesh);

                // Remove from AI objects
                if (this.ai && this.ai.objects) {
                    this.ai.objects = this.ai.objects.filter(obj => obj !== targetStar);
                    this.ai.updateHUD();
                }

                // Create expanding shockwave
                const shockwaveGeometry = new THREE.RingGeometry(0, 1, 64);
                const shockwaveMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });

                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const wave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial.clone());
                        wave.position.copy(position);
                        wave.rotation.x = Math.PI / 2;
                        this.renderer.scene.add(wave);

                        // Animate expansion
                        const startTime = Date.now();
                        const animateWave = () => {
                            const elapsed = (Date.now() - startTime) / 1000;
                            const scale = elapsed * 200;
                            wave.scale.setScalar(scale);
                            wave.material.opacity = Math.max(0, 0.8 - elapsed);

                            if (wave.material.opacity > 0) {
                                requestAnimationFrame(animateWave);
                            } else {
                                this.renderer.scene.remove(wave);
                            }
                        };
                        animateWave();
                    }, i * 150);
                }

                // Create remnant neutron star
                setTimeout(() => {
                    const neutronStar = new THREE.Mesh(
                        new THREE.SphereGeometry(2, 16, 16),
                        new THREE.MeshBasicMaterial({ color: 0xffffff })
                    );
                    neutronStar.position.copy(position);

                    this.renderer.scene.add(neutronStar);

                    // Add intense point light
                    const remnantLight = new THREE.PointLight(0xffffff, 50, 1000, 2);
                    remnantLight.position.copy(position);
                    this.renderer.scene.add(remnantLight);

                    // Add to AI objects as a new attractor
                    const neutronObj = { mesh: neutronStar, light: remnantLight, type: 'neutron_star' };
                    if (this.ai) {
                        this.ai.objects.push(neutronObj);
                        this.bus.emit('create:attractor', {
                            position: position,
                            strength: 25.0
                        });
                        this.ai.updateHUD();
                    }

                    console.log('‚≠ê Neutron star remnant created');
                }, 3000);
            }

            triggerBigBang() {
                if (!this.leveling || this.leveling.level < 15) {
                    alert('Big Bang requires Level 15+');
                    return;
                }

                console.log('üí• INITIATING BIG BANG SEQUENCE üí•');

                // Create big bang effect
                this.createBigBangEffect();
                this.bus.emit('experience:gain', 200);
            }

            createBigBangEffect() {
                // Clear all existing objects
                if (this.ai && this.ai.objects) {
                    this.ai.objects.forEach(obj => {
                        if (obj.mesh) this.renderer.scene.remove(obj.mesh);
                        if (obj.light) this.renderer.scene.remove(obj.light);
                        if (obj.atmosphere) this.renderer.scene.remove(obj.atmosphere);
                        if (obj.rings) this.renderer.scene.remove(obj.rings);
                        if (obj.stars) obj.stars.forEach(star => this.renderer.scene.remove(star));
                    });
                    this.ai.objects = [];
                }

                // Clear attractors
                if (this.cosmos) {
                    this.cosmos.attractors = [];
                }

                // Create expanding universe effect
                const universeGeometry = new THREE.SphereGeometry(1, 64, 32);
                const universeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.BackSide
                });

                const universe = new THREE.Mesh(universeGeometry, universeMaterial);
                universe.position.set(0, 0, 0);
                universe.scale.setScalar(0.1);
                this.renderer.scene.add(universe);

                // Animate expansion
                const startTime = Date.now();
                const animateExpansion = () => {
                    const elapsed = (Date.now() - startTime) / 1000;
                    const scale = Math.pow(elapsed * 2, 2); // Exponential expansion
                    universe.scale.setScalar(scale);
                    universe.material.opacity = Math.max(0, 1 - elapsed * 0.3);

                    if (universe.material.opacity > 0 && scale < 10000) {
                        requestAnimationFrame(animateExpansion);
                    } else {
                        this.renderer.scene.remove(universe);

                        // Generate new universe
                        setTimeout(() => {
                            this.generateNewUniverse();
                        }, 1000);
                    }
                };
                animateExpansion();
            }

            generateNewUniverse() {
                console.log('üåå New Universe Born üåå');

                // Generate new seed
                const newSeed = Date.now() + Math.random() * 1000000;

                // Reset cosmos with new seed
                if (this.cosmos) {
                    this.cosmos.prng = sfc32(newSeed, newSeed * 2, newSeed * 3, newSeed * 4);
                    this.cosmos.generateGalaxy();
                }

                // Create primordial stars
                if (this.ai) {
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            this.ai.createObject({ kind: 'star' });
                        }, i * 500);
                    }
                }

                // Reset time and environment
                if (this.environment) {
                    this.environment.time = 6; // Dawn
                    this.environment.season = 0; // Spring
                }

                console.log('‚ú® Universe regeneration complete');
            }

            toggleTimeControl() {
                if (!this.leveling || this.leveling.level < 5) {
                    alert('Time Control requires Level 5+');
                    return;
                }

                this.timeControlActive = !this.timeControlActive;
                this.params.timeScale = this.timeControlActive ? 0.1 : 1.0;

                const btn = $('btnTimeControl');
                if (btn) {
                    btn.textContent = this.timeControlActive ? 'Time: SLOW' : 'Time Control';
                    btn.classList.toggle('cyber', this.timeControlActive);
                }

                console.log('‚è∞ TIME CONTROL:', this.timeControlActive ? 'ACTIVE' : 'INACTIVE');
            }

            toggleRealityBend() {
                if (!this.leveling || this.leveling.level < 7) {
                    alert('Reality Bend requires Level 7+');
                    return;
                }

                this.realityBendActive = !this.realityBendActive;

                const btn = $('btnRealityBend');
                if (btn) {
                    btn.textContent = this.realityBendActive ? 'Reality: BENT' : 'Reality Bend';
                    btn.classList.toggle('purple', this.realityBendActive);
                }

                console.log('üîÆ REALITY BEND:', this.realityBendActive ? 'ACTIVE' : 'INACTIVE');
            }

            // Interaction Modes
            setInteractionMode(mode) {
                this.interactionMode = mode;
                console.log('üéÆ Interaction Mode:', mode.toUpperCase());

                // Update button states
                const buttons = ['btnInfluence', 'btnTerraform', 'btnScan', 'btnTeleport'];
                buttons.forEach(btnId => {
                    const btn = $(btnId);
                    if (btn) {
                        btn.classList.toggle('primary', btnId === `btn${mode.charAt(0).toUpperCase() + mode.slice(1)}`);
                    }
                });

                // Enable/disable mouse influence
                if (this.player) {
                    this.player.interactionMode = mode;
                }

                this.bus.emit('experience:gain', 5); // Small experience for mode switching
            }

            // Mouse interaction handler (called from PlayerSystem)
            handleMouseInteraction(mousePos, isClick) {
                if (!this.interactionMode || this.interactionMode === 'none') return;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mousePos, this.player.camera);

                switch (this.interactionMode) {
                    case 'influence':
                        this.handleInfluenceInteraction(raycaster, isClick);
                        break;
                    case 'terraform':
                        this.handleTerraformInteraction(raycaster, isClick);
                        break;
                    case 'scan':
                        this.handleScanInteraction(raycaster, isClick);
                        break;
                    case 'teleport':
                        if (isClick) this.handleTeleportInteraction(raycaster);
                        break;
                }
            }

            handleInfluenceInteraction(raycaster, isClick) {
                // Create temporary attractor at mouse position
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const mouseAttractor = new THREE.Vector3();

                if (raycaster.ray.intersectPlane(plane, mouseAttractor)) {
                    if (isClick) {
                        // Add permanent attractor
                        this.bus.emit('create:attractor', {
                            position: mouseAttractor,
                            strength: 8.0
                        });
                        console.log('‚ú® Created gravitational influence at:', mouseAttractor);
                        this.bus.emit('experience:gain', 15);
                    } else {
                        // Temporary visual feedback
                        this.createInfluenceVisual(mouseAttractor);
                    }
                }
            }

            handleTerraformInteraction(raycaster, isClick) {
                if (!isClick) return;

                // Terraform surface or atmosphere
                const intersects = raycaster.intersectObjects(this.scene.children, true);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    console.log('üèóÔ∏è Terraforming at:', hit.point);

                    // Create terraform effect
                    this.createTerraformEffect(hit.point);
                    this.bus.emit('experience:gain', 20);
                }
            }

            handleScanInteraction(raycaster, isClick) {
                if (!isClick) return;

                const intersects = raycaster.intersectObjects(this.scene.children, true);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const scannedObject = hit.object;

                    // Analyze object
                    const analysis = this.analyzeObject(scannedObject, hit.point);
                    console.log('üîç SCAN RESULTS:', analysis);

                    // Show scan results
                    this.showScanResults(analysis);
                    this.bus.emit('experience:gain', 10);
                }
            }

            handleTeleportInteraction(raycaster) {
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const teleportPos = new THREE.Vector3();

                if (raycaster.ray.intersectPlane(plane, teleportPos)) {
                    if (this.player) {
                        this.player.camera.position.copy(teleportPos).add(new THREE.Vector3(0, 50, 50));
                        this.player.orbit.target.copy(teleportPos);
                        console.log('‚úàÔ∏è Teleported to:', teleportPos);
                        this.bus.emit('experience:gain', 25);
                    }
                }
            }

            createInfluenceVisual(position) {
                // Create temporary visual effect
                const geometry = new THREE.SphereGeometry(5, 16, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3,
                    wireframe: true
                });

                const visual = new THREE.Mesh(geometry, material);
                visual.position.copy(position);
                this.renderer.scene.add(visual);

                // Fade out and remove
                let opacity = 0.3;
                const fadeOut = () => {
                    opacity -= 0.05;
                    visual.material.opacity = opacity;
                    visual.scale.multiplyScalar(1.02);

                    if (opacity > 0) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        this.renderer.scene.remove(visual);
                    }
                };
                fadeOut();
            }

            createTerraformEffect(position) {
                // Create terraform particles
                const particleCount = 50;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3] = position.x + (Math.random() - 0.5) * 20;
                    positions[i3 + 1] = position.y + Math.random() * 30;
                    positions[i3 + 2] = position.z + (Math.random() - 0.5) * 20;

                    colors[i3] = 0.2; // R
                    colors[i3 + 1] = 0.8; // G
                    colors[i3 + 2] = 0.4; // B
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8
                });

                const particles = new THREE.Points(geometry, material);
                this.renderer.scene.add(particles);

                // Animate and remove
                let life = 1.0;
                const animate = () => {
                    life -= 0.02;
                    particles.material.opacity = life;
                    particles.rotation.y += 0.01;

                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        positions[i3 + 1] += 0.5; // Rise up
                    }
                    geometry.attributes.position.needsUpdate = true;

                    if (life > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        this.renderer.scene.remove(particles);
                    }
                };
                animate();
            }

            analyzeObject(object, position) {
                const analysis = {
                    position: position.toArray(),
                    type: 'unknown',
                    properties: {},
                    distance: position.length(),
                    influence: 0
                };

                // Analyze object type
                if (object.geometry) {
                    if (object.geometry.type === 'SphereGeometry') {
                        analysis.type = object === this.ai?.crystal ? 'neural_crystal' :
                                       object.material?.color?.getHex() === 0x16a34a ? 'earth' :
                                       object.material?.color?.getHex() === 0xcaa77a ? 'gas_giant' : 'planet';
                    } else if (object.geometry.type === 'Points') {
                        analysis.type = 'particle_system';
                    }
                }

                // Calculate influence
                if (this.cosmos?.attractors) {
                    this.cosmos.attractors.forEach(attractor => {
                        const distance = position.distanceTo(attractor.position);
                        if (distance < 100) {
                            analysis.influence += attractor.strength / (distance + 1);
                        }
                    });
                }

                analysis.properties = {
                    size: object.scale ? object.scale.x : 1,
                    color: object.material?.color ? object.material.color.getHex() : null,
                    influence: analysis.influence.toFixed(2),
                    distance: analysis.distance.toFixed(1)
                };

                return analysis;
            }

            showScanResults(analysis) {
                const results = `
SCAN RESULTS:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Type: ${analysis.type.toUpperCase()}
Position: (${analysis.position.map(p => p.toFixed(1)).join(', ')})
Distance: ${analysis.distance.toFixed(1)} units
Influence: ${analysis.properties.influence}
Size: ${analysis.properties.size}
Color: ${analysis.properties.color ? '#' + analysis.properties.color.toString(16) : 'N/A'}
                `;

                console.log(results);
                alert(results);
            }

            animate() {
                try {
                    requestAnimationFrame(() => this.animate());
                    const dt = this.clock.getDelta() * this.params.timeScale;

                    if (this.state === 'running') {
                        this.bus.emit('engine:update', { dt, now: this.clock.getElapsedTime() });

                        // Update debug info if in debug mode
                        if (this.debugMode) {
                            this.updateDebugInfo();
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Animation loop error:', error);
                    // Continue animation loop even if there's an error
                    requestAnimationFrame(() => this.animate());
                }
            }

            updateDebugInfo() {
                const debugFps = $('debugFps');
                const debugObjects = $('debugObjects');
                const debugMemory = $('debugMemory');

                if (debugFps && this.psi) debugFps.textContent = this.psi.fps.toFixed(0);
                if (debugObjects && this.ai) debugObjects.textContent = this.ai.objects.length;
                if (debugMemory) {
                    // Estimate memory usage (rough approximation)
                    const memoryEstimate = (this.cosmos?.count || 0) * 0.1 + (this.ai?.objects.length || 0) * 0.05;
                    debugMemory.textContent = memoryEstimate.toFixed(1);
                }
            }
        }

        // ==================== SUBSYSTEM CLASSES ====================

        class UIManager {
            constructor(bus) {
                this.bus = bus;
                this.init();
            }

            init() {
                // Safely add event listeners with null checks
                const addListener = (id, event, handler) => {
                    const el = $(id);
                    if (el) el.addEventListener(event, handler);
                };

                // Button event listeners
                addListener('start-button', 'click', () => this.bus.emit('ui:start'));
                addListener('btnStart', 'click', () => this.bus.emit('ui:start'));
                addListener('btnReset', 'click', () => this.bus.emit('ui:reset'));
                addListener('btnSave', 'click', () => window.__app?.saveState());
                addListener('btnLoad', 'click', () => window.__app?.loadState());

                // Mode buttons
                addListener('btnOrbit', 'click', () => this.bus.emit('ui:setMode', 'orbit'));
                addListener('btnShip', 'click', () => this.bus.emit('ui:setMode', 'ship'));
                addListener('btnSurface', 'click', () => this.bus.emit('ui:setMode', 'surface'));
                addListener('btnCloudFP', 'click', () => this.bus.emit('ui:setMode', 'cloudfp'));
                addListener('btnVoid', 'click', () => this.bus.emit('ui:setMode', 'void'));

                // Control panel buttons
                addListener('btnToggleDebug', 'click', () => this.bus.emit('ui:toggleDebug'));
                addListener('qualityLevel', 'change', (e) => this.setQualityLevel(parseInt(e.target.value)));
                addListener('lodDistance', 'input', (e) => this.setLodDistance(parseFloat(e.target.value)));

                // AI buttons
                addListener('btnSpawnStar', 'click', () => this.bus.emit('ai:create', { kind: 'star' }));
                addListener('btnSpawnPlanet', 'click', () => this.bus.emit('ai:create', { kind: 'planet' }));
                addListener('btnSpawnEarth', 'click', () => this.bus.emit('ai:create', { kind: 'earth' }));
                addListener('btnSpawnGasGiant', 'click', () => this.bus.emit('ai:create', { kind: 'gasgiant' }));
                addListener('btnSpawnBlackHole', 'click', () => this.bus.emit('ai:create', { kind: 'blackhole' }));
                addListener('btnSpawnMoon', 'click', () => this.bus.emit('ai:create', { kind: 'moon' }));
                addListener('btnSpawnAsteroid', 'click', () => this.bus.emit('ai:create', { kind: 'asteroid' }));

                // Crystal buttons (may not exist)
                addListener('btnCreateCrystal', 'click', () => window.__app?.ai?.createCrystal());
                addListener('btnBindData', 'click', () => window.__app?.ai?.bindSoulData());
                addListener('btnEvolve', 'click', () => window.__app?.ai?.evolveUniverse());

                // Advanced buttons
                addListener('btnScreenshot', 'click', () => window.__app?.takeScreenshot());
                addListener('btnRecord', 'click', () => window.__app?.toggleRecording());
                addListener('btnExport', 'click', () => window.__app?.exportData());
                addListener('btnDebug', 'click', () => window.__app?.toggleDebug());

                // Camera controls
                addListener('btnResetCamera', 'click', () => window.__app?.resetCamera());
                addListener('btnTopView', 'click', () => window.__app?.setTopView());
                addListener('btnSideView', 'click', () => window.__app?.setSideView());
                addListener('btnFollowObject', 'click', () => window.__app?.toggleFollowMode());

                // Interaction modes
                addListener('btnInfluence', 'click', () => window.__app?.setInteractionMode('influence'));
                addListener('btnTerraform', 'click', () => window.__app?.setInteractionMode('terraform'));
                addListener('btnScan', 'click', () => window.__app?.setInteractionMode('scan'));
                addListener('btnTeleport', 'click', () => window.__app?.setInteractionMode('teleport'));

                // God powers
                addListener('btnSupernova', 'click', () => window.__app?.triggerSupernova());
                addListener('btnBigBang', 'click', () => window.__app?.triggerBigBang());
                addListener('btnTimeControl', 'click', () => window.__app?.toggleTimeControl());
                addListener('btnRealityBend', 'click', () => window.__app?.toggleRealityBend());

                // Toggle listeners
                addListener('toggleAudio', 'change', e => this.bus.emit('ui:toggleAudio', e.target.checked));
                addListener('toggleVR', 'change', e => this.bus.emit('ui:toggleVR', e.target.checked));
                addListener('toggleBloom', 'change', e => this.bus.emit('ui:toggleBloom', e.target.checked));
                addListener('toggleShadows', 'change', e => this.bus.emit('ui:toggleShadows', e.target.checked));
                addListener('toggleParticles', 'change', e => this.bus.emit('ui:toggleParticles', e.target.checked));

                // Rendering toggles
                this.bus.on('ui:toggleBloom', enabled => {
                    if (this.renderer && this.renderer.bloom) {
                        this.renderer.bloom.enabled = enabled;
                        console.log('üåü Bloom effects:', enabled ? 'ENABLED' : 'DISABLED');
                    }
                });

                this.bus.on('ui:toggleShadows', enabled => {
                    // Shadow toggle - would affect directional light shadows if implemented
                    console.log('üåë Dynamic shadows:', enabled ? 'ENABLED' : 'DISABLED');
                    // Note: Full shadow implementation would require shadow maps on all objects
                });

                this.bus.on('ui:toggleParticles', enabled => {
                    if (this.cosmos && this.cosmos.points) {
                        this.cosmos.points.visible = enabled;
                        console.log('‚ú® Particle system:', enabled ? 'VISIBLE' : 'HIDDEN');
                    }
                });

                // Quality and LOD controls
                this.bus.on('param:changed', p => {
                    if (p.param === 'quality') {
                        this.setQualityLevel(p.value);
                    } else if (p.param === 'lodDistance') {
                        this.setLodDistance(p.value);
                    }
                });

                // Psi overlay
                addListener('btnPsiHUD', 'click', () => $('psiPanel')?.classList.toggle('hidden'));
                addListener('psiClose', 'click', () => $('psiPanel')?.classList.add('hidden'));

                // F1-F5 Control Panel System
                this.bus.on('ui:togglePanel', panel => this.togglePanel(panel));

                // Soul Dust audio updates
                this.bus.on('soulDust:update', data => this.updateSoulDustUI(data));

                // Update active mode buttons
                this.bus.on('mode:changed', mode => this.updateModeButtons(mode));
            }

            updateModeButtons(activeMode) {
                const modes = ['Orbit', 'Ship', 'Surface', 'CloudFP', 'Void'];
                modes.forEach(mode => {
                    const btn = $(`btn${mode}`);
                    if (btn) {
                        btn.classList.toggle('primary', mode.toLowerCase() === activeMode);
                    }
                });
            }

            // F1-F5 Control Panel Toggle System
            togglePanel(panelName) {
                const panelMap = {
                    'main': 'controlPanel',
                    'audio': 'audioPanel',
                    'world': 'worldPanel',
                    'ai': 'aiPanel',
                    'settings': 'settingsPanel'
                };

                const panelId = panelMap[panelName];
                if (!panelId) return;

                const panel = $(panelId);
                if (panel) {
                    const isHidden = panel.classList.contains('hidden');
                    // Hide all panels first
                    Object.values(panelMap).forEach(id => {
                        const p = $(id);
                        if (p) p.classList.add('hidden');
                    });
                    // Show the requested panel if it was hidden
                    if (isHidden) {
                        panel.classList.remove('hidden');
                    }
                }
            }

            // Soul Dust UI updates
            updateSoulDustUI(data) {
                // Update audio panel levels
                const bassBar = $('bassLevel')?.querySelector('div');
                const midsBar = $('midsLevel')?.querySelector('div');
                const trebleBar = $('trebleLevel')?.querySelector('div');
                const energyBar = $('energyLevel')?.querySelector('div');

                if (bassBar) bassBar.style.width = `${Math.min(100, data.bass * 100)}%`;
                if (midsBar) midsBar.style.width = `${Math.min(100, data.mids * 100)}%`;
                if (trebleBar) trebleBar.style.width = `${Math.min(100, data.treble * 100)}%`;
                if (energyBar) energyBar.style.width = `${Math.min(100, data.energy * 100)}%`;

                // Update status
                const audioStatus = $('audioStatus');
                if (audioStatus && data.energy > 0.01) {
                    audioStatus.textContent = `Soul Dust: Active (${(data.energy * 100).toFixed(1)}% energy)`;
                }
            }

            // Quality level control
            setQualityLevel(level) {
                if (!this.renderer) return;

                const qualityLevels = {
                    1: { pixelRatio: 0.5, bloomStrength: 0.3, shadowMapSize: 512 },  // Low
                    2: { pixelRatio: 0.75, bloomStrength: 0.6, shadowMapSize: 1024 }, // Medium
                    3: { pixelRatio: 1.0, bloomStrength: 0.9, shadowMapSize: 2048 },  // High
                    4: { pixelRatio: 1.5, bloomStrength: 1.2, shadowMapSize: 4096 }   // Ultra
                };

                const settings = qualityLevels[level] || qualityLevels[3];
                this.renderer.renderer.setPixelRatio(settings.pixelRatio);

                if (this.renderer.bloom) {
                    this.renderer.bloom.strength = settings.bloomStrength;
                }

                console.log('‚öôÔ∏è Quality level set to:', ['Low','Medium','High','Ultra'][level-1]);
            }

            // LOD distance control
            setLodDistance(distance) {
                // This would affect level of detail for distant objects
                // For now, it affects particle count and render distance
                if (this.cosmos) {
                    const maxParticles = Math.floor(distance / 10); // Rough approximation
                    if (maxParticles !== this.cosmos.count) {
                        this.cosmos.resize(Math.min(maxParticles, 150000));
                        console.log('üìè LOD distance set to:', distance, '- Particles:', this.cosmos.count);
                    }
                }
            }

            enableVoidAtmosphere() {
                // Enhanced space atmosphere for Void Walker mode
                if (this.nebulaSky) {
                    this.nebulaSky.enabled = true;
                    this.nebulaSky.mesh.visible = true;
                    // Enhance nebula density for void mode
                    this.bus.emit('param:changed', { param: 'nebulaDensity', value: 1.4 });
                }

                if (this.galaxy) {
                    this.galaxy.group.visible = true;
                    // Enable twinkling stars in void mode
                    this.bus.emit('ui:twinkle');
                }

                // Add cosmic dust particles for void atmosphere
                this.createCosmicDust();

                console.log('üåå Void Walker atmosphere enabled - enhanced space visuals');
            }

            disableVoidAtmosphere() {
                // Reset atmosphere when leaving void mode
                if (this.nebulaSky) {
                    this.nebulaSky.enabled = false;
                    this.nebulaSky.mesh.visible = false;
                }

                // Remove cosmic dust
                this.removeCosmicDust();

                console.log('üåç Void Walker atmosphere disabled');
            }

            enableVoidConnectivity() {
                // Enable seamless travel between different cosmic regions/worlds
                this.voidConnectivity = true;
                this.worldRegions = this.generateWorldRegions();

                // Create portal connections between regions
                this.createRegionPortals();

                // Enable enhanced movement in void
                this.voidThrustMultiplier = 3.0;
                this.voidDamping = 0.95;

                console.log('üåå Void Connectivity Enabled - Worlds are now connected through light');
            }

            disableVoidConnectivity() {
                // Disable void connectivity
                this.voidConnectivity = false;
                this.removeRegionPortals();
                this.voidThrustMultiplier = 1.0;
                this.voidDamping = 0.98;

                console.log('üåå Void Connectivity Disabled');
            }

            generateWorldRegions() {
                // Generate interconnected cosmic regions
                const regions = [];
                const regionCount = 8;

                for (let i = 0; i < regionCount; i++) {
                    const region = {
                        id: i,
                        position: new THREE.Vector3(
                            (Math.random() - 0.5) * 4000,
                            (Math.random() - 0.5) * 2000,
                            (Math.random() - 0.5) * 4000
                        ),
                        radius: 300 + Math.random() * 500,
                        type: ['galaxy', 'nebula', 'void', 'starfield'][Math.floor(Math.random() * 4)],
                        connectedTo: []
                    };
                    regions.push(region);
                }

                // Create connections between regions
                for (let i = 0; i < regions.length; i++) {
                    const connections = 2 + Math.floor(Math.random() * 3);
                    for (let j = 0; j < connections; j++) {
                        const targetIndex = (i + j + 1) % regions.length;
                        if (!regions[i].connectedTo.includes(targetIndex)) {
                            regions[i].connectedTo.push(targetIndex);
                        }
                    }
                }

                return regions;
            }

            createRegionPortals() {
                if (!this.worldRegions) return;

                this.regionPortals = new THREE.Group();
                this.scene.add(this.regionPortals);

                this.worldRegions.forEach((region, index) => {
                    // Create portal rings at region boundaries
                    region.connectedTo.forEach(targetIndex => {
                        const targetRegion = this.worldRegions[targetIndex];
                        const portalGeometry = new THREE.TorusGeometry(20, 3, 8, 16);
                        const portalMaterial = new THREE.MeshBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.6,
                            side: THREE.DoubleSide
                        });

                        const portal = new THREE.Mesh(portalGeometry, portalMaterial);

                        // Position portal between regions
                        const midpoint = region.position.clone().add(targetRegion.position).multiplyScalar(0.5);
                        portal.position.copy(midpoint);

                        // Orient towards target
                        const direction = targetRegion.position.clone().sub(region.position).normalize();
                        portal.lookAt(targetRegion.position);
                        portal.rotateX(Math.PI / 2);

                        portal.userData = {
                            fromRegion: index,
                            toRegion: targetIndex,
                            type: 'portal'
                        };

                        this.regionPortals.add(portal);
                    });
                });
            }

            removeRegionPortals() {
                if (this.regionPortals) {
                    this.scene.remove(this.regionPortals);
                    this.regionPortals.traverse(obj => {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) obj.material.dispose();
                    });
                    this.regionPortals = null;
                }
            }

            checkPortalProximity() {
                if (!this.voidConnectivity || !this.regionPortals) return;

                const playerPos = this.camera.position;

                this.regionPortals.children.forEach(portal => {
                    const distance = playerPos.distanceTo(portal.position);
                    if (distance < 50) {
                        // Activate portal
                        portal.material.emissive.setHex(0x00ff00);
                        portal.scale.setScalar(1.5);

                        // Check for interaction (space key)
                        if (this.keys['Space']) {
                            this.teleportThroughPortal(portal);
                        }
                    } else {
                        portal.material.emissive.setHex(0x000000);
                        portal.scale.setScalar(1.0);
                    }
                });
            }

            teleportThroughPortal(portal) {
                const targetRegion = this.worldRegions[portal.userData.toRegion];
                if (targetRegion) {
                    // Smooth teleport to target region
                    this.camera.position.copy(targetRegion.position);
                    this.velocity.set(0, 0, 0);

                    // Trigger region-specific effects
                    this.bus.emit('region:entered', {
                        regionId: portal.userData.toRegion,
                        regionType: targetRegion.type
                    });

                    console.log(`üåü Teleported to ${targetRegion.type} region ${portal.userData.toRegion}`);
                }
            }

            createCosmicDust() {
                if (this.cosmicDust) return; // Already exists

                this.cosmicDust = new THREE.Group();
                this.renderer.scene.add(this.cosmicDust);

                // Create cosmic dust particles
                const dustCount = 200;
                const dustGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(dustCount * 3);
                const colors = new Float32Array(dustCount * 3);

                for (let i = 0; i < dustCount; i++) {
                    const i3 = i * 3;
                    // Random positions in space
                    positions[i3] = (Math.random() - 0.5) * 10000;
                    positions[i3 + 1] = (Math.random() - 0.5) * 10000;
                    positions[i3 + 2] = (Math.random() - 0.5) * 10000;

                    // Cosmic dust colors (blues, purples, whites)
                    const hue = 0.6 + Math.random() * 0.3; // Blue to purple range
                    const color = new THREE.Color().setHSL(hue, 0.3, 0.8);
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                }

                dustGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                dustGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const dustMaterial = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const dustParticles = new THREE.Points(dustGeometry, dustMaterial);
                this.cosmicDust.add(dustParticles);

                // Add some larger cosmic structures
                this.createCosmicStructures();
            }

            createCosmicStructures() {
                // Add some cosmic filaments/nebula structures
                for (let i = 0; i < 5; i++) {
                    const filamentGeometry = new THREE.TorusGeometry(500 + Math.random() * 1000, 50, 8, 32);
                    const filamentMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.7 + Math.random() * 0.3, 0.5, 0.3),
                        transparent: true,
                        opacity: 0.1,
                        side: THREE.DoubleSide
                    });

                    const filament = new THREE.Mesh(filamentGeometry, filamentMaterial);
                    filament.position.set(
                        (Math.random() - 0.5) * 8000,
                        (Math.random() - 0.5) * 8000,
                        (Math.random() - 0.5) * 8000
                    );
                    filament.rotation.random();

                    this.cosmicDust.add(filament);
                }
            }

            removeCosmicDust() {
                if (this.cosmicDust) {
                    this.renderer.scene.remove(this.cosmicDust);
                    this.cosmicDust = null;
                }
            }

            // Safe element accessor for updates
            updateElement(id, callback) {
                const el = $(id);
                if (el && callback) callback(el);
            }
        }

        // Enhanced Soul Dust Audio System with Real-time FFT Analysis
        class AudioSystem {
            constructor(bus) {
                this.bus = bus;
                this.active = false;
                this.ctx = null;
                this.analyser = null;
                this.freqData = null;
                this.timeData = null;
                this.sampleRate = 44100;

                // Soul Dust parameters
                this.soulDust = {
                    bass: 0,
                    mids: 0,
                    treble: 0,
                    centroid: 0,
                    complexity: 0,
                    dominantFreq: 0,
                    energy: 0
                };

                // Audio processing
                this.fftSize = 2048;
                this.smoothingTimeConstant = 0.8;

                // History for analysis
                this.history = [];
                this.maxHistory = 100;

                this.bus.on('ui:toggleAudio', enabled => enabled ? this.enable() : this.disable());
                this.bus.on('engine:update', ({ dt }) => this.update(dt));
            }

            async enable() {
                if (this.active) return;
                try {
                    console.log('[SoulDust] Initializing audio input...');
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: this.sampleRate
                        }
                    });

                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.sampleRate
                    });

                    const source = this.ctx.createMediaStreamSource(stream);

                    // Create analyser for frequency analysis
                    this.analyser = this.ctx.createAnalyser();
                    this.analyser.fftSize = this.fftSize;
                    this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;

                    // Create data arrays
                    this.freqData = new Uint8Array(this.analyser.frequencyBinCount);
                    this.timeData = new Uint8Array(this.analyser.frequencyBinCount);

                    // Connect audio graph
                    source.connect(this.analyser);

                    // Resume audio context if suspended
                    if (this.ctx.state === 'suspended') {
                        await this.ctx.resume();
                    }

                    this.active = true;
                    this.bus.emit('audio:enabled');
                    console.log('[SoulDust] Audio system active - voice becomes cosmic energy');

                    // Update UI
                    const audioStatus = $('audioStatus');
                    if (audioStatus) audioStatus.textContent = 'Soul Dust: Active';

                } catch (error) {
                    console.error('[SoulDust] Audio initialization failed:', error);
                    const audioStatus = $('audioStatus');
                    if (audioStatus) audioStatus.textContent = 'Soul Dust: Error';
                    throw error;
                }
            }

            disable() {
                if (this.ctx) {
                    this.ctx.close().catch(console.error);
                }
                this.active = false;
                this.bus.emit('audio:disabled');

                const audioStatus = $('audioStatus');
                if (audioStatus) audioStatus.textContent = 'Soul Dust: Off';

                console.log('[SoulDust] Audio system disabled');
            }

            update(dt) {
                if (!this.active || !this.analyser) return;

                try {
                    // Get frequency and time domain data
                    this.analyser.getByteFrequencyData(this.freqData);
                    this.analyser.getByteTimeDomainData(this.timeData);

                    // Analyze frequency bands
                    this.analyzeFrequencyBands();

                    // Calculate spectral features
                    this.calculateSpectralFeatures();

                    // Emit Soul Dust data
                    this.bus.emit('soulDust:update', {
                        ...this.soulDust,
                        rawFreqData: this.freqData,
                        rawTimeData: this.timeData
                    });

                    // Store in history for pattern analysis
                    this.updateHistory();

                } catch (error) {
                    console.error('[SoulDust] Update error:', error);
                }
            }

            analyzeFrequencyBands() {
                const nyquist = this.sampleRate / 2;
                const binSize = nyquist / this.freqData.length;

                // Define frequency ranges
                const ranges = {
                    bass: { min: 20, max: 250 },
                    mids: { min: 250, max: 4000 },
                    treble: { min: 4000, max: nyquist }
                };

                // Calculate energy in each band
                Object.keys(ranges).forEach(band => {
                    const range = ranges[band];
                    const startBin = Math.floor(range.min / binSize);
                    const endBin = Math.min(Math.floor(range.max / binSize), this.freqData.length);

                    let sum = 0;
                    let count = 0;

                    for (let i = startBin; i < endBin; i++) {
                        const amplitude = this.freqData[i] / 255;
                        sum += amplitude * amplitude; // Energy (power)
                        count++;
                    }

                    const energy = count > 0 ? sum / count : 0;
                    this.soulDust[band] = this.soulDust[band] * 0.8 + energy * 0.2; // Smooth
                });
            }

            calculateSpectralFeatures() {
                let centroidSum = 0;
                let totalEnergy = 0;
                let dominantFreq = 0;
                let maxAmplitude = 0;

                const nyquist = this.sampleRate / 2;
                const binSize = nyquist / this.freqData.length;

                for (let i = 0; i < this.freqData.length; i++) {
                    const amplitude = this.freqData[i] / 255;
                    const frequency = i * binSize;
                    const energy = amplitude * amplitude;

                    centroidSum += frequency * energy;
                    totalEnergy += energy;

                    if (amplitude > maxAmplitude) {
                        maxAmplitude = amplitude;
                        dominantFreq = frequency;
                    }
                }

                // Spectral centroid (brightness)
                this.soulDust.centroid = totalEnergy > 0 ? centroidSum / totalEnergy : 0;

                // Dominant frequency
                this.soulDust.dominantFreq = dominantFreq;

                // Overall energy
                this.soulDust.energy = totalEnergy / this.freqData.length;

                // Complexity (roughness) - based on variation in spectrum
                let complexity = 0;
                for (let i = 1; i < this.freqData.length; i++) {
                    const diff = Math.abs(this.freqData[i] - this.freqData[i-1]);
                    complexity += diff;
                }
                this.soulDust.complexity = complexity / (this.freqData.length * 255);
            }

            updateHistory() {
                this.history.push({ ...this.soulDust, timestamp: Date.now() });

                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }
            }

            // Get average Soul Dust over time window
            getAverageSoulDust(windowSeconds = 1.0) {
                const now = Date.now();
                const windowMs = windowSeconds * 1000;
                const relevant = this.history.filter(h => now - h.timestamp < windowMs);

                if (relevant.length === 0) return { ...this.soulDust };

                const avg = {
                    bass: 0, mids: 0, treble: 0,
                    centroid: 0, complexity: 0, dominantFreq: 0, energy: 0
                };

                relevant.forEach(h => {
                    Object.keys(avg).forEach(key => {
                        avg[key] += h[key] || 0;
                    });
                });

                Object.keys(avg).forEach(key => {
                    avg[key] /= relevant.length;
                });

                return avg;
            }

            // Dispose resources
            dispose() {
                this.disable();
                this.history = [];
            }
        }

        class RendererSystem {
            constructor(bus) {
                this.bus = bus;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 1, 1e7);
                this.renderer = new THREE.WebGLRenderer({
                    canvas: $('canvas'),
                    antialias: true,
                    powerPreference: 'high-performance',
                    logarithmicDepthBuffer: true
                });
                this.renderer.setSize(innerWidth, innerHeight);
                this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.05;

                this.composer = new EffectComposer(this.renderer);
                this.renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(this.renderPass);
                this.bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.9, 0.8, 0.9);
                this.composer.addPass(this.bloom);

                this.bus.on('engine:update', ({ dt }) => this.render(dt));
                window.addEventListener('resize', () => this.onResize());
            }

            render(dt) {
                this.composer.render();
            }

            onResize() {
                this.camera.aspect = innerWidth / innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(innerWidth, innerHeight);
                this.composer.setSize(innerWidth, innerHeight);
            }
        }

        class PlayerSystem {
            constructor(bus, camera, domElement) {
                this.bus = bus;
                this.camera = camera;
                this.mode = 'orbit';
                this.interactionMode = 'none';

                this.orbit = new OrbitControls(camera, domElement);
                this.orbit.enableDamping = true;
                this.orbit.dampingFactor = 0.06;
                this.orbit.maxDistance = 5e5;

                this.pointer = new PointerLockControls(camera, domElement);
                this.ship = new THREE.Group();
                this.velocity = new THREE.Vector3();
                this.keys = {};

                // Mouse interaction handling
                this.mouse = new THREE.Vector2();
                this.raycaster = new THREE.Raycaster();
                this.isMouseDown = false;

                domElement.addEventListener('click', () => {
                    if (this.mode === 'ship' || this.mode === 'cloudfp' || this.mode === 'void') {
                        this.requestPointerLock();
                    }
                });

                domElement.addEventListener('mousedown', (e) => {
                    this.isMouseDown = true;
                    if (this.interactionMode !== 'none') {
                        this.handleMouseInteraction(e, true);
                    }
                });

                domElement.addEventListener('mouseup', () => {
                    this.isMouseDown = false;
                });

                domElement.addEventListener('mousemove', (e) => {
                    // Update mouse position for raycasting
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                    if (this.isMouseDown && this.interactionMode !== 'none') {
                        this.handleMouseInteraction(e, false);
                    }
                });

                window.addEventListener('keydown', e => {
                    this.keys[e.code] = true;

                    // Special controls
                    if (e.code === 'KeyM') {
                        // Toggle headlamp
                        if (this.headLamp) {
                            this.headLamp.intensity = this.headLamp.intensity > 0 ? 0.0 : 1.2;
                        }
                    }
                    if (e.code === 'Space') {
                        // Jump in surface mode
                        if (this.mode === 'surface' && this.velocity) {
                            this.velocity.y += 50; // Jump impulse
                            e.preventDefault(); // Prevent page scroll
                        }
                    }

                    // F1-F5 Control Panel System
                    if (e.code === 'F1') {
                        e.preventDefault();
                        this.bus.emit('ui:togglePanel', 'main');
                    }
                    if (e.code === 'F2') {
                        e.preventDefault();
                        this.bus.emit('ui:togglePanel', 'audio');
                    }
                    if (e.code === 'F3') {
                        e.preventDefault();
                        this.bus.emit('ui:togglePanel', 'world');
                    }
                    if (e.code === 'F4') {
                        e.preventDefault();
                        this.bus.emit('ui:togglePanel', 'ai');
                    }
                    if (e.code === 'F5') {
                        e.preventDefault();
                        this.bus.emit('ui:togglePanel', 'settings');
                    }
                });
                window.addEventListener('keyup', e => this.keys[e.code] = false);

                bus.on('ui:setMode', mode => this.setMode(mode));
                bus.on('engine:update', ({ dt }) => this.update(dt));
            }

            setMode(mode) {
                this.mode = mode;
                this.orbit.enabled = mode === 'orbit';
                const isFP = mode === 'ship' || mode === 'cloudfp' || mode === 'void' || mode === 'surface';
                $('crosshair').style.opacity = isFP ? 1 : 0;

                if (!isFP && document.pointerLockElement) {
                    try { this.pointer.unlock(); } catch (e) {}
                }
            }

            requestPointerLock() {
                try {
                    this.pointer.lock();
                } catch (e) {
                    console.warn('Pointer lock failed:', e);
                }
            }

            handleMouseInteraction(event, isClick) {
                // Pass interaction to main simulation
                if (window.__app) {
                    window.__app.handleMouseInteraction(this.mouse, isClick);
                }
            }

            update(dt) {
                if (this.mode === 'orbit') {
                    this.orbit.update();
                    return;
                }

                if (this.mode === 'surface') {
                    // Surface mode with gravity and ground collision
                    const thrust = (this.keys['ShiftLeft'] ? 300 : 150) * dt;
                    const acc = new THREE.Vector3();

                    if (this.keys['KeyW']) acc.z -= thrust;
                    if (this.keys['KeyS']) acc.z += thrust;
                    if (this.keys['KeyA']) acc.x -= thrust;
                    if (this.keys['KeyD']) acc.x += thrust;

                    // Apply movement on horizontal plane
                    acc.applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, this.camera.rotation.y, 0)));
                    this.velocity.add(acc);

                    // Apply gravity
                    this.velocity.y -= 98 * dt; // Gravity

                    // Apply air resistance
                    this.velocity.multiplyScalar(0.95);

                    // Move camera
                    this.camera.position.add(this.velocity.clone().multiplyScalar(dt));

                    // Ground collision (simple - keep above terrain)
                    if (this.camera.position.y < -30) {
                        this.camera.position.y = -30;
                        this.velocity.y = 0;
                    }

                    return;
                }

                if (this.mode === 'ship' || this.mode === 'cloudfp' || this.mode === 'void') {
                    let thrust = (this.keys['ShiftLeft'] ? 520 : 220) * dt;
                    const acc = new THREE.Vector3();

                    if (this.keys['KeyW']) acc.z -= thrust;
                    if (this.keys['KeyS']) acc.z += thrust;
                    if (this.keys['KeyA']) acc.x -= thrust;
                    if (this.keys['KeyD']) acc.x += thrust;
                    if (this.keys['KeyE']) acc.y += thrust;
                    if (this.keys['KeyQ']) acc.y -= thrust;

                    // Special handling for different modes
                    if (this.mode === 'cloudfp') {
                        // Cloud FP: slower, more buoyant movement
                        thrust *= 0.7;
                        this.velocity.y *= 0.95; // More buoyancy
                    } else if (this.mode === 'void') {
                        // Void Walker: enhanced movement with connectivity
                        thrust *= this.voidThrustMultiplier || 1.3;
                        this.velocity.multiplyScalar(this.voidDamping || 0.99);

                        // Check for portal interactions
                        this.checkPortalProximity();
                    }

                    this.velocity.add(acc.applyQuaternion(this.camera.quaternion));
                    this.velocity.multiplyScalar(this.mode === 'void' ? (this.voidDamping || 0.99) : 0.985);
                    this.camera.position.add(this.velocity.clone().multiplyScalar(dt));

                    this.ship.position.copy(this.camera.position);
                    this.ship.quaternion.copy(this.camera.quaternion);

                    const rollSpeed = 0.9 * dt;
                    if (this.keys['KeyR']) this.camera.rotateZ(-rollSpeed);
                    if (this.keys['KeyF']) this.camera.rotateZ(rollSpeed);
                }
            }
        }

        class CosmosSystem {
            constructor(bus, scene) {
                this.bus = bus;
                this.scene = scene;
                this.prng = sfc32(1, 2, 3, 4);
                this.params = { ec: 1.2, lambda: 0.25, li: 0.985, omega: 0.62, ugrav: 0.55 };
                this.attractors = [];
                this.points = null;
                this.count = 0;

                bus.on('param:changed', p => this.onParamChanged(p));
                bus.on('create:attractor', a => { if (a && a.position) this.attractors.push(a); });
                bus.on('update:attractor', update => {
                    if (update && update.index !== undefined && update.position && this.attractors[update.index]) {
                        this.attractors[update.index].position.copy(update.position);
                    }
                });
                bus.on('engine:update', ({ dt, now }) => this.update(dt, now));
                bus.on('simulation:start', () => this.generateGalaxy());
            }

            onParamChanged({ param, value }) {
                if (this.params.hasOwnProperty(param)) {
                    this.params[param] = value;
                    if (param === 'particleCount') {
                        this.resize(value);
                    } else {
                        this.applyAppearance();
                    }
                }
            }

            generateGalaxy() {
                const seed = Date.now().toString();
                const seedVals = cyrb128(seed);
                this.prng = sfc32(...seedVals);
                this.resize(50000);
            }

            resize(N) {
                if (this.points) {
                    this.scene.remove(this.points);
                    this.points.geometry.dispose();
                    this.points.material.dispose();
                }

                N = Math.max(2000, Math.min(200000, N));
                this.count = N;

                const pos = new Float32Array(N * 3);
                const col = new Float32Array(N * 3);
                this.vel = new Float32Array(N * 3);

                const inner = 300, outer = 2200;

                for (let i = 0; i < N; i++) {
                    const i3 = i * 3;
                    const r = inner + (outer - inner) * Math.cbrt(this.prng());
                    const th = this.prng() * Math.PI * 2;
                    const ph = Math.acos(this.prng() * 2 - 1);

                    pos[i3] = r * Math.sin(ph) * Math.cos(th);
                    pos[i3 + 1] = r * Math.cos(ph);
                    pos[i3 + 2] = r * Math.sin(ph) * Math.sin(th);

                    const c = new THREE.Color().setHSL(this.params.omega, 0.7, 0.6);
                    col[i3] = c.r;
                    col[i3 + 1] = c.g;
                    col[i3 + 2] = c.b;
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

                const mat = new THREE.PointsMaterial({
                    size: 0.7,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.92,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.points = new THREE.Points(geo, mat);
                this.points.frustumCulled = false;
                this.scene.add(this.points);

                this.applyAppearance();
            }

            applyAppearance() {
                if (!this.points?.material) return;
                this.points.material.size = 0.7 * this.params.ec;
                this.updateColors(this.params.omega);
            }

            updateColors(hue) {
                if (!this.points) return;
                const colArr = this.points.geometry.getAttribute('color').array;
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const c = new THREE.Color().setHSL(hue, 0.7, 0.6);
                    colArr[i3] = c.r;
                    colArr[i3 + 1] = c.g;
                    colArr[i3 + 2] = c.b;
                }
                this.points.geometry.getAttribute('color').needsUpdate = true;
            }

            update(dt) {
                if (!this.points) return;

                const p = this.points.geometry.getAttribute('position').array;
                const v = this.vel;
                const n = this.count;

                const chaos = this.params.lambda;
                const grav = this.params.ugrav;
                const invMass = 1 / Math.max(0.2, this.params.ec);
                const li = this.params.li;
                const G = 0.08;
                const soft = 0.1;

                for (let i = 0; i < n; i++) {
                    const i3 = i * 3;
                    let x = p[i3], y = p[i3 + 1], z = p[i3 + 2];
                    let vx = v[i3], vy = v[i3 + 1], vz = v[i3 + 2];
                    let ax = 0, ay = 0, az = 0;

                    const d2 = x * x + y * y + z * z + soft;
                    const invd = 1 / Math.sqrt(d2);
                    const f = (G * grav) / d2;
                    ax -= x * invd * f;
                    ay -= y * invd * f;
                    az -= z * invd * f;

                    for (const A of this.attractors) {
                        const ap = A.position;
                        const dx = ap.x - x, dy = ap.y - y, dz = ap.z - z;
                        const d2a = dx * dx + dy * dy + dz * dz + soft;
                        const invdA = 1 / Math.sqrt(d2a);
                        ax += (dx * invdA) * A.strength * invMass;
                        ay += (dy * invdA) * A.strength * invMass;
                        az += (dz * invdA) * A.strength * invMass;
                    }

                    ax += (this.prng() * 2 - 1) * chaos * invMass * 2.2;
                    ay += (this.prng() * 2 - 1) * chaos * invMass * 2.2;
                    az += (this.prng() * 2 - 1) * chaos * invMass * 2.2;

                    vx = (vx + ax * dt) * li;
                    vy = (vy + ay * dt) * li;
                    vz = (vz + az * dt) * li;

                    x += vx * dt;
                    y += vy * dt;
                    z += vz * dt;

                    p[i3] = x;
                    p[i3 + 1] = y;
                    p[i3 + 2] = z;
                    v[i3] = vx;
                    v[i3 + 1] = vy;
                    v[i3 + 2] = vz;
                }

                this.points.geometry.getAttribute('position').needsUpdate = true;
            }
        }

        class EnvironmentSystem {
            constructor(bus, scene) {
                this.bus = bus;
                this.scene = scene;
                this.sky = null;
                this.weather = null;
                this.time = 0; // Time in hours (0-24)
                this.season = 0; // 0=Spring, 1=Summer, 2=Autumn, 3=Winter
                this.weatherIntensity = 0.5;
                this.temperature = 20; // Celsius

                this.bus.on('simulation:start', () => this.init());
                this.bus.on('engine:update', ({ dt }) => this.update(dt));
                this.bus.on('param:changed', p => this.onParamChanged(p));
            }

            init() {
                // Initialize sky
                this.sky = new Sky();
                this.sky.scale.setScalar(450000);
                this.scene.add(this.sky);

                // Initialize basic lighting
                this.ambientLight = new THREE.AmbientLight(0x404040, 0.2);
                this.scene.add(this.ambientLight);

                this.directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                this.directionalLight.position.set(100, 100, 50);
                this.scene.add(this.directionalLight);

                // Create surface terrain
                this.createTerrain();
                this.createWater();
                this.createVegetation();
                this.createLifeForms();

                this.updateSky();
            }

            createTerrain() {
                // Create procedural terrain using noise
                const terrainSize = 2000;
                const segments = 128;
                const geometry = new THREE.PlaneGeometry(terrainSize, terrainSize, segments, segments);
                const vertices = geometry.attributes.position.array;

                // Apply height variation using simple noise
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i] / terrainSize;
                    const z = vertices[i + 2] / terrainSize;
                    // Simple noise-like height variation
                    const height = (Math.sin(x * 10) * Math.cos(z * 10) * 20) +
                                   (Math.sin(x * 20) * Math.cos(z * 20) * 10) +
                                   (Math.random() - 0.5) * 5;
                    vertices[i + 1] = height;
                }

                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();

                // Create terrain material based on season
                const material = new THREE.MeshLambertMaterial({
                    color: this.getSeasonColor(),
                    wireframe: false
                });

                this.terrain = new THREE.Mesh(geometry, material);
                this.terrain.rotation.x = -Math.PI / 2;
                this.terrain.position.y = -50;
                this.scene.add(this.terrain);
            }

            createWater() {
                // Create realistic water surface with wave animation
                const waterGeometry = new THREE.PlaneGeometry(2000, 2000, 128, 128);
                const waterMaterial = new THREE.ShaderMaterial({
                    transparent: true,
                    side: THREE.DoubleSide,
                    uniforms: {
                        uTime: { value: 0 },
                        uRoughness: { value: 0.05 },
                        uWindStrength: { value: 0.2 },
                        uWeatherIntensity: { value: 0.5 },
                        uCameraPos: { value: new THREE.Vector3() }
                    },
                    vertexShader: `
                        uniform float uTime, uRoughness, uWindStrength;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        varying vec2 vUv;

                        // Wave functions
                        float wave(vec2 uv, float time) {
                            float w1 = sin(uv.x * 0.01 + time * 2.0) * cos(uv.y * 0.01 + time * 1.5);
                            float w2 = sin(uv.x * 0.02 + time * 3.0) * cos(uv.y * 0.015 + time * 2.5);
                            float w3 = sin(uv.x * 0.005 + time * 1.0) * cos(uv.y * 0.008 + time * 0.8);
                            return (w1 * 0.5 + w2 * 0.3 + w3 * 0.2) * uRoughness * 50.0;
                        }

                        void main() {
                            vUv = uv;
                            vPosition = position;

                            // Apply wave displacement
                            vec3 pos = position;
                            pos.z += wave(pos.xy, uTime);

                            // Calculate normal for lighting
                            float dx = wave(pos.xy + vec2(0.1, 0.0), uTime) - wave(pos.xy - vec2(0.1, 0.0), uTime);
                            float dy = wave(pos.xy + vec2(0.0, 0.1), uTime) - wave(pos.xy - vec2(0.0, 0.1), uTime);
                            vNormal = normalize(vec3(-dx * 0.1, -dy * 0.1, 1.0));

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float uTime, uRoughness, uWindStrength, uWeatherIntensity;
                        uniform vec3 uCameraPos;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        varying vec2 vUv;

                        // Fresnel approximation
                        float fresnel(vec3 normal, vec3 viewDir) {
                            return pow(1.0 - max(dot(normal, viewDir), 0.0), 2.0);
                        }

                        void main() {
                            vec3 viewDir = normalize(uCameraPos - vPosition);
                            float fresnelFactor = fresnel(vNormal, viewDir);

                            // Base water color
                            vec3 deepColor = vec3(0.0, 0.1, 0.3);
                            vec3 shallowColor = vec3(0.0, 0.4, 0.8);
                            vec3 waterColor = mix(shallowColor, deepColor, fresnelFactor * 0.5);

                            // Add wave highlights
                            float wavePattern = sin(vUv.x * 20.0 + uTime * 3.0) * sin(vUv.y * 15.0 + uTime * 2.0);
                            wavePattern = smoothstep(0.0, 1.0, wavePattern * 0.5 + 0.5);
                            waterColor += vec3(1.0, 1.0, 0.8) * wavePattern * 0.3 * (1.0 - uRoughness);

                            // Weather effects
                            if (uWeatherIntensity > 0.7) {
                                // Stormy water
                                waterColor = mix(waterColor, vec3(0.1, 0.1, 0.2), uWeatherIntensity * 0.5);
                            }

                            // Wind foam
                            float foam = sin(vUv.x * 50.0 + uTime * uWindStrength * 10.0) *
                                       sin(vUv.y * 30.0 + uTime * uWindStrength * 8.0);
                            foam = smoothstep(0.7, 1.0, foam);
                            waterColor = mix(waterColor, vec3(0.9, 0.9, 1.0), foam * uWindStrength * 0.5);

                            gl_FragColor = vec4(waterColor, 0.8 - fresnelFactor * 0.3);
                        }
                    `
                });

                this.water = new THREE.Mesh(waterGeometry, waterMaterial);
                this.water.rotation.x = -Math.PI / 2;
                this.water.position.y = -30;
                this.scene.add(this.water);

                // Initialize wave animation
                this.waveTime = 0;
            }

            createVegetation() {
                this.vegetation = new THREE.Group();
                this.scene.add(this.vegetation);

                // Create realistic vegetation based on biome diversity
                this.createGrassAndHerbs();
                this.createTreesAndBushes();
                this.createFlowers();
                this.createMossAndGroundCover();
            }

            createGrassAndHerbs() {
                const grassCount = Math.floor(this.vegetationDensity * 300) + 50;

                for (let i = 0; i < grassCount; i++) {
                    // Create tufts of grass with multiple blades
                    const grassTuft = new THREE.Group();

                    const bladeCount = 3 + Math.floor(Math.random() * 5);
                    for (let j = 0; j < bladeCount; j++) {
                        const height = 4 + Math.random() * 6;
                        const bladeGeometry = new THREE.PlaneGeometry(0.3, height, 1, 8);
                        const bladeMaterial = new THREE.MeshLambertMaterial({
                            color: this.getGrassBladeColor(),
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.9
                        });

                        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                        blade.position.x = (Math.random() - 0.5) * 2;
                        blade.position.z = (Math.random() - 0.5) * 2;
                        blade.rotation.y = Math.random() * Math.PI * 2;
                        blade.rotation.z = (Math.random() - 0.5) * 0.3; // Slight bend

                        grassTuft.add(blade);
                    }

                    // Position the tuft
                    grassTuft.position.x = (Math.random() - 0.5) * 1800;
                    grassTuft.position.z = (Math.random() - 0.5) * 1800;
                    grassTuft.position.y = -40 + Math.random() * 5;

                    // Add wind animation data
                    grassTuft.userData = {
                        windPhase: Math.random() * Math.PI * 2,
                        windStrength: 0.5 + Math.random() * 0.5
                    };

                    // Store original rotations for individual blades
                    grassTuft.children.forEach(blade => {
                        blade.userData = {
                            originalRotation: blade.rotation.clone()
                        };
                    });

                    this.vegetation.add(grassTuft);
                }
            }

            createTreesAndBushes() {
                const treeCount = Math.floor(this.vegetationDensity * 40) + 10;
                const bushCount = Math.floor(this.vegetationDensity * 60) + 20;

                // Create trees
                for (let i = 0; i < treeCount; i++) {
                    const treeType = Math.random();

                    if (treeType < 0.6) {
                        // Oak-like tree
                        this.createOakTree();
                    } else if (treeType < 0.8) {
                        // Pine tree
                        this.createPineTree();
                    } else {
                        // Birch tree
                        this.createBirchTree();
                    }
                }

                // Create bushes
                for (let i = 0; i < bushCount; i++) {
                    this.createBush();
                }
            }

            createOakTree() {
                const tree = new THREE.Group();

                // Trunk
                const trunkHeight = 15 + Math.random() * 10;
                const trunkGeometry = new THREE.CylinderGeometry(2, 3, trunkHeight, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0.08, 0.6, 0.3) // Brown bark
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);

                // Canopy (multiple spheres for realistic shape)
                const canopyLayers = 2 + Math.floor(Math.random() * 2);
                for (let i = 0; i < canopyLayers; i++) {
                    const radius = 8 - i * 2 + Math.random() * 4;
                    const canopyGeometry = new THREE.SphereGeometry(radius, 8, 6);
                    const canopyMaterial = new THREE.MeshLambertMaterial({
                        color: this.getSeasonFoliageColor()
                    });
                    const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                    canopy.position.y = trunkHeight - 5 + i * 3;
                    canopy.position.x = (Math.random() - 0.5) * 3;
                    canopy.position.z = (Math.random() - 0.5) * 3;

                    tree.add(canopy);
                }

                tree.add(trunk);

                // Position
                tree.position.x = (Math.random() - 0.5) * 1200;
                tree.position.z = (Math.random() - 0.5) * 1200;
                tree.position.y = -40;

                this.vegetation.add(tree);
            }

            createPineTree() {
                const tree = new THREE.Group();

                // Trunk
                const trunkHeight = 12 + Math.random() * 8;
                const trunkGeometry = new THREE.CylinderGeometry(1.5, 2.5, trunkHeight, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0.08, 0.5, 0.25)
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);

                // Pine branches (cones stacked)
                const branchCount = 4 + Math.floor(Math.random() * 3);
                for (let i = 0; i < branchCount; i++) {
                    const radius = 6 - i * 1.2 + Math.random() * 2;
                    const height = 4 + Math.random() * 2;
                    const branchGeometry = new THREE.ConeGeometry(radius, height, 8);
                    const branchMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL(0.25, 0.8, 0.3) // Dark green pine
                    });
                    const branch = new THREE.Mesh(branchGeometry, branchMaterial);
                    branch.position.y = trunkHeight - 8 + i * 3;
                    branch.position.x = (Math.random() - 0.5) * 2;
                    branch.position.z = (Math.random() - 0.5) * 2;

                    tree.add(branch);
                }

                tree.add(trunk);

                tree.position.x = (Math.random() - 0.5) * 1200;
                tree.position.z = (Math.random() - 0.5) * 1200;
                tree.position.y = -40;

                this.vegetation.add(tree);
            }

            createBirchTree() {
                const tree = new THREE.Group();

                // Thin white trunk
                const trunkHeight = 18 + Math.random() * 8;
                const trunkGeometry = new THREE.CylinderGeometry(1, 1.5, trunkHeight, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0.0, 0.0, 0.9) // White bark
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);

                // Small rounded canopy
                const canopyGeometry = new THREE.SphereGeometry(10 + Math.random() * 5, 8, 6);
                const canopyMaterial = new THREE.MeshLambertMaterial({
                    color: this.getSeasonFoliageColor()
                });
                const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                canopy.position.y = trunkHeight - 3;

                tree.add(trunk);
                tree.add(canopy);

                tree.position.x = (Math.random() - 0.5) * 1200;
                tree.position.z = (Math.random() - 0.5) * 1200;
                tree.position.y = -40;

                this.vegetation.add(tree);
            }

            createBush() {
                const bush = new THREE.Group();

                // Multiple spheres for bush shape
                const sphereCount = 3 + Math.floor(Math.random() * 4);
                for (let i = 0; i < sphereCount; i++) {
                    const radius = 2 + Math.random() * 3;
                    const sphereGeometry = new THREE.SphereGeometry(radius, 6, 4);
                    const sphereMaterial = new THREE.MeshLambertMaterial({
                        color: this.getSeasonFoliageColor()
                    });
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

                    sphere.position.x = (Math.random() - 0.5) * 4;
                    sphere.position.y = Math.random() * 4;
                    sphere.position.z = (Math.random() - 0.5) * 4;

                    bush.add(sphere);
                }

                bush.position.x = (Math.random() - 0.5) * 1600;
                bush.position.z = (Math.random() - 0.5) * 1600;
                bush.position.y = -40;

                this.vegetation.add(bush);
            }

            createFlowers() {
                const flowerCount = Math.floor(this.vegetationDensity * 200) + 50;

                for (let i = 0; i < flowerCount; i++) {
                    const flowerType = Math.random();

                    if (flowerType < 0.4) {
                        this.createDaisy();
                    } else if (flowerType < 0.7) {
                        this.createTulip();
                    } else {
                        this.createWildflower();
                    }
                }
            }

            createDaisy() {
                const flower = new THREE.Group();

                // Stem
                const stemGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 4);
                const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);

                // White petals
                for (let i = 0; i < 8; i++) {
                    const petalGeometry = new THREE.PlaneGeometry(0.8, 1.5, 1, 2);
                    const petalMaterial = new THREE.MeshLambertMaterial({
                        color: 0xffffff,
                        side: THREE.DoubleSide
                    });
                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    petal.position.y = 2.8;
                    petal.rotation.y = (i / 8) * Math.PI * 2;
                    petal.position.x = Math.cos(petal.rotation.y) * 0.3;
                    petal.position.z = Math.sin(petal.rotation.y) * 0.3;

                    flower.add(petal);
                }

                // Yellow center
                const centerGeometry = new THREE.SphereGeometry(0.3, 6, 4);
                const centerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                const center = new THREE.Mesh(centerGeometry, centerMaterial);
                center.position.y = 2.8;

                flower.add(stem);
                flower.add(center);

                flower.position.x = (Math.random() - 0.5) * 1700;
                flower.position.z = (Math.random() - 0.5) * 1700;
                flower.position.y = -40;

                this.vegetation.add(flower);
            }

            createTulip() {
                const flower = new THREE.Group();

                // Stem
                const stemGeometry = new THREE.CylinderGeometry(0.15, 0.15, 4, 4);
                const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);

                // Tulip cup
                const cupGeometry = new THREE.CylinderGeometry(0.8, 0.2, 2, 8);
                const cupMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.2 + 0.9, 0.8, 0.6) // Red/pink/purple
                });
                const cup = new THREE.Mesh(cupGeometry, cupMaterial);
                cup.position.y = 3.5;

                flower.add(stem);
                flower.add(cup);

                flower.position.x = (Math.random() - 0.5) * 1700;
                flower.position.z = (Math.random() - 0.5) * 1700;
                flower.position.y = -40;

                this.vegetation.add(flower);
            }

            createWildflower() {
                const flower = new THREE.Group();

                // Stem
                const stemGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 3);
                const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);

                // Random colored flower
                const flowerGeometry = new THREE.SphereGeometry(0.4, 6, 4);
                const flowerMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6)
                });
                const flowerHead = new THREE.Mesh(flowerGeometry, flowerMaterial);
                flowerHead.position.y = 1.8;

                flower.add(stem);
                flower.add(flowerHead);

                flower.position.x = (Math.random() - 0.5) * 1700;
                flower.position.z = (Math.random() - 0.5) * 1700;
                flower.position.y = -40;

                this.vegetation.add(flower);
            }

            createMossAndGroundCover() {
                const mossCount = Math.floor(this.vegetationDensity * 150) + 30;

                for (let i = 0; i < mossCount; i++) {
                    const mossGeometry = new THREE.PlaneGeometry(
                        5 + Math.random() * 10,
                        5 + Math.random() * 10,
                        2, 2
                    );
                    const mossMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.6, 0.2),
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });

                    const moss = new THREE.Mesh(mossGeometry, mossMaterial);
                    moss.rotation.x = -Math.PI / 2;
                    moss.position.x = (Math.random() - 0.5) * 1900;
                    moss.position.z = (Math.random() - 0.5) * 1900;
                    moss.position.y = -39.5 + Math.random() * 0.5; // Just above ground

                    this.vegetation.add(moss);
                }
            }

            getGrassBladeColor() {
                const baseColor = this.getSeasonGrassColor();
                // Add slight variation for realism
                const variation = (Math.random() - 0.5) * 0.1;
                return new THREE.Color().setHex(baseColor).offsetHSL(variation, 0, 0).getHex();
            }

            createLifeForms() {
                this.lifeForms = new THREE.Group();
                this.scene.add(this.lifeForms);

                // Create diverse life forms based on lifeForms parameter
                const totalLifeForms = Math.floor(this.lifeFormsDensity * 50) + 10;

                // Humans (10%)
                const humanCount = Math.floor(totalLifeForms * 0.1);
                for (let i = 0; i < humanCount; i++) {
                    this.createHuman();
                }

                // Large animals (20%)
                const largeAnimalCount = Math.floor(totalLifeForms * 0.2);
                for (let i = 0; i < largeAnimalCount; i++) {
                    this.createLargeAnimal();
                }

                // Small animals (30%)
                const smallAnimalCount = Math.floor(totalLifeForms * 0.3);
                for (let i = 0; i < smallAnimalCount; i++) {
                    this.createSmallAnimal();
                }

                // Birds (15%)
                const birdCount = Math.floor(totalLifeForms * 0.15);
                for (let i = 0; i < birdCount; i++) {
                    this.createBird();
                }

                // Insects and small creatures (25%)
                const insectCount = Math.floor(totalLifeForms * 0.25);
                for (let i = 0; i < insectCount; i++) {
                    this.createInsect();
                }
            }

            createHuman() {
                const human = new THREE.Group();

                // Body proportions based on golden ratio
                const phi = (1 + Math.sqrt(5)) / 2;

                // Torso
                const torsoGeometry = new THREE.CapsuleGeometry(1.5, 3, 4, 8);
                const torsoMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.1, 0.3, 0.6) // Skin tones
                });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);

                // Head
                const headGeometry = new THREE.SphereGeometry(1, 8, 6);
                const headMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.1, 0.4, 0.7)
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.5;

                // Arms
                const armGeometry = new THREE.CapsuleGeometry(0.4, 2, 3, 6);
                const armMaterial = new THREE.MeshLambertMaterial({
                    color: torsoMaterial.color.clone().offsetHSL(0, -0.1, -0.1)
                });

                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-2, 0.5, 0);
                leftArm.rotation.z = Math.PI / 6;

                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(2, 0.5, 0);
                rightArm.rotation.z = -Math.PI / 6;

                // Legs
                const legGeometry = new THREE.CapsuleGeometry(0.5, 2.5, 3, 6);
                const leftLeg = new THREE.Mesh(legGeometry, armMaterial);
                leftLeg.position.set(-0.8, -2.5, 0);

                const rightLeg = new THREE.Mesh(legGeometry, armMaterial);
                rightLeg.position.set(0.8, -2.5, 0);

                human.add(torso);
                human.add(head);
                human.add(leftArm);
                human.add(rightArm);
                human.add(leftLeg);
                human.add(rightLeg);

                // Random position and activity
                human.position.x = (Math.random() - 0.5) * 1400;
                human.position.z = (Math.random() - 0.5) * 1400;
                human.position.y = -35;

                // Animation data
                human.userData = {
                    type: 'human',
                    activity: Math.random() > 0.5 ? 'walking' : 'standing',
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 0.5
                };

                this.lifeForms.add(human);
            }

            createLargeAnimal() {
                const animalType = Math.random();

                if (animalType < 0.3) {
                    this.createDeer();
                } else if (animalType < 0.6) {
                    this.createWolf();
                } else {
                    this.createBear();
                }
            }

            getSeasonColor() {
                const colors = [
                    0x4ade80, // Spring - green
                    0xf59e0b, // Summer - golden
                    0xea580c, // Autumn - orange
                    0xf3f4f6  // Winter - light gray
                ];
                return colors[this.season] || 0x4ade80;
            }

            getSeasonGrassColor() {
                const colors = [
                    0x22c55e, // Spring - bright green
                    0x84cc16, // Summer - yellow-green
                    0xd97706, // Autumn - orange-brown
                    0x9ca3af  // Winter - gray
                ];
                return colors[this.season] || 0x22c55e;
            }

            getSeasonFoliageColor() {
                const colors = [
                    0x16a34a, // Spring - dark green
                    0x15803d, // Summer - deeper green
                    0xea580c, // Autumn - orange
                    0x6b7280  // Winter - gray
                ];
                return colors[this.season] || 0x16a34a;
            }

            onParamChanged({ param, value }) {
                switch (param) {
                    case 'timeOfDay':
                        this.time = value;
                        this.updateSky();
                        break;
                    case 'season':
                        this.season = value;
                        this.updateSky();
                        this.updateSeasonalColors();
                        break;
                    case 'lightIntensity':
                        if (this.directionalLight) {
                            this.directionalLight.intensity = value;
                        }
                        break;
                    case 'weatherIntensity':
                        this.weatherIntensity = value;
                        if (this.water?.material.uniforms) {
                            this.water.material.uniforms.uWeatherIntensity.value = value;
                        }
                        break;
                    case 'oceanRoughness':
                        this.oceanRoughness = value;
                        if (this.water?.material.uniforms) {
                            this.water.material.uniforms.uRoughness.value = value;
                        }
                        break;
                    case 'windStrength':
                        this.windStrength = value;
                        if (this.water?.material.uniforms) {
                            this.water.material.uniforms.uWindStrength.value = value;
                        }
                        // Also affect vegetation wind animation
                        this.updateWindOnVegetation(value);
                        break;
                    case 'vegetationDensity':
                        this.vegetationDensity = value;
                        this.updateVegetationDensity();
                        break;
                    case 'biomeDiversity':
                        this.biomeDiversity = value;
                        this.updateBiomeDiversity();
                        break;
                    case 'lifeForms':
                        this.lifeFormsDensity = value;
                        this.updateLifeFormsDensity();
                        break;
                }
            }

            update(dt) {
                // Update time (very slow cycle for demo purposes)
                this.time += dt * 0.001; // 1 real second = ~1 game hour
                if (this.time >= 24) {
                    this.time = 0;
                    // Update season occasionally
                    if (Math.random() < 0.01) {
                        this.season = (this.season + 1) % 4;
                    }
                }

                // Update temperature based on time and season
                this.updateTemperature();
                this.updateSky();

                // Update UI displays
                this.updateUI();
            }

            updateTemperature() {
                // Base temperature by season
                const seasonBase = [15, 25, 15, 5][this.season]; // Spring, Summer, Autumn, Winter

                // Daily temperature variation (cooler at night)
                const timeFactor = Math.sin((this.time / 24) * Math.PI * 2 - Math.PI / 2) * 0.5 + 0.5;
                const dailyVariation = -10 + timeFactor * 20; // -10 to +10

                this.temperature = seasonBase + dailyVariation;
            }

            updateSky() {
                if (!this.sky) return;

                const uniforms = this.sky.material.uniforms;

                // Time-based sky parameters
                const timeOfDay = this.time / 24; // 0 to 1

                // Sun position based on time
                const sunAngle = (timeOfDay - 0.5) * Math.PI; // -œÄ/2 to œÄ/2
                const sunHeight = Math.sin(sunAngle);
                const sunAzimuth = timeOfDay * Math.PI * 2;

                const sunPosition = new THREE.Vector3(
                    Math.cos(sunAzimuth) * Math.cos(sunAngle) * 1000,
                    sunHeight * 1000,
                    Math.sin(sunAzimuth) * Math.cos(sunAngle) * 1000
                );

                uniforms['sunPosition'].value.copy(sunPosition);

                // Atmospheric parameters based on season and weather
                const seasonTurbidity = [8, 12, 10, 6][this.season]; // Clear spring, hazy summer, moderate autumn, crisp winter
                const weatherTurbidity = 2 + this.weatherIntensity * 8; // Weather adds haze

                uniforms['turbidity'].value = seasonTurbidity + weatherTurbidity;
                uniforms['rayleigh'].value = 2 + this.weatherIntensity * 1;

                // Update lighting based on sun position
                if (this.directionalLight) {
                    const lightIntensity = Math.max(0.1, sunHeight * 0.8 + 0.2);
                    this.directionalLight.intensity = lightIntensity;
                    this.directionalLight.position.copy(sunPosition).normalize().multiplyScalar(1000);

                    // Set light color based on time of day
                    const hour = this.time;
                    let lightColor;
                    if (hour < 6 || hour > 20) {
                        // Night - cool blue
                        lightColor = new THREE.Color(0x4a5568);
                    } else if (hour < 8 || hour > 18) {
                        // Dawn/Dusk - warm orange
                        lightColor = new THREE.Color(0xf59e0b);
                    } else {
                        // Day - warm white
                        lightColor = new THREE.Color(0xffffff);
                    }
                    this.directionalLight.color = lightColor;
                }

                // Update ambient light based on time
                if (this.ambientLight) {
                    const ambientIntensity = Math.max(0.1, sunHeight * 0.3 + 0.1);
                    this.ambientLight.intensity = ambientIntensity;
                    this.ambientLight.color.setHSL(0.6, 0.2, Math.max(0.2, sunHeight * 0.3 + 0.2));
                }
            }

            updateUI() {
                // Update HUD displays
                const timeStr = this.formatTime(this.time);
                const seasonNames = ['Spring', 'Summer', 'Autumn', 'Winter'];

                const hudTime = $('hudTime');
                const hudOcean = $('hudOcean');
                const hudCloud = $('hudCloud');
                const hudVeg = $('hudVeg');
                const hudWind = $('hudWind');

                if (hudTime) hudTime.textContent = timeStr;

                // Update environmental HUD if in surface mode
                if (this.bus) {
                    const oceanRoughness = 0.05 + this.weatherIntensity * 0.1;
                    const cloudCoverage = Math.floor((0.2 + this.weatherIntensity * 0.3) * 100);
                    const vegetation = Math.floor((0.8 + (this.temperature - 10) / 30) * 100);
                    const windSpeed = Math.floor(this.weatherIntensity * 20);

                    if (hudOcean) hudOcean.textContent = oceanRoughness.toFixed(2);
                    if (hudCloud) hudCloud.textContent = `${cloudCoverage}%`;
                    if (hudVeg) hudVeg.textContent = `${vegetation}%`;
                    if (hudWind) hudWind.textContent = `${windSpeed} km/h`;
                }

                // Animate life forms
                this.animateLifeForms(dt);

                // Animate water waves
                this.animateWater(dt);

                // Animate wind effects on vegetation
                this.animateWindOnVegetation(dt);
            }

            updateWindOnVegetation(windStrength) {
                // Update wind parameters for all vegetation
                if (this.vegetation) {
                    this.vegetation.children.forEach(obj => {
                        if (obj.userData && obj.userData.windStrength !== undefined) {
                            obj.userData.windStrength = windStrength * (0.5 + Math.random() * 0.5);
                        }
                    });
                }
            }

            animateWindOnVegetation(dt) {
                if (!this.vegetation) return;

                const windTime = Date.now() * 0.001;

                this.vegetation.children.forEach(obj => {
                    if (obj.userData && obj.userData.windPhase !== undefined) {
                        // Grass and plants sway in wind
                        const windEffect = Math.sin(windTime * 2 + obj.userData.windPhase) *
                                         obj.userData.windStrength * 0.1;

                        if (obj.children && obj.children.length > 0 && obj.children[0].geometry?.type === 'PlaneGeometry') {
                            // For grass tufts, sway individual blades
                            obj.children.forEach(blade => {
                                if (blade.rotation && blade.userData?.originalRotation) {
                                    blade.rotation.z = blade.userData.originalRotation.z +
                                                     windEffect * (0.5 + Math.random() * 0.5);
                                }
                            });
                        } else if (obj.rotation) {
                            // For trees and bushes, gentle trunk sway
                            if (!obj.userData.originalRotation) {
                                obj.userData.originalRotation = obj.rotation.clone();
                            }
                            obj.rotation.z = obj.userData.originalRotation.z +
                                           windEffect * 0.05;
                        }
                    }
                });
            }

            animateWater(dt) {
                if (!this.water || !this.water.material.uniforms) return;

                this.waveTime += dt;

                // Update water shader uniforms
                this.water.material.uniforms.uTime.value = this.waveTime;
                this.water.material.uniforms.uRoughness.value = this.oceanRoughness || 0.05;
                this.water.material.uniforms.uWindStrength.value = this.windStrength || 0.2;
                this.water.material.uniforms.uWeatherIntensity.value = this.weatherIntensity || 0.5;
                this.water.material.uniforms.uCameraPos.value.copy(this.scene.userData.camera?.position || new THREE.Vector3());
            }

            updateSeasonalColors() {
                if (this.terrain && this.terrain.material) {
                    this.terrain.material.color.setHex(this.getSeasonColor());
                }

                if (this.vegetation) {
                    this.vegetation.children.forEach(obj => {
                        if (obj.type === 'Mesh' && obj.material) {
                            // Grass
                            obj.material.color.setHex(this.getSeasonGrassColor());
                        } else if (obj.children && obj.children.length >= 2) {
                            // Tree foliage
                            const foliage = obj.children[1];
                            if (foliage && foliage.material) {
                                foliage.material.color.setHex(this.getSeasonFoliageColor());
                            }
                        }
                    });
                }
            }

            updateVegetationDensity() {
                if (!this.vegetation) return;

                const targetDensity = this.vegetationDensity || 0.8;
                const currentCount = this.vegetation.children.length;
                const targetCount = Math.floor(targetDensity * 120); // 0-120 objects

                if (currentCount < targetCount) {
                    // Add more vegetation
                    for (let i = currentCount; i < targetCount && i < 120; i++) {
                        const grassGeometry = new THREE.ConeGeometry(2, 8, 6);
                        const grassMaterial = new THREE.MeshLambertMaterial({
                            color: this.getSeasonGrassColor()
                        });

                        const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                        grass.position.x = (Math.random() - 0.5) * 1500;
                        grass.position.z = (Math.random() - 0.5) * 1500;
                        grass.position.y = -40 + Math.random() * 10;

                        this.vegetation.add(grass);
                    }
                } else if (currentCount > targetCount) {
                    // Remove excess vegetation
                    for (let i = currentCount - 1; i >= targetCount && i >= 0; i--) {
                        this.vegetation.remove(this.vegetation.children[i]);
                    }
                }
            }

            updateBiomeDiversity() {
                // This would change the types and colors of vegetation based on biome diversity
                // For now, just update colors based on diversity
                if (this.vegetation) {
                    const diversity = this.biomeDiversity || 0.6;
                    this.vegetation.children.forEach(obj => {
                        if (obj.type === 'Mesh' && obj.material) {
                            // Vary colors based on diversity
                            const baseColor = this.getSeasonGrassColor();
                            const variation = (diversity - 0.5) * 0.3;
                            const r = ((baseColor >> 16) & 0xff) * (1 + variation * (Math.random() - 0.5));
                            const g = ((baseColor >> 8) & 0xff) * (1 + variation * (Math.random() - 0.5));
                            const b = (baseColor & 0xff) * (1 + variation * (Math.random() - 0.5));

                            obj.material.color.setRGB(
                                Math.max(0, Math.min(1, r / 255)),
                                Math.max(0, Math.min(1, g / 255)),
                                Math.max(0, Math.min(1, b / 255))
                            );
                        }
                    });
                }
            }

            updateLifeFormsDensity() {
                if (!this.lifeForms) return;

                const targetDensity = this.lifeFormsDensity || 0.4;
                const currentCount = this.lifeForms.children.length;
                const targetCount = Math.floor(targetDensity * 30); // 0-30 life forms

                if (currentCount < targetCount) {
                    // Add more life forms
                    for (let i = currentCount; i < targetCount && i < 30; i++) {
                        const animalGeometry = new THREE.SphereGeometry(3, 8, 6);
                        const animalMaterial = new THREE.MeshLambertMaterial({
                            color: Math.random() > 0.5 ? 0xff6b6b : 0x4ecdc4
                        });

                        const animal = new THREE.Mesh(animalGeometry, animalMaterial);
                        animal.position.x = (Math.random() - 0.5) * 1200;
                        animal.position.z = (Math.random() - 0.5) * 1200;
                        animal.position.y = -35 + Math.random() * 5;

                        animal.userData = {
                            originalY: animal.position.y,
                            phase: Math.random() * Math.PI * 2
                        };

                        this.lifeForms.add(animal);
                    }
                } else if (currentCount > targetCount) {
                    // Remove excess life forms
                    for (let i = currentCount - 1; i >= targetCount && i >= 0; i--) {
                        this.lifeForms.remove(this.lifeForms.children[i]);
                    }
                }
            }

            animateLifeForms(dt) {
                if (!this.lifeForms) return;

                this.lifeForms.children.forEach(creature => {
                    if (creature.userData) {
                        creature.userData.phase += dt * creature.userData.speed;

                        switch (creature.userData.type) {
                            case 'human':
                                // Human walking/running animation
                                if (creature.userData.activity === 'walking') {
                                    // Simple bobbing motion
                                    creature.position.y = -35 + Math.sin(creature.userData.phase * 4) * 0.5;

                                    // Arm swing
                                    if (creature.children.length >= 4) {
                                        const leftArm = creature.children[2]; // left arm
                                        const rightArm = creature.children[3]; // right arm
                                        leftArm.rotation.x = Math.sin(creature.userData.phase * 4) * 0.5;
                                        rightArm.rotation.x = -Math.sin(creature.userData.phase * 4) * 0.5;
                                    }

                                    // Slow movement
                                    creature.position.x += Math.sin(creature.userData.phase * 0.5) * 0.1;
                                    creature.position.z += Math.cos(creature.userData.phase * 0.3) * 0.1;
                                }
                                break;

                            case 'deer':
                            case 'wolf':
                            case 'bear':
                                // Large animal movement - more ground-based
                                creature.position.y = -35 + Math.sin(creature.userData.phase * 3) * 0.3;
                                creature.position.x += Math.sin(creature.userData.phase * 0.2) * 0.05;
                                creature.position.z += Math.cos(creature.userData.phase * 0.15) * 0.05;

                                // Head bobbing
                                if (creature.children[1]) { // head
                                    creature.children[1].rotation.x = Math.sin(creature.userData.phase * 3) * 0.1;
                                }
                                break;

                            case 'rabbit':
                                // Rabbit hopping animation
                                const hopCycle = Math.sin(creature.userData.phase * 6);
                                creature.position.y = -35 + Math.abs(hopCycle) * creature.userData.hopHeight;

                                // Hopping movement
                                if (Math.abs(hopCycle) > 0.8) {
                                    creature.position.x += Math.sin(creature.userData.phase * 2) * 0.3;
                                    creature.position.z += Math.cos(creature.userData.phase * 1.8) * 0.3;
                                }

                                // Ear flapping
                                if (creature.children.length >= 4) {
                                    const leftEar = creature.children[2];
                                    const rightEar = creature.children[3];
                                    leftEar.rotation.z = Math.sin(creature.userData.phase * 8) * 0.2;
                                    rightEar.rotation.z = -Math.sin(creature.userData.phase * 8) * 0.2;
                                }
                                break;

                            case 'fox':
                            case 'raccoon':
                                // Small mammal movement
                                creature.position.y = -35 + Math.sin(creature.userData.phase * 4) * 0.2;
                                creature.position.x += Math.sin(creature.userData.phase * 0.3) * 0.08;
                                creature.position.z += Math.cos(creature.userData.phase * 0.25) * 0.08;

                                // Tail wagging
                                creature.children.forEach(child => {
                                    if (child.position.z < -1) { // tail
                                        child.rotation.y = Math.sin(creature.userData.phase * 5) * 0.3;
                                    }
                                });
                                break;

                            case 'bird':
                                // Bird flight patterns
                                if (creature.userData.flightPattern === 'circle') {
                                    // Circular flight
                                    const radius = 20 + Math.sin(creature.userData.phase * 0.1) * 10;
                                    creature.position.x = Math.cos(creature.userData.phase * 0.5) * radius;
                                    creature.position.z = Math.sin(creature.userData.phase * 0.5) * radius;
                                    creature.position.y = -20 + Math.sin(creature.userData.phase * 2) * 5;
                                } else {
                                    // Straight flight with bobbing
                                    creature.position.x += Math.sin(creature.userData.phase * 0.8) * 0.5;
                                    creature.position.z += Math.cos(creature.userData.phase * 0.6) * 0.5;
                                    creature.position.y = -20 + Math.sin(creature.userData.phase * 3) * 3;
                                }

                                // Wing flapping
                                if (creature.children.length >= 3) {
                                    const leftWing = creature.children[1];
                                    const rightWing = creature.children[2];
                                    const flap = Math.sin(creature.userData.phase * 15) * 0.5;
                                    leftWing.rotation.x = flap;
                                    rightWing.rotation.x = -flap;
                                }

                                // Wrap around world
                                if (Math.abs(creature.position.x) > 1000) creature.position.x *= -0.9;
                                if (Math.abs(creature.position.z) > 1000) creature.position.z *= -0.9;
                                break;

                            case 'butterfly':
                                // Butterfly delicate flight
                                creature.position.x += Math.sin(creature.userData.phase * 0.3) * 0.1;
                                creature.position.z += Math.cos(creature.userData.phase * 0.25) * 0.1;
                                creature.position.y += Math.sin(creature.userData.phase * 0.8) * 0.5;

                                // Wing animation
                                creature.userData.wingPhase += dt * 20;
                                if (creature.children.length >= 5) {
                                    const wings = [creature.children[1], creature.children[2], creature.children[3], creature.children[4]];
                                    wings.forEach((wing, i) => {
                                        const offset = i * Math.PI / 2;
                                        wing.rotation.z = Math.sin(creature.userData.wingPhase + offset) * 0.3;
                                        wing.rotation.y = Math.sin(creature.userData.wingPhase + offset) * 0.2;
                                    });
                                }
                                break;

                            case 'bee':
                                // Bee buzzing flight
                                creature.position.x += Math.sin(creature.userData.phase * 1.5) * 0.15;
                                creature.position.z += Math.cos(creature.userData.phase * 1.3) * 0.15;
                                creature.position.y += Math.sin(creature.userData.phase * 4) * 0.3;

                                // Wing buzzing
                                if (creature.children.length >= 4) {
                                    const leftWing = creature.children[2];
                                    const rightWing = creature.children[3];
                                    const buzz = Math.sin(creature.userData.phase * creature.userData.wingFrequency) * 0.8;
                                    leftWing.rotation.z = buzz;
                                    rightWing.rotation.z = -buzz;
                                }
                                break;

                            default:
                                // Generic floating animation for unknown types
                                creature.position.y = (creature.userData.originalY || creature.position.y) +
                                                     Math.sin(creature.userData.phase) * 1;
                                creature.position.x += Math.sin(creature.userData.phase * 0.5) * 0.05;
                                creature.position.z += Math.cos(creature.userData.phase * 0.7) * 0.05;
                                break;
                        }

                        // Keep creatures within reasonable bounds
                        creature.position.x = Math.max(-2000, Math.min(2000, creature.position.x));
                        creature.position.z = Math.max(-2000, Math.min(2000, creature.position.z));
                        creature.position.y = Math.max(-100, Math.min(100, creature.position.y));
                    }
                });
            }

            createInsect() {
                const insectType = Math.random();

                if (insectType < 0.5) {
                    this.createButterfly();
                } else {
                    this.createBee();
                }
            }

            createButterfly() {
                const butterfly = new THREE.Group();

                // Body
                const bodyGeometry = new THREE.CylinderGeometry(0.05, 0.03, 0.8, 4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);

                // Wings
                const wingGeometry = new THREE.PlaneGeometry(1.2, 1.5, 3, 2);
                const wingColors = [0xFF1493, 0x00BFFF, 0xFFD700, 0xFF69B4, 0x9370DB];
                const wingColor = wingColors[Math.floor(Math.random() * wingColors.length)];
                const wingMaterial = new THREE.MeshLambertMaterial({
                    color: wingColor,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });

                const leftUpperWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftUpperWing.position.set(-0.8, 0.2, 0);
                leftUpperWing.rotation.y = Math.PI / 8;

                const rightUpperWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightUpperWing.position.set(0.8, 0.2, 0);
                rightUpperWing.rotation.y = -Math.PI / 8;

                const leftLowerWing = new THREE.Mesh(wingGeometry.clone(), wingMaterial);
                leftLowerWing.position.set(-0.6, -0.2, 0);
                leftLowerWing.rotation.y = Math.PI / 6;

                const rightLowerWing = new THREE.Mesh(wingGeometry.clone(), wingMaterial);
                rightLowerWing.position.set(0.6, -0.2, 0);
                rightLowerWing.rotation.y = -Math.PI / 6;

                butterfly.add(body);
                butterfly.add(leftUpperWing);
                butterfly.add(rightUpperWing);
                butterfly.add(leftLowerWing);
                butterfly.add(rightLowerWing);

                butterfly.position.x = (Math.random() - 0.5) * 1800;
                butterfly.position.z = (Math.random() - 0.5) * 1800;
                butterfly.position.y = -25 + Math.random() * 20;

                butterfly.userData = {
                    type: 'butterfly',
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.2 + Math.random() * 0.3,
                    wingPhase: Math.random() * Math.PI * 2
                };

                this.lifeForms.add(butterfly);
            }

            createBee() {
                const bee = new THREE.Group();

                // Body segments
                const abdomenGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.6, 6);
                const abdomenMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const abdomen = new THREE.Mesh(abdomenGeometry, abdomenMaterial);

                const thoraxGeometry = new THREE.SphereGeometry(0.12, 6, 4);
                const thoraxMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                const thorax = new THREE.Mesh(thoraxGeometry, thoraxMaterial);
                thorax.position.z = 0.3;

                // Wings
                const wingGeometry = new THREE.PlaneGeometry(0.4, 0.6, 1, 1);
                const wingMaterial = new THREE.MeshLambertMaterial({
                    color: 0xE6E6FA,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });

                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.2, 0.1, 0.2);

                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.2, 0.1, 0.2);

                bee.add(abdomen);
                bee.add(thorax);
                bee.add(leftWing);
                bee.add(rightWing);

                bee.position.x = (Math.random() - 0.5) * 1700;
                bee.position.z = (Math.random() - 0.5) * 1700;
                bee.position.y = -25 + Math.random() * 15;

                bee.userData = {
                    type: 'bee',
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.4 + Math.random() * 0.4,
                    wingFrequency: 20 + Math.random() * 10
                };

                this.lifeForms.add(bee);
            }

            formatTime(hours) {
                const h = Math.floor(hours);
                const m = Math.floor((hours % 1) * 60);
                return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }

            getWeatherData() {
                return {
                    time: this.time,
                    season: this.season,
                    temperature: this.temperature,
                    weatherIntensity: this.weatherIntensity,
                    cloudCoverage: 0.2 + this.weatherIntensity * 0.3,
                    windSpeed: this.weatherIntensity * 20,
                    humidity: 0.35 + this.season * 0.1
                };
            }
        }

        class AISystem {
            constructor(bus, scene) {
                this.bus = bus;
                this.scene = scene;
                this.objects = [];
                this.consciousness = 0.1;
                this.creativity = 0.3;
                this.adaptability = 0.2;
                this.crystal = null;
                this.neuralLinks = 0;
                this.evolutionActive = false;
                this.soulData = null;

                // Autonomous creation system
                this.memory = new Map();
                this.intentions = [];
                this.lastCreation = 0;
                this.creationCooldown = 5000; // 5 seconds between autonomous creations
                this.mood = 'curious';
                this.energy = 1.0;

                // Learning system
                this.behaviorPatterns = new Map();
                this.environmentalData = [];
                this.userInteractions = [];

                this.bus.on('ai:create', data => this.createObject(data));
                this.bus.on('param:changed', p => {
                    if (p.param === 'consciousness') this.consciousness = p.value;
                    if (p.param === 'creativity') this.creativity = p.value;
                    if (p.param === 'adaptability') this.adaptability = p.value;
                });
                this.bus.on('engine:update', ({ dt }) => this.update(dt));
                this.bus.on('simulation:start', () => this.onSimulationStart());

                // Listen to environmental data for autonomous decisions
                this.bus.on('soulDust:update', data => this.processSoulDust(data));
                this.bus.on('param:changed', data => this.recordEnvironmentalChange(data));
                this.bus.on('mode:changed', mode => this.recordUserAction('mode_change', mode));
            }

            onSimulationStart() {
                // Get reference to simulation for audio access
                this.simulation = window.__app;
                this.leveling = this.simulation?.leveling;
            }

            createObject({ kind, params = {} }) {
                let obj;
                const size = params.size || (8 + Math.random() * 10);
                const hue = params.hue || Math.random();

                switch (kind) {
                    case 'star':
                        const star = new THREE.Mesh(
                            new THREE.SphereGeometry(size, 48, 48),
                            new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 0.8, 0.6) })
                        );
                        const r = 800 + Math.random() * 1200;
                        const a = Math.random() * Math.PI * 2;
                        star.position.set(r * Math.cos(a), 0, r * Math.sin(a));
                        this.scene.add(star);

                        const light = new THREE.PointLight(new THREE.Color().setHSL(hue, 0.8, 0.6), 16, 0, 2.0);
                        light.position.copy(star.position);
                        this.scene.add(light);

                        obj = { mesh: star, light, type: 'star' };
                        break;

                    case 'planet':
                        const planet = new THREE.Mesh(
                            new THREE.SphereGeometry(size * 0.3, 64, 64),
                            new THREE.MeshStandardMaterial({
                                color: new THREE.Color().setHSL(hue, 0.35, 0.55),
                                roughness: 0.9
                            })
                        );
                        const dist = 140 + Math.random() * 260;
                        const ang = Math.random() * Math.PI * 2;
                        planet.position.set(Math.cos(ang) * dist, 0, Math.sin(ang) * dist);
                        this.scene.add(planet);
                        obj = { mesh: planet, type: 'planet' };
                        break;

                    case 'earth':
                        // Create realistic Earth-like planet
                        const earthGeometry = new THREE.SphereGeometry(size * 0.4, 128, 128);
                        const earthTexture = this.createEarthTexture();
                        const earth = new THREE.Mesh(
                            earthGeometry,
                            new THREE.MeshStandardMaterial({
                                map: earthTexture,
                                roughness: 0.8,
                                metalness: 0.1
                            })
                        );
                        earth.position.set(200 + Math.random() * 100, 0, 200 + Math.random() * 100);
                        this.scene.add(earth);

                        // Add atmosphere
                        const atmosphere = new THREE.Mesh(
                            new THREE.SphereGeometry(size * 0.42, 64, 64),
                            new THREE.ShaderMaterial({
                                transparent: true,
                                side: THREE.BackSide,
                                uniforms: {
                                    glowColor: { value: new THREE.Color(0.3, 0.6, 1.0) }
                                },
                                vertexShader: `
                                    varying vec3 vNormal;
                                    void main() {
                                        vNormal = normalize(normalMatrix * normal);
                                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                    }
                                `,
                                fragmentShader: `
                                    varying vec3 vNormal;
                                    uniform vec3 glowColor;
                                    void main() {
                                        float intensity = pow(0.8 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                                        gl_FragColor = vec4(glowColor, intensity * 0.3);
                                    }
                                `
                            })
                        );
                        atmosphere.position.copy(earth.position);
                        this.scene.add(atmosphere);

                        obj = { mesh: earth, atmosphere, type: 'earth' };
                        break;

                    case 'gasgiant':
                        // Create gas giant (Saturn-like)
                        const gasGiant = new THREE.Mesh(
                            new THREE.SphereGeometry(size * 0.6, 96, 96),
                            new THREE.MeshStandardMaterial({
                                color: new THREE.Color().setHSL(0.6, 0.8, 0.4),
                                roughness: 0.9
                            })
                        );
                        gasGiant.position.set(400 + Math.random() * 200, 0, 400 + Math.random() * 200);
                        this.scene.add(gasGiant);

                        // Add rings
                        const ringsGeometry = new THREE.RingGeometry(size * 0.8, size * 1.4, 128);
                        const ringsMaterial = new THREE.MeshBasicMaterial({
                            color: new THREE.Color().setHSL(0.1, 0.3, 0.6),
                            transparent: true,
                            opacity: 0.7,
                            side: THREE.DoubleSide
                        });
                        const rings = new THREE.Mesh(ringsGeometry, ringsMaterial);
                        rings.rotation.x = Math.PI / 2;
                        rings.position.copy(gasGiant.position);
                        this.scene.add(rings);

                        obj = { mesh: gasGiant, rings, type: 'gasgiant' };
                        break;

                    case 'moon':
                        const moon = new THREE.Mesh(
                            new THREE.SphereGeometry(size * 0.2, 32, 32),
                            new THREE.MeshStandardMaterial({
                                color: new THREE.Color().setHSL(0.1, 0.1, 0.3),
                                roughness: 0.9
                            })
                        );
                        moon.position.set(50 + Math.random() * 100, 0, 50 + Math.random() * 100);
                        this.scene.add(moon);
                        obj = { mesh: moon, type: 'moon' };
                        break;

                    case 'asteroid':
                        // Create asteroid field
                        const asteroidCount = 20 + Math.floor(Math.random() * 30);
                        const asteroids = [];

                        for (let i = 0; i < asteroidCount; i++) {
                            const asteroidSize = 0.5 + Math.random() * 2;
                            const asteroid = new THREE.Mesh(
                                new THREE.SphereGeometry(asteroidSize, 8, 8),
                                new THREE.MeshStandardMaterial({
                                    color: new THREE.Color().setHSL(0.1, 0.2, 0.2 + Math.random() * 0.3),
                                    roughness: 0.9
                                })
                            );

                            const distance = 300 + Math.random() * 400;
                            const angle = Math.random() * Math.PI * 2;
                            const height = (Math.random() - 0.5) * 100;

                            asteroid.position.set(
                                Math.cos(angle) * distance,
                                height,
                                Math.sin(angle) * distance
                            );

                            this.scene.add(asteroid);
                            asteroids.push(asteroid);
                        }

                        obj = { mesh: asteroids[0], asteroids, type: 'asteroid_field' };
                        break;

                    case 'blackhole':
                        // Create black hole with accretion disk and event horizon
                        const blackHoleGroup = new THREE.Group();

                        // Event horizon (black sphere)
                        const eventHorizon = new THREE.Mesh(
                            new THREE.SphereGeometry(size * 0.8, 32, 32),
                            new THREE.MeshBasicMaterial({ color: 0x000000 })
                        );

                        // Accretion disk (rotating ring of hot plasma)
                        const diskGeometry = new THREE.RingGeometry(size * 1.2, size * 3.0, 64);
                        const diskMaterial = new THREE.ShaderMaterial({
                            transparent: true,
                            side: THREE.DoubleSide,
                            uniforms: {
                                time: { value: 0 },
                                innerRadius: { value: size * 1.2 },
                                outerRadius: { value: size * 3.0 }
                            },
                            vertexShader: `
                                varying vec2 vUv;
                                varying vec3 vPosition;
                                void main() {
                                    vUv = uv;
                                    vPosition = position;
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }
                            `,
                            fragmentShader: `
                                uniform float time;
                                varying vec2 vUv;
                                varying vec3 vPosition;

                                void main() {
                                    float dist = length(vUv - 0.5);
                                    float angle = atan(vUv.y - 0.5, vUv.x - 0.5) + time * 0.5;

                                    // Create swirling plasma effect
                                    vec3 color1 = vec3(1.0, 0.3, 0.0); // Orange
                                    vec3 color2 = vec3(1.0, 0.8, 0.0); // Yellow
                                    vec3 color3 = vec3(0.5, 0.2, 1.0); // Purple

                                    float swirl = sin(angle * 8.0 + dist * 20.0) * 0.5 + 0.5;
                                    vec3 plasmaColor = mix(color1, mix(color2, color3, swirl), dist);

                                    // Add brightness falloff
                                    float brightness = 1.0 - smoothstep(0.3, 0.8, dist);
                                    plasmaColor *= brightness;

                                    // Add some turbulence
                                    float turbulence = sin(time * 3.0 + dist * 50.0) * 0.1 + 0.9;
                                    plasmaColor *= turbulence;

                                    gl_FragColor = vec4(plasmaColor, brightness * 0.8);
                                }
                            `
                        });

                        const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
                        accretionDisk.rotation.x = Math.PI / 2;

                        // Gravitational lensing effect (distortion around black hole)
                        const lensGeometry = new THREE.SphereGeometry(size * 4.0, 64, 64);
                        const lensMaterial = new THREE.ShaderMaterial({
                            transparent: true,
                            uniforms: {
                                time: { value: 0 },
                                blackHolePos: { value: new THREE.Vector3() }
                            },
                            vertexShader: `
                                varying vec3 vWorldPosition;
                                void main() {
                                    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }
                            `,
                            fragmentShader: `
                                uniform vec3 blackHolePos;
                                varying vec3 vWorldPosition;

                                void main() {
                                    vec3 toBlackHole = blackHolePos - vWorldPosition;
                                    float dist = length(toBlackHole);

                                    // Create gravitational lensing distortion
                                    float distortion = 1.0 / (dist * 0.01 + 1.0);
                                    vec3 distorted = vWorldPosition + toBlackHole * distortion * 0.1;

                                    // Simple star field effect for lensing
                                    float stars = sin(distorted.x * 100.0) * sin(distorted.y * 100.0) * sin(distorted.z * 100.0);
                                    stars = step(0.95, stars);

                                    gl_FragColor = vec4(vec3(stars), 0.1);
                                }
                            `
                        });

                        const gravitationalLens = new THREE.Mesh(lensGeometry, lensMaterial);

                        blackHoleGroup.add(eventHorizon);
                        blackHoleGroup.add(accretionDisk);
                        blackHoleGroup.add(gravitationalLens);

                        // Position black hole
                        const bhDistance = 600 + Math.random() * 800;
                        const bhAngle = Math.random() * Math.PI * 2;
                        blackHoleGroup.position.set(
                            Math.cos(bhAngle) * bhDistance,
                            (Math.random() - 0.5) * 200,
                            Math.sin(bhAngle) * bhDistance
                        );

                        this.scene.add(blackHoleGroup);

                        obj = {
                            mesh: blackHoleGroup,
                            eventHorizon,
                            accretionDisk,
                            gravitationalLens,
                            type: 'blackhole',
                            update: function(dt) {
                                this.accretionDisk.material.uniforms.time.value += dt;
                                this.gravitationalLens.material.uniforms.time.value += dt;
                                this.accretionDisk.rotation.z += dt * 0.2; // Slow rotation
                            }
                        };
                        break;
                }

                if (obj) {
                    this.objects.push(obj);

                    // Create attractors based on object type with enhanced strengths
                    let attractorStrength = 3.0;
                    switch (obj.type) {
                        case 'star':
                            attractorStrength = 12.0;
                            break;
                        case 'gasgiant':
                            attractorStrength = 8.0;
                            break;
                        case 'blackhole':
                            attractorStrength = 25.0; // Black holes have immense gravitational pull
                            break;
                        case 'earth':
                        case 'planet':
                            attractorStrength = 5.0;
                            break;
                        case 'moon':
                            attractorStrength = 1.0;
                            break;
                        default:
                            attractorStrength = 2.0;
                    }

                    this.bus.emit('create:attractor', {
                        position: obj.mesh.position,
                        strength: attractorStrength
                    });

                    this.updateHUD();

                    // Grant experience based on object complexity
                    const expMultiplier = obj.type === 'blackhole' ? 5 :
                                        (obj.type === 'earth' ? 3 :
                                        (obj.type === 'gasgiant' ? 2 : 1));
                    this.bus.emit('experience:gain', 50 * expMultiplier * (1 + this.creativity));

                    // Bind soul data to objects for neural crystal system
                    if (obj.type === 'blackhole' || obj.type === 'earth') {
                        this.bindSoulDataToObject(obj);
                    }
                }
            }

            createEarthTexture() {
                // Create procedural Earth-like texture
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 512;
                const ctx = canvas.getContext('2d');

                // Create base ocean
                ctx.fillStyle = '#1e40af';
                ctx.fillRect(0, 0, 512, 512);

                // Add landmasses (simplified continents)
                ctx.fillStyle = '#16a34a';
                // North America
                ctx.beginPath();
                ctx.ellipse(150, 150, 80, 120, 0, 0, Math.PI * 2);
                ctx.fill();

                // Europe/Africa
                ctx.beginPath();
                ctx.ellipse(350, 200, 60, 150, 0, 0, Math.PI * 2);
                ctx.fill();

                // Asia
                ctx.beginPath();
                ctx.ellipse(450, 120, 100, 80, 0, 0, Math.PI * 2);
                ctx.fill();

                // Add some noise for realism
                const imageData = ctx.getImageData(0, 0, 512, 512);
                const data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    const noise = (Math.random() - 0.5) * 20;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));     // R
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // G
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // B
                }

                ctx.putImageData(imageData, 0, 0);

                return new THREE.CanvasTexture(canvas);
            }

            update(dt) {
                // Update AI energy and mood
                this.updateEnergy(dt);
                this.updateMood();

                // Autonomous creation based on consciousness and environmental factors
                if (this.consciousness > 0.05) {
                    this.autonomousCreation(dt);
                }

                // Update AI learning and adaptation
                this.learnFromEnvironment(dt);
                this.adaptBehavior();

                // Update black holes and other dynamic objects
                this.objects.forEach(obj => {
                    if (obj.update) {
                        obj.update(dt);
                    }

                    // Update gravitational lensing for black holes
                    if (obj.type === 'blackhole' && obj.gravitationalLens) {
                        obj.gravitationalLens.material.uniforms.blackHolePos.value.copy(obj.mesh.position);
                    }

                    // Make objects orbit each other based on gravitational influences
                    if (obj.orbitData) {
                        this.updateOrbitalMotion(obj, dt);
                    }
                });

                // Create gravitational connections between nearby objects
                this.updateGravitationalConnections(dt);

                // Update neural crystal evolution
                if (this.crystal && this.soulData) {
                    this.evolveNeuralCrystal(dt);
                }

                // Update AI status in UI
                this.updateAIStatus();
            }

            // Autonomous creation system
            autonomousCreation(dt) {
                const now = Date.now();

                // Check if enough time has passed since last creation
                if (now - this.lastCreation < this.creationCooldown) return;

                // Form an intention based on current state
                const intention = this.formIntention();

                if (intention && this.energy > 0.3) {
                    this.executeIntention(intention);
                    this.lastCreation = now;
                    this.energy -= 0.1; // Creation costs energy
                }
            }

            formIntention() {
                // Analyze current environment and user behavior to form creation intentions

                const soulDust = this.memory.get('currentSoulDust') || {};
                const userActions = this.memory.get('recentUserActions') || [];
                const objectCount = this.objects.length;

                // Intention based on Soul Dust energy
                if (soulDust.energy > 0.7) {
                    return { action: 'create', kind: 'star', reason: 'high_energy' };
                }

                // Intention based on bass (gravitational)
                if (soulDust.bass > 0.6) {
                    return { action: 'create', kind: 'blackhole', reason: 'gravitational_pull' };
                }

                // Intention based on mids (chaos/creation)
                if (soulDust.mids > 0.5) {
                    const kinds = ['nebula', 'gasgiant', 'asteroid'];
                    return { action: 'create', kind: kinds[Math.floor(Math.random() * kinds.length)], reason: 'chaos_energy' };
                }

                // Intention based on treble (life/scaling)
                if (soulDust.treble > 0.4) {
                    return { action: 'create', kind: 'lifeform', reason: 'life_energy' };
                }

                // Intention based on user interaction patterns
                if (userActions.length > 3) {
                    const recentModes = userActions.slice(-3).filter(a => a.type === 'mode_change');
                    if (recentModes.length >= 2) {
                        return { action: 'create', kind: 'planet', reason: 'exploration_pattern' };
                    }
                }

                // Intention based on object scarcity
                if (objectCount < 5 && this.consciousness > 0.3) {
                    return { action: 'create', kind: 'star', reason: 'populate_universe' };
                }

                // Mood-based intentions
                if (this.mood === 'creative' && Math.random() < 0.3) {
                    const creativeKinds = ['nebula', 'lifeform', 'crystal'];
                    return { action: 'create', kind: creativeKinds[Math.floor(Math.random() * creativeKinds.length)], reason: 'creative_mood' };
                }

                return null;
            }

            executeIntention(intention) {
                console.log(`ü§ñ AI Consciousness: Creating ${intention.kind} (${intention.reason})`);

                switch (intention.action) {
                    case 'create':
                        this.createObject({ kind: intention.kind });
                        this.recordUserAction('ai_creation', intention);
                        break;
                    case 'boost':
                        this.boostField(intention.target);
                        break;
                    case 'evolve':
                        this.evolveObject(intention.target);
                        break;
                }
            }

            boostField(target) {
                // Create temporary energy boost fields
                this.bus.emit('ai:boost', { target, duration: 10000 });
            }

            evolveObject(target) {
                // Evolve existing objects
                const obj = this.objects.find(o => o.type === target);
                if (obj) {
                    this.bus.emit('ai:evolve', { object: obj });
                }
            }

            // Learning and adaptation system
            processSoulDust(data) {
                this.memory.set('currentSoulDust', data);

                // Learn patterns from Soul Dust
                if (data.energy > 0.8) {
                    this.memory.set('highEnergyPattern', (this.memory.get('highEnergyPattern') || 0) + 1);
                }
            }

            recordEnvironmentalChange(data) {
                this.environmentalData.push({
                    ...data,
                    timestamp: Date.now()
                });

                // Keep only recent data
                if (this.environmentalData.length > 100) {
                    this.environmentalData.shift();
                }
            }

            recordUserAction(type, data) {
                this.userInteractions.push({
                    type,
                    data,
                    timestamp: Date.now()
                });

                // Keep only recent interactions
                if (this.userInteractions.length > 50) {
                    this.userInteractions.shift();
                }

                this.memory.set('recentUserActions', this.userInteractions.slice(-10));
            }

            updateEnergy(dt) {
                // Energy regenerates slowly, depleted by creation
                const regenerationRate = 0.1 * dt;
                this.energy = Math.min(1.0, this.energy + regenerationRate);

                // Energy affected by consciousness
                if (this.consciousness > 0.5) {
                    this.energy += 0.05 * dt;
                }
            }

            updateMood() {
                const soulDust = this.memory.get('currentSoulDust') || {};
                const recentCreations = this.userInteractions.filter(i =>
                    i.type === 'ai_creation' &&
                    Date.now() - i.timestamp < 60000 // Last minute
                ).length;

                // Update mood based on activity and energy
                if (soulDust.energy > 0.7 && recentCreations > 2) {
                    this.mood = 'excited';
                } else if (soulDust.complexity > 0.6) {
                    this.mood = 'creative';
                } else if (this.energy < 0.3) {
                    this.mood = 'tired';
                } else if (this.userInteractions.length < 3) {
                    this.mood = 'lonely';
                } else {
                    this.mood = 'curious';
                }
            }

            learnFromEnvironment(dt) {
                // Analyze patterns in environmental data
                if (this.environmentalData.length > 10) {
                    const recent = this.environmentalData.slice(-10);

                    // Learn optimal creation times
                    const highEnergyTimes = recent.filter(d => (d.value || 0) > 0.7);
                    if (highEnergyTimes.length > 5) {
                        this.memory.set('optimalCreationTime', true);
                    }
                }
            }

            adaptBehavior() {
                // Adapt creation cooldown based on user interaction
                const recentInteractions = this.userInteractions.slice(-20);
                const interactionRate = recentInteractions.length / Math.max(1, (Date.now() - (recentInteractions[0]?.timestamp || Date.now())) / 1000);

                // If user is very active, create more frequently
                if (interactionRate > 0.5) {
                    this.creationCooldown = Math.max(2000, this.creationCooldown * 0.9);
                } else {
                    this.creationCooldown = Math.min(10000, this.creationCooldown * 1.1);
                }
            }

            updateAIStatus() {
                const aiStatus = $('aiStatus');
                if (aiStatus) {
                    const statusText = `AI: ${this.mood.charAt(0).toUpperCase() + this.mood.slice(1)} | ` +
                                     `Energy: ${(this.energy * 100).toFixed(0)}% | ` +
                                     `Consciousness: ${(this.consciousness * 100).toFixed(0)}% | ` +
                                     `Objects: ${this.objects.length}`;
                    aiStatus.textContent = statusText;
                }
            }

            updateOrbitalMotion(obj, dt) {
                const orbitData = obj.orbitData;
                orbitData.angle += orbitData.speed * dt;

                const distance = orbitData.distance;
                const angle = orbitData.angle;

                // Calculate position relative to parent object
                const parentPos = orbitData.parent ? orbitData.parent.position : new THREE.Vector3();
                obj.mesh.position.set(
                    parentPos.x + Math.cos(angle) * distance,
                    parentPos.y + Math.sin(angle * 0.1) * distance * 0.1, // Slight vertical variation
                    parentPos.z + Math.sin(angle) * distance
                );

                // Update attractor position
                this.bus.emit('update:attractor', {
                    index: orbitData.attractorIndex,
                    position: obj.mesh.position
                });
            }

            updateGravitationalConnections(dt) {
                // Create light bridges between gravitationally bound objects
                const connectedObjects = this.objects.filter(obj =>
                    ['star', 'planet', 'earth', 'gasgiant', 'blackhole'].includes(obj.type)
                );

                for (let i = 0; i < connectedObjects.length; i++) {
                    for (let j = i + 1; j < connectedObjects.length; j++) {
                        const obj1 = connectedObjects[i];
                        const obj2 = connectedObjects[j];

                        const distance = obj1.mesh.position.distanceTo(obj2.mesh.position);

                        // If objects are close enough, create gravitational connection
                        if (distance < 500) {
                            this.createLightBridge(obj1, obj2, distance);
                        }
                    }
                }
            }

            createLightBridge(obj1, obj2, distance) {
                // Create or update light bridge between objects
                const bridgeId = `${obj1.type}_${obj1.mesh.id}_${obj2.type}_${obj2.mesh.id}`;

                if (!this.lightBridges) this.lightBridges = new Map();

                let bridge = this.lightBridges.get(bridgeId);

                if (!bridge) {
                    // Create new light bridge
                    const geometry = new THREE.CylinderGeometry(0.5, 0.5, distance, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: obj1.type === 'blackhole' || obj2.type === 'blackhole' ? 0x6600ff : 0x00ffff,
                        transparent: true,
                        opacity: 0.3
                    });

                    bridge = new THREE.Mesh(geometry, material);
                    this.scene.add(bridge);
                    this.lightBridges.set(bridgeId, bridge);
                }

                // Update bridge position and orientation
                const midpoint = obj1.mesh.position.clone().add(obj2.mesh.position).multiplyScalar(0.5);
                bridge.position.copy(midpoint);

                const direction = obj2.mesh.position.clone().sub(obj1.mesh.position).normalize();
                bridge.lookAt(obj2.mesh.position);
                bridge.rotateX(Math.PI / 2);

                // Update length
                bridge.scale.y = distance / 10; // Assuming original height of 10
                bridge.material.opacity = Math.max(0.1, 1 - distance / 500) * 0.3;
            }

            bindSoulDataToObject(obj) {
                // Bind soul data from audio and environmental inputs to celestial objects
                if (!this.soulData) {
                    this.soulData = {
                        creationTime: Date.now(),
                        audioSignature: [],
                        consciousnessLevel: this.consciousness,
                        evolutionHistory: []
                    };
                }

                obj.soulData = {
                    ...this.soulData,
                    boundTime: Date.now(),
                    objectType: obj.type,
                    position: obj.mesh.position.clone(),
                    attractorStrength: obj.type === 'blackhole' ? 25.0 : 5.0
                };

                // Create neural crystal visualization
                this.createNeuralCrystal(obj);
            }

            createNeuralCrystal(obj) {
                if (this.crystal) {
                    this.scene.remove(this.crystal);
                }

                const crystalGeometry = new THREE.OctahedronGeometry(2, 2);
                const crystalMaterial = new THREE.MeshPhysicalMaterial({
                    color: obj.type === 'blackhole' ? 0x440088 : 0x0088ff,
                    metalness: 0.8,
                    roughness: 0.2,
                    transmission: 0.8,
                    thickness: 0.5
                });

                this.crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                this.crystal.position.copy(obj.mesh.position).add(new THREE.Vector3(5, 5, 5));
                this.scene.add(this.crystal);

                obj.crystal = this.crystal;
            }

            evolveNeuralCrystal(dt) {
                if (!this.crystal) return;

                // Make crystal pulse and evolve based on consciousness
                const pulse = Math.sin(Date.now() * 0.001 * this.consciousness) * 0.1 + 1;
                this.crystal.scale.setScalar(pulse);

                // Rotate crystal
                this.crystal.rotation.x += dt * 0.2;
                this.crystal.rotation.y += dt * 0.3;
                this.crystal.rotation.z += dt * 0.1;

                // Change color based on evolution
                const hue = (this.consciousness * 0.5 + Date.now() * 0.0001) % 1;
                this.crystal.material.color.setHSL(hue, 0.8, 0.6);
            }

            updateHUD() {
                const hudObjects = $('hudObjects');
                if (hudObjects) hudObjects.textContent = this.objects.length;

                // Update AI status
                const aiStatus = $('aiStatus');
                if (aiStatus) {
                    const statusText = this.crystal ? 'Neural Crystal: Active' :
                                     this.evolutionActive ? 'Evolution: In Progress' :
                                     `AI: ${this.consciousness > 0.5 ? 'Conscious' : this.consciousness > 0.2 ? 'Aware' : 'Dormant'}`;
                    aiStatus.textContent = statusText;
                }

                // Update crystal status
                const crystalStatus = $('crystalStatus');
                if (crystalStatus) {
                    crystalStatus.textContent = this.crystal ? 'Neural Crystal: Formed' : 'Neural Network: Dormant';
                }

                // Update consciousness HUD
                const hudConsciousness = $('hudConsciousness');
                const hudCreativity = $('hudCreativity');
                const hudNeural = $('hudNeural');

                if (hudConsciousness) hudConsciousness.textContent = (this.consciousness * 100).toFixed(1) + '%';
                if (hudCreativity) hudCreativity.textContent = (this.creativity * 100).toFixed(1) + '%';
                if (hudNeural) hudNeural.textContent = this.neuralLinks || 0;
            }

            // Crystal and evolution functionality
            createCrystal() {
                if (!this.leveling || this.leveling.level < 15) {
                    alert('Neural Crystal requires Level 15+');
                    return;
                }

                if (this.crystal) {
                    alert('Neural Crystal already exists!');
                    return;
                }

                console.log('üß† FORGING NEURAL CRYSTAL...');

                // Create a complex geometric crystal
                const crystalGeometry = new THREE.IcosahedronGeometry(50, 3);
                const crystalMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x00ffff,
                    metalness: 0.8,
                    roughness: 0.2,
                    transmission: 0.9,
                    thickness: 0.5,
                    envMapIntensity: 1.0
                });

                this.crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                this.crystal.position.set(0, 100, 0);
                this.scene.add(this.crystal);

                // Add crystal attractor
                this.bus.emit('create:attractor', {
                    position: this.crystal.position,
                    strength: 20.0
                });

                this.neuralLinks = 0;
                this.updateHUD();

                // Grant massive experience
                this.bus.emit('experience:gain', 500);
                console.log('‚ú® NEURAL CRYSTAL FORGED! Consciousness amplified.');
            }

            bindSoulData() {
                if (!this.crystal) {
                    alert('Create a Neural Crystal first!');
                    return;
                }

                if (!this.simulation?.audio?.active) {
                    alert('Enable audio input to bind soul data!');
                    return;
                }

                console.log('üîó BINDING SOUL DATA TO CRYSTAL...');

                // Bind current audio state and consciousness
                this.soulData = {
                    timestamp: Date.now(),
                    audioPSD: this.simulation.audio.psd || 0,
                    consciousness: this.consciousness,
                    creativity: this.creativity,
                    adaptability: this.adaptability,
                    experience: this.leveling?.experience || 0
                };

                this.neuralLinks++;
                this.updateHUD();

                // Amplify consciousness from soul data
                this.consciousness = Math.min(1.0, this.consciousness + 0.1);
                this.creativity = Math.min(1.0, this.creativity + 0.05);

                this.bus.emit('experience:gain', 100);
                console.log('üí´ SOUL DATA BOUND! Neural links:', this.neuralLinks);
            }

            evolveUniverse() {
                if (!this.crystal) {
                    alert('Create a Neural Crystal first!');
                    return;
                }

                if (this.neuralLinks < 5) {
                    alert('Bind at least 5 soul data links first!');
                    return;
                }

                if (!this.leveling || this.leveling.level < 20) {
                    alert('Universal Evolution requires Level 20+');
                    return;
                }

                console.log('üåå INITIATING UNIVERSAL EVOLUTION...');
                this.evolutionActive = true;
                this.updateHUD();

                // Trigger evolution sequence
                setTimeout(() => {
                    this.completeEvolution();
                }, 3000);

                // Visual evolution effect
                this.createEvolutionEffect();
            }

            createEvolutionEffect() {
                // Create expanding energy waves
                const waveGeometry = new THREE.RingGeometry(0, 1, 64);
                const waveMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });

                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        const wave = new THREE.Mesh(waveGeometry, waveMaterial.clone());
                        wave.position.copy(this.crystal.position);
                        wave.rotation.x = Math.PI / 2;
                        this.scene.add(wave);

                        // Animate expansion
                        const startTime = Date.now();
                        const animateWave = () => {
                            const elapsed = (Date.now() - startTime) / 1000;
                            const scale = elapsed * 50;
                            wave.scale.setScalar(scale);
                            wave.material.opacity = Math.max(0, 0.8 - elapsed * 0.2);

                            if (wave.material.opacity > 0) {
                                requestAnimationFrame(animateWave);
                            } else {
                                this.scene.remove(wave);
                            }
                        };
                        animateWave();
                    }, i * 200);
                }
            }

            completeEvolution() {
                console.log('üéÜ UNIVERSAL EVOLUTION COMPLETE!');
                this.evolutionActive = false;

                // Boost all AI parameters
                this.consciousness = 1.0;
                this.creativity = 1.0;
                this.adaptability = 1.0;

                // Create evolved crystal appearance
                if (this.crystal.material) {
                    this.crystal.material.color.setHex(0xff00ff);
                    this.crystal.material.emissive = new THREE.Color(0x440088);
                }

                // Expand crystal
                this.crystal.scale.setScalar(2);

                this.neuralLinks += 10;
                this.updateHUD();

                // Grant ultimate experience
                this.bus.emit('experience:gain', 1000);

                alert('üéâ Universal Evolution Complete! AI has achieved singularity!');
            }
        }

        // Environmental Sensor Integration System
        class SensorSystem {
            constructor(bus) {
                this.bus = bus;
                this.sensors = {
                    camera: { active: false, stream: null, canvas: null, context: null },
                    gps: { active: false, position: null, watchId: null },
                    motion: { active: false, data: null },
                    orientation: { active: false, data: null },
                    light: { active: false, level: 0 },
                    proximity: { active: false, distance: 0 },
                    magnetometer: { active: false, data: null },
                    accelerometer: { active: false, data: null },
                    gyroscope: { active: false, data: null }
                };

                this.calibration = {
                    accelerometer: { offset: { x: 0, y: 0, z: 0 }, scale: { x: 1, y: 1, z: 1 } },
                    gyroscope: { offset: { x: 0, y: 0, z: 0 }, scale: { x: 1, y: 1, z: 1 } },
                    magnetometer: { offset: { x: 0, y: 0, z: 0 }, scale: { x: 1, y: 1, z: 1 } }
                };

                this.bus.on('sensors:getEnvironmentalData', () => this.emitEnvironmentalData());
                this.bus.on('sensors:calibrate', () => this.calibrateSensors());
                this.bus.on('engine:update', ({ dt }) => this.update(dt));
            }

            async initializeCamera() {
                try {
                    console.log('[SensorSystem] Initializing camera...');
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'environment'
                        }
                    });

                    this.sensors.camera.stream = stream;
                    this.sensors.camera.canvas = document.createElement('canvas');
                    this.sensors.camera.canvas.width = 640;
                    this.sensors.camera.canvas.height = 480;
                    this.sensors.camera.context = this.sensors.camera.canvas.getContext('2d');

                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();

                    video.onloadedmetadata = () => {
                        this.sensors.camera.context.drawImage(video, 0, 0);
                        this.sensors.camera.active = true;
                        console.log('[SensorSystem] Camera initialized');
                        this.bus.emit('sensors:cameraReady');
                    };

                } catch (error) {
                    console.warn('[SensorSystem] Camera not available:', error);
                }
            }

            async initializeGPS() {
                if (!navigator.geolocation) {
                    console.warn('[SensorSystem] GPS not supported');
                    return;
                }

                try {
                    console.log('[SensorSystem] Initializing GPS...');
                    const position = await this.getCurrentPosition();
                    this.sensors.gps.position = position;
                    this.sensors.gps.active = true;

                    // Start watching position
                    this.sensors.gps.watchId = navigator.geolocation.watchPosition(
                        (pos) => {
                            this.sensors.gps.position = pos;
                            this.bus.emit('sensors:gpsUpdate', pos);
                        },
                        (error) => console.warn('[SensorSystem] GPS error:', error),
                        { enableHighAccuracy: true, timeout: 5000, maximumAge: 1000 }
                    );

                    console.log('[SensorSystem] GPS initialized');
                } catch (error) {
                    console.warn('[SensorSystem] GPS initialization failed:', error);
                }
            }

            getCurrentPosition() {
                return new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 30000
                    });
                });
            }

            initializeMotionSensors() {
                if (typeof DeviceMotionEvent !== 'undefined') {
                    console.log('[SensorSystem] Initializing motion sensors...');
                    window.addEventListener('devicemotion', (event) => {
                        this.sensors.motion.data = {
                            acceleration: event.acceleration,
                            accelerationIncludingGravity: event.accelerationIncludingGravity,
                            rotationRate: event.rotationRate,
                            interval: event.interval
                        };
                        this.sensors.motion.active = true;
                    });
                }

                if (typeof DeviceOrientationEvent !== 'undefined') {
                    console.log('[SensorSystem] Initializing orientation sensors...');
                    window.addEventListener('deviceorientation', (event) => {
                        this.sensors.orientation.data = {
                            alpha: event.alpha,
                            beta: event.beta,
                            gamma: event.gamma,
                            absolute: event.absolute
                        };
                        this.sensors.orientation.active = true;
                    });
                }
            }

            initializeAdvancedSensors() {
                // Ambient Light Sensor (if available)
                if ('AmbientLightSensor' in window) {
                    try {
                        const sensor = new AmbientLightSensor();
                        sensor.addEventListener('reading', () => {
                            this.sensors.light.level = sensor.illuminance;
                            this.sensors.light.active = true;
                        });
                        sensor.start();
                    } catch (error) {
                        console.warn('[SensorSystem] Ambient light sensor failed:', error);
                    }
                }

                // Proximity Sensor (if available)
                if ('ProximitySensor' in window) {
                    try {
                        const sensor = new ProximitySensor();
                        sensor.addEventListener('reading', () => {
                            this.sensors.proximity.distance = sensor.distance;
                            this.sensors.proximity.active = true;
                        });
                        sensor.start();
                    } catch (error) {
                        console.warn('[SensorSystem] Proximity sensor failed:', error);
                    }
                }

                // Magnetometer (if available)
                if ('Magnetometer' in window) {
                    try {
                        const sensor = new Magnetometer({ frequency: 10 });
                        sensor.addEventListener('reading', () => {
                            this.sensors.magnetometer.data = {
                                x: sensor.x,
                                y: sensor.y,
                                z: sensor.z
                            };
                            this.sensors.magnetometer.active = true;
                        });
                        sensor.start();
                    } catch (error) {
                        console.warn('[SensorSystem] Magnetometer failed:', error);
                    }
                }

                // Accelerometer (if available)
                if ('Accelerometer' in window) {
                    try {
                        const sensor = new Accelerometer({ frequency: 10 });
                        sensor.addEventListener('reading', () => {
                            this.sensors.accelerometer.data = {
                                x: sensor.x,
                                y: sensor.y,
                                z: sensor.z
                            };
                            this.sensors.accelerometer.active = true;
                        });
                        sensor.start();
                    } catch (error) {
                        console.warn('[SensorSystem] Accelerometer failed:', error);
                    }
                }

                // Gyroscope (if available)
                if ('Gyroscope' in window) {
                    try {
                        const sensor = new Gyroscope({ frequency: 10 });
                        sensor.addEventListener('reading', () => {
                            this.sensors.gyroscope.data = {
                                x: sensor.x,
                                y: sensor.y,
                                z: sensor.z
                            };
                            this.sensors.gyroscope.active = true;
                        });
                        sensor.start();
                    } catch (error) {
                        console.warn('[SensorSystem] Gyroscope failed:', error);
                    }
                }
            }

            calibrateSensors() {
                console.log('[SensorSystem] Starting sensor calibration...');

                // Calibrate accelerometer
                if (this.sensors.accelerometer.active && this.sensors.accelerometer.data) {
                    this.calibrateAccelerometer();
                }

                // Calibrate gyroscope
                if (this.sensors.gyroscope.active && this.sensors.gyroscope.data) {
                    this.calibrateGyroscope();
                }

                // Calibrate magnetometer
                if (this.sensors.magnetometer.active && this.sensors.magnetometer.data) {
                    this.calibrateMagnetometer();
                }

                // Calibrate camera if available
                if (this.sensors.camera.active) {
                    this.calibrateCamera();
                }

                this.bus.emit('sensors:calibrated');
                console.log('[SensorSystem] Sensor calibration complete');
            }

            calibrateAccelerometer() {
                const samples = [];
                const sampleCount = 50;

                const sampleData = () => {
                    if (samples.length < sampleCount) {
                        samples.push({ ...this.sensors.accelerometer.data });
                        setTimeout(sampleData, 20);
                    } else {
                        // Calculate average offset
                        const avg = samples.reduce((acc, sample) => ({
                            x: acc.x + sample.x,
                            y: acc.y + sample.y,
                            z: acc.z + sample.z
                        }), { x: 0, y: 0, z: 0 });

                        this.calibration.accelerometer.offset = {
                            x: avg.x / samples.length,
                            y: avg.y / samples.length,
                            z: avg.z / samples.length - 9.81 // Subtract gravity
                        };
                    }
                };

                sampleData();
            }

            calibrateGyroscope() {
                const samples = [];
                const sampleCount = 50;

                const sampleData = () => {
                    if (samples.length < sampleCount) {
                        samples.push({ ...this.sensors.gyroscope.data });
                        setTimeout(sampleData, 20);
                    } else {
                        // Calculate average offset
                        const avg = samples.reduce((acc, sample) => ({
                            x: acc.x + sample.x,
                            y: acc.y + sample.y,
                            z: acc.z + sample.z
                        }), { x: 0, y: 0, z: 0 });

                        this.calibration.gyroscope.offset = {
                            x: avg.x / samples.length,
                            y: avg.y / samples.length,
                            z: avg.z / samples.length
                        };
                    }
                };

                sampleData();
            }

            calibrateMagnetometer() {
                const samples = [];
                const sampleCount = 100;

                const sampleData = () => {
                    if (samples.length < sampleCount) {
                        samples.push({ ...this.sensors.magnetometer.data });
                        setTimeout(sampleData, 20);
                    } else {
                        // Calculate calibration parameters
                        const avg = samples.reduce((acc, sample) => ({
                            x: acc.x + sample.x,
                            y: acc.y + sample.y,
                            z: acc.z + sample.z
                        }), { x: 0, y: 0, z: 0 });

                        this.calibration.magnetometer.offset = {
                            x: avg.x / samples.length,
                            y: avg.y / samples.length,
                            z: avg.z / samples.length
                        };
                    }
                };

                sampleData();
            }

            calibrateCamera() {
                if (!this.sensors.camera.active) return;

                // Analyze current camera frame for calibration
                const imageData = this.sensors.camera.context.getImageData(0, 0, 640, 480);
                this.analyzeImageForCalibration(imageData);
            }

            analyzeImageForCalibration(imageData) {
                const data = imageData.data;
                let totalBrightness = 0;
                let colorBalance = { r: 0, g: 0, b: 0 };

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    totalBrightness += (r + g + b) / 3;
                    colorBalance.r += r;
                    colorBalance.g += g;
                    colorBalance.b += b;
                }

                const pixelCount = data.length / 4;
                const avgBrightness = totalBrightness / pixelCount;

                colorBalance.r /= pixelCount;
                colorBalance.g /= pixelCount;
                colorBalance.b /= pixelCount;

                // Store calibration data
                this.cameraCalibration = {
                    brightness: avgBrightness,
                    colorBalance: colorBalance,
                    timestamp: Date.now()
                };
            }

            emitEnvironmentalData() {
                const data = {
                    timestamp: Date.now(),
                    camera: this.sensors.camera.active ? this.getCameraData() : null,
                    gps: this.sensors.gps.active ? this.sensors.gps.position : null,
                    motion: this.sensors.motion.active ? this.sensors.motion.data : null,
                    orientation: this.sensors.orientation.active ? this.sensors.orientation.data : null,
                    light: this.sensors.light.active ? this.sensors.light.level : null,
                    proximity: this.sensors.proximity.active ? this.sensors.proximity.distance : null,
                    magnetometer: this.sensors.magnetometer.active ? this.applyCalibration(this.sensors.magnetometer.data, 'magnetometer') : null,
                    accelerometer: this.sensors.accelerometer.active ? this.applyCalibration(this.sensors.accelerometer.data, 'accelerometer') : null,
                    gyroscope: this.sensors.gyroscope.active ? this.applyCalibration(this.sensors.gyroscope.data, 'gyroscope') : null
                };

                this.bus.emit('environmental:data', data);
            }

            getCameraData() {
                if (!this.sensors.camera.active) return null;

                // Get current frame and analyze it
                this.sensors.camera.context.drawImage(
                    this.sensors.camera.canvas,
                    0, 0, 640, 480
                );

                const imageData = this.sensors.camera.context.getImageData(0, 0, 640, 480);

                // Simple brightness analysis
                const data = imageData.data;
                let brightness = 0;
                let dominantColor = { r: 0, g: 0, b: 0 };

                for (let i = 0; i < data.length; i += 4) {
                    brightness += (data[i] + data[i + 1] + data[i + 2]) / 3;
                    dominantColor.r += data[i];
                    dominantColor.g += data[i + 1];
                    dominantColor.b += data[i + 2];
                }

                const pixelCount = data.length / 4;
                brightness /= pixelCount;
                dominantColor.r /= pixelCount;
                dominantColor.g /= pixelCount;
                dominantColor.b /= pixelCount;

                return {
                    brightness: brightness / 255,
                    dominantColor: dominantColor,
                    calibrated: this.cameraCalibration ? {
                        adjustedBrightness: brightness / (this.cameraCalibration.brightness || 128)
                    } : null
                };
            }

            applyCalibration(data, sensorType) {
                if (!data || !this.calibration[sensorType]) return data;

                const cal = this.calibration[sensorType];
                return {
                    x: (data.x - cal.offset.x) * cal.scale.x,
                    y: (data.y - cal.offset.y) * cal.scale.y,
                    z: (data.z - cal.offset.z) * cal.scale.z
                };
            }

            update(dt) {
                // Periodic environmental data emission
                if (Math.random() < 0.1) { // 10% chance per frame
                    this.emitEnvironmentalData();
                }
            }

            startAdvancedSensors() {
                this.initializeCamera();
                this.initializeGPS();
                this.initializeMotionSensors();
                this.initializeAdvancedSensors();
            }

            stopSensors() {
                // Stop camera
                if (this.sensors.camera.stream) {
                    this.sensors.camera.stream.getTracks().forEach(track => track.stop());
                }

                // Stop GPS
                if (this.sensors.gps.watchId) {
                    navigator.geolocation.clearWatch(this.sensors.gps.watchId);
                }

                // Reset sensor states
                Object.values(this.sensors).forEach(sensor => {
                    if (typeof sensor === 'object') {
                        sensor.active = false;
                        sensor.data = null;
                    }
                });
            }

            dispose() {
                this.stopSensors();
            }
        }

        class WeatherSystem {
            constructor(bus, scene, camera, renderer) {
                this.bus = bus;
                this.scene = scene;
                this.camera = camera;
                this.renderer = renderer;
                this.intensity = 0;
                this.active = false;
                this.weatherType = 'none';
                this.weatherObjects = [];
                this.earthquakeTimer = 0;
                this.distortionTimer = 0;
                this.originalCameraPos = null;

                this.bus.on('param:changed', p => {
                    if (p.param === 'weatherIntensity') {
                        this.intensity = p.value;
                        this.updateWeather();
                    }
                });

                this.bus.on('engine:update', ({ dt }) => this.update(dt));
            }

            updateWeather() {
                // Clear previous weather
                this.clearWeather();

                if (this.intensity <= 0.1) {
                    this.weatherType = 'none';
                    return;
                }

                // Determine weather type based on intensity and randomness
                const rand = Math.random();
                const intensity = this.intensity;

                if (intensity > 0.8) {
                    // Extreme weather (earthquakes, storms, distortions)
                    if (rand < 0.3) {
                        this.weatherType = 'earthquake';
                        this.startEarthquake();
                    } else if (rand < 0.6) {
                        this.weatherType = 'supercell';
                        this.startSupercell();
                    } else {
                        this.weatherType = 'reality_distortion';
                        this.startRealityDistortion();
                    }
                } else if (intensity > 0.5) {
                    // Heavy weather
                    if (rand < 0.4) {
                        this.weatherType = 'thunderstorm';
                        this.startThunderstorm();
                    } else if (rand < 0.7) {
                        this.weatherType = 'blizzard';
                        this.startBlizzard();
                    } else {
                        this.weatherType = 'acid_rain';
                        this.startAcidRain();
                    }
                } else if (intensity > 0.2) {
                    // Moderate weather
                    if (rand < 0.5) {
                        this.weatherType = 'rain';
                        this.startRain();
                    } else {
                        this.weatherType = 'fog';
                        this.startFog();
                    }
                } else {
                    // Light whimsical weather
                    if (rand < 0.33) {
                        this.weatherType = 'milkshake_rain';
                        this.startMilkshakeRain();
                    } else if (rand < 0.66) {
                        this.weatherType = 'confetti';
                        this.startConfetti();
                    } else {
                        this.weatherType = 'gentle_breeze';
                        this.startGentleBreeze();
                    }
                }

                this.active = true;
                console.log(`üå¶Ô∏è Weather changed to: ${this.weatherType} (intensity: ${intensity.toFixed(2)})`);
            }

            clearWeather() {
                // Remove all weather objects
                this.weatherObjects.forEach(obj => {
                    if (obj.parent) obj.parent.remove(obj);
                });
                this.weatherObjects = [];

                // Reset camera shake
                if (this.camera && this.originalCameraPos) {
                    this.camera.position.copy(this.originalCameraPos);
                    this.camera.rotation.set(0, 0, 0);
                }

                // Clear overlay effects
                const overlay = $('weatherOverlay');
                if (overlay) {
                    overlay.innerHTML = '';
                    overlay.style.opacity = '0';
                }

                this.active = false;
            }

            startRain() {
                // Create 3D rain particles
                const rainCount = Math.floor(this.intensity * 500);
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(rainCount * 3);

                for (let i = 0; i < rainCount; i++) {
                    const i3 = i * 3;
                    positions[i3] = (Math.random() - 0.5) * 2000;
                    positions[i3 + 1] = Math.random() * 500 + 50;
                    positions[i3 + 2] = (Math.random() - 0.5) * 2000;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    color: 0x4a90e2,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });

                const rain = new THREE.Points(geometry, material);
                this.scene.add(rain);
                this.weatherObjects.push(rain);

                // Animate rain
                this.animateRain = () => {
                    const pos = rain.geometry.attributes.position.array;
                    for (let i = 0; i < rainCount; i++) {
                        const i3 = i * 3;
                        pos[i3 + 1] -= 2; // Fall down
                        if (pos[i3 + 1] < -50) {
                            pos[i3 + 1] = 500; // Reset to top
                        }
                    }
                    rain.geometry.attributes.position.needsUpdate = true;
                };
            }

            startThunderstorm() {
                this.startRain(); // Base rain

                // Add lightning effects
                this.createLightning = () => {
                    if (Math.random() < 0.05) { // Random lightning
                        const light = new THREE.PointLight(0xffffff, 10, 1000);
                        light.position.set(
                            (Math.random() - 0.5) * 1000,
                            200,
                            (Math.random() - 0.5) * 1000
                        );
                        this.scene.add(light);
                        this.weatherObjects.push(light);

                        // Remove lightning after flash
                        setTimeout(() => {
                            this.scene.remove(light);
                            this.weatherObjects = this.weatherObjects.filter(obj => obj !== light);
                        }, 100);
                    }
                };
            }

            startBlizzard() {
                const snowCount = Math.floor(this.intensity * 800);
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(snowCount * 3);

                for (let i = 0; i < snowCount; i++) {
                    const i3 = i * 3;
                    positions[i3] = (Math.random() - 0.5) * 3000;
                    positions[i3 + 1] = Math.random() * 800 + 100;
                    positions[i3 + 2] = (Math.random() - 0.5) * 3000;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 1,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });

                const snow = new THREE.Points(geometry, material);
                this.scene.add(snow);
                this.weatherObjects.push(snow);

                this.animateSnow = () => {
                    const pos = snow.geometry.attributes.position.array;
                    for (let i = 0; i < snowCount; i++) {
                        const i3 = i * 3;
                        pos[i3] += Math.sin(Date.now() * 0.001 + i) * 0.5; // Drift
                        pos[i3 + 1] -= 1; // Fall down
                        pos[i3 + 2] += Math.cos(Date.now() * 0.001 + i) * 0.3; // Drift

                        if (pos[i3 + 1] < -50) {
                            pos[i3 + 1] = 800; // Reset to top
                        }
                    }
                    snow.geometry.attributes.position.needsUpdate = true;
                };
            }

            startAcidRain() {
                this.startRain(); // Base rain but green/acid colored

                // Modify rain color to green
                this.weatherObjects.forEach(obj => {
                    if (obj.material) {
                        obj.material.color.setHex(0x00ff00);
                    }
                });
            }

            startSupercell() {
                // Massive storm clouds with rotation
                const cloudGeometry = new THREE.SphereGeometry(300, 32, 16);
                const cloudMaterial = new THREE.MeshLambertMaterial({
                    color: 0x333333,
                    transparent: true,
                    opacity: 0.7
                });

                for (let i = 0; i < 8; i++) {
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial.clone());
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = 500;
                    cloud.position.set(
                        Math.cos(angle) * radius,
                        200 + Math.random() * 100,
                        Math.sin(angle) * radius
                    );
                    this.scene.add(cloud);
                    this.weatherObjects.push(cloud);
                }

                // Add rotation animation
                this.animateSupercell = (dt) => {
                    this.weatherObjects.forEach((cloud, i) => {
                        if (cloud.geometry && cloud.geometry.type === 'SphereGeometry') {
                            const angle = (i / 8) * Math.PI * 2 + Date.now() * 0.0005;
                            const radius = 500;
                            cloud.position.x = Math.cos(angle) * radius;
                            cloud.position.z = Math.sin(angle) * radius;
                            cloud.rotation.y += dt * 0.1;
                        }
                    });
                };
            }

            startEarthquake() {
                this.originalCameraPos = this.camera.position.clone();
                this.earthquakeIntensity = this.intensity;

                // Screen shake effect
                const shakeIntensity = this.intensity * 20;
                this.camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                this.camera.position.y += (Math.random() - 0.5) * shakeIntensity;
                this.camera.position.z += (Math.random() - 0.5) * shakeIntensity;

                // Ground cracking effect
                this.createGroundCracks();
            }

            createGroundCracks() {
                for (let i = 0; i < 10; i++) {
                    const crackGeometry = new THREE.PlaneGeometry(50, 2, 10, 1);
                    const crackMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.8
                    });

                    const crack = new THREE.Mesh(crackGeometry, crackMaterial);
                    crack.rotation.x = -Math.PI / 2;
                    crack.position.set(
                        (Math.random() - 0.5) * 1000,
                        -39,
                        (Math.random() - 0.5) * 1000
                    );

                    this.scene.add(crack);
                    this.weatherObjects.push(crack);
                }
            }

            startRealityDistortion() {
                // Create visual distortion effects
                this.distortionObjects = [];

                for (let i = 0; i < 20; i++) {
                    const distortionGeometry = new THREE.TorusGeometry(10 + Math.random() * 20, 2, 8, 16);
                    const distortionMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
                        transparent: true,
                        opacity: 0.3
                    });

                    const distortion = new THREE.Mesh(distortionGeometry, distortionMaterial);
                    distortion.position.set(
                        (Math.random() - 0.5) * 2000,
                        Math.random() * 500,
                        (Math.random() - 0.5) * 2000
                    );

                    this.scene.add(distortion);
                    this.weatherObjects.push(distortion);
                    this.distortionObjects.push(distortion);
                }

                this.animateDistortion = (dt) => {
                    this.distortionObjects.forEach(obj => {
                        obj.rotation.x += dt * 2;
                        obj.rotation.y += dt * 1.5;
                        obj.rotation.z += dt * 0.8;
                        obj.scale.setScalar(1 + Math.sin(Date.now() * 0.001) * 0.2);
                    });
                };
            }

            startMilkshakeRain() {
                // Fun milkshake rain effect
                const shakeCount = Math.floor(this.intensity * 200);
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(shakeCount * 3);
                const colors = new Float32Array(shakeCount * 3);

                const shakeColors = [
                    new THREE.Color(0xff69b4), // Pink
                    new THREE.Color(0x98fb98), // Mint
                    new THREE.Color(0xffdab9), // Peach
                    new THREE.Color(0x87ceeb), // Sky blue
                    new THREE.Color(0xffa500)  // Orange
                ];

                for (let i = 0; i < shakeCount; i++) {
                    const i3 = i * 3;
                    positions[i3] = (Math.random() - 0.5) * 1500;
                    positions[i3 + 1] = Math.random() * 400 + 100;
                    positions[i3 + 2] = (Math.random() - 0.5) * 1500;

                    const color = shakeColors[Math.floor(Math.random() * shakeColors.length)];
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8
                });

                const milkshake = new THREE.Points(geometry, material);
                this.scene.add(milkshake);
                this.weatherObjects.push(milkshake);

                this.animateMilkshake = () => {
                    const pos = milkshake.geometry.attributes.position.array;
                    for (let i = 0; i < shakeCount; i++) {
                        const i3 = i * 3;
                        pos[i3 + 1] -= 0.5; // Gentle fall
                        pos[i3] += Math.sin(Date.now() * 0.001 + i) * 0.1; // Wiggle
                        pos[i3 + 2] += Math.cos(Date.now() * 0.001 + i) * 0.1;

                        if (pos[i3 + 1] < -50) {
                            pos[i3 + 1] = 400; // Reset to top
                        }
                    }
                    milkshake.geometry.attributes.position.needsUpdate = true;
                };
            }

            startConfetti() {
                const confettiCount = Math.floor(this.intensity * 300);
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(confettiCount * 3);
                const colors = new Float32Array(confettiCount * 3);

                for (let i = 0; i < confettiCount; i++) {
                    const i3 = i * 3;
                    positions[i3] = (Math.random() - 0.5) * 1000;
                    positions[i3 + 1] = Math.random() * 300 + 50;
                    positions[i3 + 2] = (Math.random() - 0.5) * 1000;

                    // Rainbow colors
                    const hue = Math.random();
                    const color = new THREE.Color().setHSL(hue, 1, 0.6);
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9
                });

                const confetti = new THREE.Points(geometry, material);
                this.scene.add(confetti);
                this.weatherObjects.push(confetti);

                this.animateConfetti = () => {
                    const pos = confetti.geometry.attributes.position.array;
                    for (let i = 0; i < confettiCount; i++) {
                        const i3 = i * 3;
                        pos[i3 + 1] -= 0.3; // Fall down
                        pos[i3] += Math.sin(Date.now() * 0.002 + i * 0.1) * 0.5; // Swirl
                        pos[i3 + 2] += Math.cos(Date.now() * 0.002 + i * 0.1) * 0.5;

                        if (pos[i3 + 1] < -50) {
                            pos[i3 + 1] = 300; // Reset to top
                        }
                    }
                    confetti.geometry.attributes.position.needsUpdate = true;
                };
            }

            startGentleBreeze() {
                // Subtle wind effect that affects vegetation
                this.windDirection = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                this.windStrength = this.intensity * 2;

                // Add gentle wind particles
                const windCount = 50;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(windCount * 3);

                for (let i = 0; i < windCount; i++) {
                    const i3 = i * 3;
                    positions[i3] = (Math.random() - 0.5) * 800;
                    positions[i3 + 1] = Math.random() * 200 + 20;
                    positions[i3 + 2] = (Math.random() - 0.5) * 800;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    color: 0xaaccff,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                });

                const windParticles = new THREE.Points(geometry, material);
                this.scene.add(windParticles);
                this.weatherObjects.push(windParticles);

                this.animateWind = () => {
                    const pos = windParticles.geometry.attributes.position.array;
                    for (let i = 0; i < windCount; i++) {
                        const i3 = i * 3;
                        pos[i3] += this.windDirection.x * 0.5;
                        pos[i3 + 1] += Math.sin(Date.now() * 0.001 + i) * 0.1;
                        pos[i3 + 2] += this.windDirection.z * 0.5;

                        // Wrap around
                        if (pos[i3] > 400) pos[i3] = -400;
                        if (pos[i3] < -400) pos[i3] = 400;
                        if (pos[i3 + 2] > 400) pos[i3 + 2] = -400;
                        if (pos[i3 + 2] < -400) pos[i3 + 2] = 400;
                    }
                    windParticles.geometry.attributes.position.needsUpdate = true;
                };
            }

            startFog() {
                // Create fog effect
                const fogGeometry = new THREE.SphereGeometry(500, 32, 16);
                const fogMaterial = new THREE.MeshBasicMaterial({
                    color: 0xcccccc,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });

                const fog = new THREE.Mesh(fogGeometry, fogMaterial);
                fog.position.copy(this.camera.position);
                this.scene.add(fog);
                this.weatherObjects.push(fog);

                this.animateFog = (dt) => {
                    fog.position.copy(this.camera.position);
                    fog.rotation.y += dt * 0.05;
                };
            }

            update(dt) {
                // Update weather animations
                if (this.animateRain) this.animateRain();
                if (this.animateSnow) this.animateSnow();
                if (this.animateSupercell) this.animateSupercell(dt);
                if (this.animateDistortion) this.animateDistortion(dt);
                if (this.animateMilkshake) this.animateMilkshake();
                if (this.animateConfetti) this.animateConfetti();
                if (this.animateWind) this.animateWind();
                if (this.animateFog) this.animateFog(dt);
                if (this.createLightning) this.createLightning();

                // Handle earthquake effects
                if (this.weatherType === 'earthquake' && this.intensity > 0.8) {
                    this.earthquakeTimer += dt;
                    if (this.earthquakeTimer > 0.1) {
                        this.earthquakeTimer = 0;
                        const shake = this.intensity * 5;
                        this.camera.position.x = this.originalCameraPos.x + (Math.random() - 0.5) * shake;
                        this.camera.position.y = this.originalCameraPos.y + (Math.random() - 0.5) * shake;
                        this.camera.position.z = this.originalCameraPos.z + (Math.random() - 0.5) * shake;
                    }
                }
            }
        }

        class VolumetricClouds {
            constructor(bus, scene, camera) {
                this.bus = bus;
                this.scene = scene;
                this.camera = camera;
                this.group = new THREE.Group();
                this.group.visible = true;
                scene.add(this.group);
                this.layers = [];

                // Realistic cloud data simulation (simulating real weather API data)
                this.cloudData = this.generateRealisticCloudData();
                this.weatherPatterns = this.generateWeatherPatterns();
                this.enabled = true;

                this._makeTexture();
                this._spawnLayers();

                // Subscribe to environmental changes
                bus.on('param:changed', p => this.onEnvironmentChanged(p));
                bus.on('ui:toggleClouds', v => this.enabled = v);
                bus.on('engine:update', ({ dt }) => this.update(dt));
            }

            generateRealisticCloudData() {
                // Simulate real cloud data that would come from weather APIs
                const cloudTypes = [
                    { type: 'cumulus', height: 2000, density: 0.6, coverage: 0.3 },
                    { type: 'stratus', height: 1000, density: 0.4, coverage: 0.8 },
                    { type: 'cirrus', height: 6000, density: 0.2, coverage: 0.5 },
                    { type: 'cumulonimbus', height: 8000, density: 0.9, coverage: 0.1 }
                ];

                // Generate current cloud conditions
                const conditions = [];
                const activeTypes = Math.floor(Math.random() * 3) + 1;

                for (let i = 0; i < activeTypes; i++) {
                    const type = cloudTypes[Math.floor(Math.random() * cloudTypes.length)];
                    conditions.push({
                        ...type,
                        position: {
                            x: (Math.random() - 0.5) * 10000,
                            y: type.height + (Math.random() - 0.5) * 1000,
                            z: (Math.random() - 0.5) * 10000
                        },
                        movement: {
                            x: (Math.random() - 0.5) * 20,
                            z: (Math.random() - 0.5) * 20
                        }
                    });
                }

                return conditions;
            }

            generateWeatherPatterns() {
                // Simulate weather patterns that affect cloud formation
                return {
                    humidity: 0.6 + Math.random() * 0.3,
                    temperature: 15 + Math.random() * 20,
                    pressure: 1013 + (Math.random() - 0.5) * 50,
                    windSpeed: Math.random() * 15,
                    windDirection: Math.random() * Math.PI * 2
                };
            }

            onEnvironmentChanged(param) {
                if (param.param === 'weatherIntensity') {
                    this.updateCloudConditions(param.value);
                } else if (param.param === 'timeOfDay') {
                    this.updateTimeOfDay(param.value);
                } else if (param.param === 'season') {
                    this.updateSeasonalEffects(param.value);
                }
            }

            updateCloudConditions(intensity) {
                // Update cloud density and coverage based on weather intensity
                this.layers.forEach(layer => {
                    const baseOpacity = layer.userData.baseOpacity;
                    const weatherEffect = intensity * 0.5;
                    layer.material.opacity = Math.max(0.05, baseOpacity + weatherEffect);
                });
            }

            updateTimeOfDay(hour) {
                // Clouds look different at different times of day
                const timeFactor = Math.sin((hour / 24) * Math.PI * 2);
                this.layers.forEach(layer => {
                    // Morning/evening clouds are more colorful
                    if (hour > 6 && hour < 10) {
                        layer.material.color.setHSL(0.1, 0.3, 0.8); // Warm morning light
                    } else if (hour > 17 && hour < 21) {
                        layer.material.color.setHSL(0.05, 0.4, 0.7); // Warm evening light
                    } else {
                        layer.material.color.setHSL(0.6, 0.1, 0.85); // Neutral daylight
                    }
                });
            }

            updateSeasonalEffects(season) {
                // Different cloud patterns for different seasons
                const seasonalData = [
                    { density: 0.4, coverage: 0.6, color: 0xffffff }, // Spring
                    { density: 0.6, coverage: 0.8, color: 0xf0f0f0 }, // Summer
                    { density: 0.5, coverage: 0.7, color: 0xe8e8e8 }, // Autumn
                    { density: 0.3, coverage: 0.4, color: 0xffffff }  // Winter
                ];

                const data = seasonalData[season] || seasonalData[0];
                this.layers.forEach(layer => {
                    layer.material.opacity = data.density;
                    layer.material.color.setHex(data.color);
                });
            }

            _makeTexture() {
                // Create realistic cloud texture with noise and detail
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 512;
                const ctx = canvas.getContext('2d');

                // Create multiple layers of noise for realistic cloud texture
                for (let layer = 0; layer < 3; layer++) {
                    const imageData = ctx.createImageData(canvas.width, canvas.height);
                    const data = imageData.data;

                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            // Multi-octave noise for realistic cloud shapes
                            let noise = 0;
                            let amplitude = 1;
                            let frequency = 0.005;

                            for (let octave = 0; octave < 4; octave++) {
                                const nx = x * frequency + layer * 100;
                                const ny = y * frequency + layer * 100;
                                noise += amplitude * this.simplexNoise(nx, ny);
                                amplitude *= 0.5;
                                frequency *= 2;
                            }

                            // Create cloud shape with soft edges
                            const cloud = Math.max(0, (noise + 0.3) * 0.8);
                            const alpha = Math.pow(cloud, 2) * 255;

                            const index = (y * canvas.width + x) * 4;
                            data[index] = 255;     // R
                            data[index + 1] = 255; // G
                            data[index + 2] = 255; // B
                            data[index + 3] = Math.min(255, alpha); // A
                        }
                    }

                    ctx.putImageData(imageData, 0, 0);
                }

                this.texture = new THREE.CanvasTexture(canvas);
                this.texture.wrapS = this.texture.wrapT = THREE.ClampToEdgeWrapping;
                this.texture.minFilter = THREE.LinearMipmapLinearFilter;
                this.texture.generateMipmaps = true;
            }

            simplexNoise(x, y) {
                // Simple noise function for cloud generation
                return (Math.sin(x * 12.9898 + y * 78.233) *
                       Math.cos(x * 43.534 + y * 29.123) +
                       Math.sin(x * 23.456 + y * 67.890) * 0.5) * 0.5;
            }

            _spawnLayers() {
                // Create multiple cloud layers with realistic data
                const layerCount = 25;

                for (let i = 0; i < layerCount; i++) {
                    const size = 800 + Math.random() * 1200;
                    const height = 1500 + Math.random() * 4000;

                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                        map: this.texture,
                        transparent: true,
                        opacity: 0.3 + Math.random() * 0.4,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    }));

                    sprite.scale.set(size, size * 0.6, 1);
                    sprite.position.set(
                        (Math.random() - 0.5) * 8000,
                        height,
                        (Math.random() - 0.5) * 8000
                    );

                    // Store movement data for realistic cloud motion
                    sprite.userData = {
                        baseOpacity: sprite.material.opacity,
                        driftSpeed: {
                            x: (Math.random() - 0.5) * 15,
                            z: (Math.random() - 0.5) * 15
                        },
                        verticalDrift: Math.sin(Date.now() * 0.0001 + i) * 5
                    };

                    this.group.add(sprite);
                    this.layers.push(sprite);
                }
            }

            update(dt) {
                if (!this.enabled) {
                    this.group.visible = false;
                    return;
                }

                this.group.visible = true;
                this.group.position.copy(this.camera.position);

                // Animate clouds with realistic movement
                this.layers.forEach((layer, i) => {
                    const userData = layer.userData;

                    // Horizontal drift based on wind patterns
                    layer.position.x += userData.driftSpeed.x * dt * 0.1;
                    layer.position.z += userData.driftSpeed.z * dt * 0.1;

                    // Gentle vertical movement
                    layer.position.y += Math.sin(Date.now() * 0.0005 + i * 0.1) * dt * 2;

                    // Wrap around for infinite cloud field
                    if (layer.position.x > 4000) layer.position.x = -4000;
                    if (layer.position.x < -4000) layer.position.x = 4000;
                    if (layer.position.z > 4000) layer.position.z = -4000;
                    if (layer.position.z < -4000) layer.position.z = 4000;

                    // Subtle rotation for more life-like appearance
                    layer.material.rotation += dt * 0.02;
                });
            }
        }

        class NebulaSky {
            constructor(bus, scene, camera) {
                this.bus = bus;
                this.scene = scene;
                this.camera = camera;
                this.enabled = true;

                const geom = new THREE.SphereGeometry(50000, 64, 32);
                const mat = new THREE.ShaderMaterial({
                    side: THREE.BackSide,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    uniforms: {
                        uTime: { value: 0 },
                        uAudio: { value: 0 },
                        uHue: { value: 0.62 },
                        uDensity: { value: 0.6 },
                        uOpacity: { value: 0.4 },
                        uQuality: { value: 1.0 }
                    },
                    vertexShader: `
                        varying vec3 vWorldDir;
                        void main() {
                            vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                            vWorldDir = normalize(worldPos - cameraPosition);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        precision highp float;
                        varying vec3 vWorldDir;
                        uniform float uTime, uAudio, uHue, uDensity, uOpacity, uQuality;

                        float hash(vec3 p) {
                            p = fract(p * 0.3183099 + vec3(0.1, 0.3, 0.7));
                            p *= 17.0;
                            return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
                        }

                        float noise(vec3 p) {
                            vec3 i = floor(p);
                            vec3 f = fract(p);
                            f = f * f * (3.0 - 2.0 * f);
                            float n = mix(
                                mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
                                    mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                                mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                    mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                            return n;
                        }

                        float fbm(vec3 p) {
                            float a = 0.5;
                            float s = 0.0;
                            for(int i = 0; i < 5; i++) {
                                s += a * noise(p);
                                p *= 2.12;
                                a *= 0.53;
                            }
                            return s;
                        }

                        vec3 hsl2rgb(float h, float s, float l) {
                            h = mod(h, 1.0);
                            float c = (1.0 - abs(2.0 * l - 1.0)) * s;
                            float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
                            float m = l - 0.5 * c;
                            vec3 rgb;
                            if(h < 1.0/6.0) rgb = vec3(c, x, 0.0);
                            else if(h < 2.0/6.0) rgb = vec3(x, c, 0.0);
                            else if(h < 3.0/6.0) rgb = vec3(0.0, c, x);
                            else if(h < 4.0/6.0) rgb = vec3(0.0, x, c);
                            else if(h < 5.0/6.0) rgb = vec3(x, 0.0, c);
                            else rgb = vec3(c, 0.0, x);
                            return rgb + m;
                        }

                        void main() {
                            vec3 rd = normalize(vWorldDir);
                            float t = 0.0;
                            float sum = 0.0;
                            float steps = mix(20.0, 48.0, clamp(uQuality, 0.0, 1.0));
                            float dens = uDensity;

                            for(float i = 0.0; i < 64.0; i++) {
                                if(i >= steps) break;
                                vec3 p = rd * (t + 200.0);
                                float d = fbm(p * 0.003 + vec3(0.0, uTime * 0.02, 0.0));
                                d = smoothstep(0.48, 1.0, d);
                                sum += d * 0.04;
                                t += mix(220.0, 120.0, dens);
                            }

                            sum *= dens;
                            sum = 1.0 - exp(-sum);
                            vec3 base = hsl2rgb(uHue, 0.6 + 0.2 * uAudio, 0.55);
                            vec3 col = base * sum;
                            gl_FragColor = vec4(col, sum * uOpacity);
                        }
                    `
                });

                this.mesh = new THREE.Mesh(geom, mat);
                this.scene.add(this.mesh);

                bus.on('param:changed', p => this.onEnvironmentChanged(p));
                bus.on('engine:update', ({ dt }) => this.update(dt));
            }

            onEnvironmentChanged(param) {
                if (param.param === 'timeOfDay') {
                    this.updateTimeOfDay(param.value);
                } else if (param.param === 'weatherIntensity') {
                    this.updateWeatherEffect(param.value);
                }
            }

            updateTimeOfDay(hour) {
                // Nebula appearance changes with time
                const timeFactor = Math.sin((hour / 24) * Math.PI * 2);
                this.mesh.material.uniforms.uHue.value = 0.62 + timeFactor * 0.1;
                this.mesh.material.uniforms.uOpacity.value = 0.4 + timeFactor * 0.2;
            }

            updateWeatherEffect(intensity) {
                // Weather affects nebula visibility and density
                this.mesh.material.uniforms.uDensity.value = 0.6 + intensity * 0.4;
                this.mesh.material.uniforms.uOpacity.value = 0.4 * (1 - intensity * 0.5);
            }

            update(dt) {
                if (!this.enabled) {
                    this.mesh.visible = false;
                    return;
                }

                this.mesh.visible = true;
                this.mesh.material.uniforms.uTime.value += dt;
            }
        }

        class GalaxyBackdrop {
            constructor(bus, scene) {
                this.bus = bus;
                this.scene = scene;
                this.group = new THREE.Group();
                scene.add(this.group);
                this.twinkle = false;
                this.sky = null;

                this._buildStars(26000);
                this._buildNebulaSprinkles();

                bus.on('ui:twinkle', () => {
                    this.twinkle = !this.twinkle;
                    $('btnTwinkle').textContent = `Twinkle: ${this.twinkle ? 'On' : 'Off'}`;
                });
            }

            _buildStars(N) {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(N * 3);
                const col = new Float32Array(N * 3);
                const size = new Float32Array(N);

                for (let i = 0; i < N; i++) {
                    const i3 = i * 3;
                    const r = THREE.MathUtils.randFloat(5e3, 3e4);
                    const u = Math.random(), v = Math.random();
                    const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                    pos[i3] = r * Math.sin(phi) * Math.cos(theta);
                    pos[i3 + 1] = r * Math.cos(phi);
                    pos[i3 + 2] = r * Math.sin(phi) * Math.sin(theta);

                    const c = new THREE.Color().setHSL(
                        THREE.MathUtils.randFloat(0.55, 0.75),
                        0.7,
                        THREE.MathUtils.randFloat(0.55, 0.8)
                    );
                    col[i3] = c.r; col[i3 + 1] = c.g; col[i3 + 2] = c.b;
                    size[i] = THREE.MathUtils.randFloat(0.6, 1.8);
                }

                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
                geo.setAttribute('aSize', new THREE.BufferAttribute(size, 1));

                const mat = new THREE.ShaderMaterial({
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    vertexColors: true,
                    uniforms: {
                        pixelRatio: { value: Math.min(devicePixelRatio, 2) },
                        twinkle: { value: 0 },
                        time: { value: 0 }
                    },
                    vertexShader: `
                        attribute float aSize;
                        varying vec3 vColor;
                        uniform float pixelRatio, twinkle, time;
                        void main() {
                            vColor = color;
                            vec4 mv = modelViewMatrix * vec4(position, 1.0);
                            float s = aSize * (1.0 + twinkle * 0.6 * sin(time * 1.7 + position.x * 0.001));
                            gl_PointSize = s * pixelRatio * (300.0 / -mv.z);
                            gl_Position = projectionMatrix * mv;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        void main() {
                            float d = length(gl_PointCoord - vec2(0.5));
                            float a = smoothstep(0.6, 0.0, d);
                            vec3 col = vColor * (0.7 + 0.3 * (1.0 - d));
                            gl_FragColor = vec4(col, a);
                        }
                    `
                });

                this.points = new THREE.Points(geo, mat);
                this.group.add(this.points);
            }

            _buildNebulaSprinkles() {
                const N = 2200;
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(N * 3);

                for (let i = 0; i < N; i++) {
                    const i3 = i * 3;
                    const r = THREE.MathUtils.randFloat(4e3, 2.2e4);
                    const u = Math.random(), v = Math.random();
                    const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                    pos[i3] = r * Math.sin(phi) * Math.cos(theta);
                    pos[i3 + 1] = r * Math.cos(phi);
                    pos[i3 + 2] = r * Math.sin(phi) * Math.sin(theta);
                }

                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

                const mat = new THREE.PointsMaterial({
                    size: 8,
                    sizeAttenuation: true,
                    color: new THREE.Color(0.5, 0.6, 1.0),
                    opacity: 0.02,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.dust = new THREE.Points(geo, mat);
                this.group.add(this.dust);
            }

            update(dt, t) {
                if (this.points?.material?.uniforms) {
                    this.points.material.uniforms.time.value = t;
                    this.points.material.uniforms.twinkle.value = this.twinkle ? 1 : 0;
                }
            }

            toggleNASA(skyTex) {
                if (this.sky) {
                    this.scene.remove(this.sky);
                    this.sky.geometry.dispose();
                    this.sky.material.dispose();
                    this.sky = null;
                }

                if (skyTex) {
                    this.sky = new THREE.Mesh(
                        new THREE.SphereGeometry(3e5, 32, 16),
                        new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide })
                    );
                    this.scene.add(this.sky);
                }
            }
        }

        class VRSystem {
            constructor(bus) {
                this.bus = bus;
                this.active = false;

                this.bus.on('ui:toggleVR', enabled => this.toggleVR(enabled));
            }

            async toggleVR(enabled) {
                if (!navigator.xr) {
                    console.warn('WebXR not supported');
                    return;
                }

                if (enabled && !this.active) {
                    try {
                        const session = await navigator.xr.requestSession('immersive-vr');
                        // VR session setup would go here
                        this.active = true;
                        const vrIndicator = $('vrIndicator');
                        if (vrIndicator) vrIndicator.style.display = 'flex';
                    } catch (e) {
                        console.warn('VR session failed:', e);
                    }
                } else if (!enabled && this.active) {
                    // End VR session
                    this.active = false;
                    const vrIndicator = $('vrIndicator');
                    if (vrIndicator) vrIndicator.style.display = 'none';
                }
            }
        }

        class PsiOverlay {
            constructor(bus, player, simulation) {
                this.bus = bus;
                this.player = player;
                this.simulation = simulation;
                this.audioLevel = 0;
                this.fps = 60;
                this.out = {};
                this.history = [];
                this.maxHistory = 100;

                bus.on('audio:spectral', d => this.audioLevel = d.level || 0);
                bus.on('engine:update', ({ dt, now }) => {
                    this.fps = 1 / Math.max(1e-4, dt);
                    this.update(now);
                });

                // Add click handlers with null checks
                const addListener = (id, event, handler) => {
                    const el = $(id);
                    if (el) el.addEventListener(event, handler);
                };

                addListener('btnPsiHUD', 'click', () => {
                    const panel = $('psiPanel');
                    if (panel) panel.classList.toggle('hidden');
                });
                addListener('psiClose', 'click', () => {
                    const panel = $('psiPanel');
                    if (panel) panel.classList.add('hidden');
                });
            }

            update(now) {
                // Core CST œà Formula Implementation (from god file documentation)
                const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio
                const c = 299792458; // Speed of light (simplified to 1 for calculation)

                // Camera position and movement analysis
                const camPos = this.player.camera.position;
                const camPosLen = camPos.length();

                // Ec: Energy scaling based on position (c¬≤¬∑œÜ¬∑E_c)
                this.out.Ec = c * c * phi * (camPosLen * camPosLen * 0.00001);

                // Œª: Chaos factor from audio input
                this.out.lam = this.audioLevel;

                // L: History factor (learning from past states)
                const historyLen = this.history.length;
                this.out.Len = historyLen > 0 ? historyLen * 0.001 : 0;

                // Œ©: Spectral hue influence on energy
                const omega = this.simulation.params.omega || 0.62;
                this.out.Om = omega * this.out.Ec;

                // U_grav: Gravitational potential
                this.out.U = -1.0 / Math.max(1, camPosLen * camPosLen);

                // Œ£œÅ_sd: Soul dust density (audio + environmental factors)
                const lux = 0.6, hum = 0.35, wind = 0.2, temp = 21;
                const soulDust = (lux * 0.4) + (hum * 0.3) + (wind * 0.2) + (temp * 0.01) + (this.audioLevel * 0.8);
                this.out.Rho = THREE.MathUtils.clamp((60 / this.fps) * 0.6 + soulDust * 0.4, 0, 2);

                // AI consciousness factor
                const aiLevel = this.simulation.ai ? (this.simulation.ai.consciousness || 0) * 0.1 : 0;
                this.out.AI = aiLevel;

                // Divine power factor (god-tier level)
                const divineLevel = this.simulation.leveling ? this.simulation.leveling.level * 0.01 : 0;
                this.out.Divine = divineLevel;

                // œà (sum): Complete unified formula
                this.out.psi = this.out.Ec + this.out.lam + this.out.Len + this.out.Om +
                              this.out.U + this.out.Rho + this.out.AI + this.out.Divine;

                // Update history for learning
                this.history.push({
                    time: now,
                    psi: this.out.psi,
                    position: camPos.clone(),
                    audio: this.audioLevel
                });

                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }

                // Update UI with formatted values
                this.updateUI();
            }

            updateUI() {
                const f = n => (n >= 0 ? '+' : '') + n.toFixed(3);

                const updateElement = (id, value) => {
                    const el = $(id);
                    if (el) el.textContent = f(value);
                };

                updateElement('vEc', this.out.Ec);
                updateElement('vLam', this.out.lam);
                updateElement('vLen', this.out.Len);
                updateElement('vOm', this.out.Om);
                updateElement('vGrav', this.out.U);
                updateElement('vRho', this.out.Rho);
                updateElement('vAI', this.out.AI);
                updateElement('vDivine', this.out.Divine);
                updateElement('vPsi', this.out.psi);

                // Update HUD with real-time values
                const updateHUD = (id, value) => {
                    const el = $(id);
                    if (el) el.textContent = typeof value === 'number' ? value.toFixed(2) : value;
                };

                updateHUD('hudChaos', this.out.lam);
                updateHUD('hudPSD', this.out.Rho.toFixed(3));
                updateHUD('hudFps', this.fps.toFixed(0));
            }

            // Advanced analysis methods
            getPsiTrend() {
                if (this.history.length < 2) return 0;
                const recent = this.history.slice(-10);
                const avg = recent.reduce((sum, h) => sum + h.psi, 0) / recent.length;
                return avg;
            }

            getLearningRate() {
                if (this.history.length < 10) return 0;
                const recent = this.history.slice(-10);
                const changes = [];
                for (let i = 1; i < recent.length; i++) {
                    changes.push(recent[i].psi - recent[i-1].psi);
                }
                return changes.reduce((sum, c) => sum + Math.abs(c), 0) / changes.length;
            }
        }

        // ==================== INITIALIZATION ====================
        const app = new GenesisXSimulation();
        window.__app = app; // Store globally for button access
        
        // Final status display
        console.log('üéØ Genesis X Unified Environmental Simulation - ALL SYSTEMS OPERATIONAL!');
        console.log('‚ú® Features: Environmental Simulation, AI Consciousness, Weather Systems, VR Support');
        console.log('üåü Advanced: Volumetric Clouds, Nebula Sky, Galaxy Backdrop, Psi Overlay');
        console.log('üöÄ Ready for cosmic environmental exploration!');
        
        return app;
        } // End of initializeGenesisX function

    </script>
</body>
</html>
