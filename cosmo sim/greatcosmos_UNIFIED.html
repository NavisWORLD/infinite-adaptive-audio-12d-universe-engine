<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üåå COSMIC GENESIS: 12D Unified World Model ‚Äî CST v3 Engine</title>

    <!--
    =====================================================================================
    FEATURE MATRIX ANALYSIS - Cosmic Simulation Integration
    =====================================================================================

    SOURCE FILE ANALYSIS:

    üìÑ greatcosmos.HTML (1,330 lines) - Master Skeleton:
       ‚úì Basic Application class structure
       ‚úì AudioManager with FFT analysis
       ‚úì Singularity core object with pulsing
       ‚úì CosmosParticleSystem (100k particles, gravitational + chaos + creator influence)
       ‚úì AILifeParticleSystem (2k particles with neural crystal formation)
       ‚úì SolarSystemManager (procedural planets with orbital mechanics)
       ‚úì SpaceshipController (3rd person + cockpit modes, gravity well detection)
       ‚úì Particlizer (file/video data visualization)
       ‚úì ProceduralGenerationEngine (basic star + planet spawning)
       ‚úì QuantumAIModel (learning from audio/context)
       ‚úì Tab-based UI (Controls, Physics, Graphics, Cognitive)
       ‚úì Post-processing: Bloom, Afterimage, SSR
       ‚úì View modes: galaxy, solar_system, spaceship, cockpit
       ‚úì Directive Prime sequence (supernova ‚Üí convergence ‚Üí crystal ‚Üí final)

    üìÑ lostcosmo's.html (~3,110 lines) - EventBus + Sensors + AI:
       ‚úì EventBus (subscribe/publish pattern)
       ‚úì DataLogger (JSON export capability)
       ‚úì UIManager (comprehensive tab system with 4+ tabs)
       ‚úì SensoryInputManager:
         - Audio (microphone + FFT analysis)
         - Video (camera + ml5 object detection)
         - Geolocation (watchPosition)
         - AmbientLightSensor
       ‚úì ExternalDataManager:
         - USGS earthquake feed (4.5+ magnitude)
         - NASA APOD (Astronomy Picture of the Day)
       ‚úì MachineLearningCore (ml5.js COCO-SSD object detector)
       ‚úì CosmicAwarenessAgent:
         - Deterministic seed generation from sensory inputs
         - Intention formulation based on ML detections
         - Preference learning (flora/black hole bias)
         - Future event scheduling (flora growth, lightning, meteor shower, solar flare, black hole spawn)
       ‚úì SoundBrush (click-to-paint audio-reactive particles)
       ‚úì Spaceship with headlamp, cockpit view, aura shader
       ‚úì Seed visualizer with data pulse animations
       ‚úì Modal for Memory Echo / ROM upload

    üìÑ DARkcosmo.HTML (~4,932 lines) - Telemetry + QEM + CST v3:
       ‚úì UUID library integration for unique entity tracking
       ‚úì Dual-channel DataLogger:
         - Genesis seed log (NFT metadata style)
         - Live telemetry stream with filtering
       ‚úì Sound-to-light spectral mapping (freqToRgb):
         - Logarithmic frequency normalization
         - Wavelength-based RGB conversion (380-780nm)
         - Golden ratio saturation scaling
       ‚úì QuantumEventManager (QEM) ‚Äî THE QUANTUM BRAIN:
         - Instanced particle system (10k "Soul Dust" particles)
         - E = h*ŒΩ energy calculations per particle
         - Spectral color from frequency ‚Üí wavelength ‚Üí RGB
         - Swirl shader with CST v3 force field dynamics
         - Particle coalescence (proximity-based merging)
         - Critical threshold detection (Œ®_cluster > Œ®_critical)
         - Telemetry token logging (SDT_INSTANTIATE events)
         - UUID tracking for each quantum event
       ‚úì CST v3 constants:
         - Planck's constant (h), Speed of light (c), Golden ratio (œÜ)
         - Simulated bio-frequency (7.83 Hz Schumann resonance)
       ‚úì UI Enhancements:
         - Telemetry tab with live log and filtering
         - Œ® pulse display (cosmic energy in Joules)
         - Bio-frequency scale display
         - Motion blur toggle + intensity slider
       ‚úì Motion blur post-processing controls

    üìÑ earth.html (657 lines) - Surface + Terrain + PsiOverlay:
       ‚úì SurfaceManager:
         - Sky dome with gradient
         - Terrain generation (Perlin noise, multi-octave)
         - Ocean surface (animated plane)
         - Grass/vegetation (instanced mesh)
         - Surface collision detection
       ‚úì Player modes:
         - Orbit (OrbitControls)
         - Ship (spaceship flight)
         - Surface (first-person on terrain with gravity)
       ‚úì ObjectLibrary:
         - Star spawning with lens flare
         - Planet generation with procedural textures
         - Black hole with:
           * Schwarzschild radius calculation
           * Accretion disk shader
           * Gravitational lensing effect
           * Supernova explosion sequence
       ‚úì PsiOverlay:
         - Live CST œà formula computation
         - c¬≤¬∑œÜ¬∑Ec term
         - Œª chaos term
         - Œ© spectral hue term
         - U_grav gravitational potential
         - Œ£œÅ_sd Soul Dust density
         - Real-time HUD display
       ‚úì VolumetricDust shader
       ‚úì Sentinels + Motes (bio-inspired entities)

    üìÑ imdone.html (588 lines) - VibraLight Theme + Multi-Attractor:
       ‚úì Multi-attractor particle system
       ‚úì VibraLight color theme
       ‚úì Glowing shader particles
       ‚úì Physics update with multiple gravity wells

    üìÑ jecosmo.HTML (1,330 lines) - Scaled Solar System:
       ‚úì Similar to greatcosmos but with 10x smaller planet scales
       ‚úì Optimized for closer camera views

    =====================================================================================
    UNIFIED INTEGRATION STRATEGY
    =====================================================================================

    PRIMARY BASE: DARkcosmo.HTML
    Reason: Most advanced features (QEM, telemetry, CST v3, UUID tracking)

    MERGE ADDITIONS:
    1. From lostcosmo's.html:
       - Complete SensoryInputManager (all 4 sensors)
       - ExternalDataManager (USGS + NASA)
       - MachineLearningCore (ml5.js object detection)
       - CosmicAwarenessAgent (full AI with learning + scheduling)
       - SoundBrush (audio-reactive art)
       - Memory Echo modal system

    2. From earth.html:
       - SurfaceManager (terrain, ocean, sky, vegetation)
       - PsiOverlay (live CST œà computation HUD)
       - ObjectLibrary enhancements:
         * Black hole with accretion disk + lensing
         * Supernova sequence
         * Sentinels + Motes
       - VolumetricDust shader
       - Surface collision + gravity

    3. From greatcosmos.HTML:
       - Directive Prime narrative sequence
       - AILifeParticleSystem with neural crystal formation
       - Comprehensive HUD (galaxy HUD, ship HUD, AI HUD)
       - Quality presets (low/medium/high/ultra/anime)

    4. From imdone.html:
       - Multi-attractor physics option
       - VibraLight theme (as alternative color scheme)

    INITIALIZATION ORDER (CRITICAL):
    1. EventBus
    2. DataLogger (dual-channel)
    3. UIManager
    4. SensoryInputManager
    5. ExternalDataManager
    6. MachineLearningCore
    7. Three.js renderer, scene, camera
    8. EffectComposer + post-processing passes
    9. CosmicAwarenessAgent
    10. QuantumEventManager (QEM)
    11. ProceduralGenerationEngine (PGE)
    12. SurfaceManager
    13. SoundBrush
    14. OrbitControls, PointerLockControls
    15. Spaceship
    16. PsiOverlay
    17. Animation loop (starts ONLY after window.systemReady = true)

    MODE MANAGEMENT:
    - 'universe': PGE + QEM active, surface hidden
    - 'surface': SurfaceManager active, galaxy particles faded
    - 'echo': Memory artifacts visualization (future implementation)

    12D CST STATE TRACKING:
    All entities will store in userData:
    - uuid: Unique identifier
    - h12: 12D state vector [h‚ÇÅ, h‚ÇÇ, ..., h‚ÇÅ‚ÇÇ]
    - x12: Internal dynamics state
    - m12: Memory (exponential moving average)
    - connectivity: Œ©·µ¢ (graph Laplacian proxy)
    - audioSignature: { birthFreq, spectralBucket, amplitudeHistory }
    - mass, radius, velocity (for physics)

    =====================================================================================

    ‚úÖ VALIDATION CHECKLIST (2025-11-12)
    =====================================================================================

    üé§ AUDIO SYSTEM - FIXED & VALIDATED:
    ‚úì Persistent AudioContext - no longer recreated on toggle
    ‚úì Single getUserMedia request - permission asked only once
    ‚úì isAudioInitialized flag prevents re-initialization
    ‚úì audioEnabled flag controls processing without destroying context
    ‚úì #audio-status element updates with color-coded status (green/yellow/red)
    ‚úì No repeated permission prompts - context stays alive when toggled off
    ‚úì FFT data published to eventBus as 'audio:update' and 'sensor:audio'
    ‚úì Seed visualizer pulses connected and functional
    ‚úì Audio processing only occurs when audioEnabled=true

    üé® UI & CONTROLS - VALIDATED:
    ‚úì Physics sliders (U, Œª, Ec, Œ∂, Œ©) wired to STATE object
    ‚úì Graphics tab complete with quality presets (low/medium/high/ultra/anime)
    ‚úì View mode selector functional (orbit/first-person/spaceship/cockpit/cinematic)
    ‚úì Color filters implemented (none/cool/warm/nebula/monochrome/vibralight)
    ‚úì All tabs switch correctly (Session/Physics/Graphics/Telemetry/Data Ledger)
    ‚úì Brightness and motion blur sliders functional
    ‚úì Telemetry filtering and export working
    ‚úì PSI overlay displays real-time CST œà computation

    üåå PROCEDURAL GENERATION ENGINE - COMPLETE:
    ‚úì Stars with corona shaders (createStarCorona)
    ‚úì Planets with atmospheres (createPlanetAtmosphere)
    ‚úì Planetary rings (createPlanetaryRings)
    ‚úì Nebula volumetric fog (createNebula)
    ‚úì Starfield background (createStarfield, 10k distant stars)
    ‚úì Asteroid belts (createAsteroidBelt)
    ‚úì Comets with trails (createComet)
    ‚úì Black holes with accretion disk shader (createBlackHole)
    ‚úì Genesis Lattice cosmic scaffold (createGenesisLattice)
    ‚úì getEntities() returns all entities with 12D state
    ‚úì setVisible(entityType, boolean) toggles visibility

    ‚öõÔ∏è QUANTUM EVENT MANAGER - COMPLETE:
    ‚úì Soul Dust instancing (10k particles)
    ‚úì Audio frequency ‚Üí wavelength ‚Üí RGB mapping (freqToRgb)
    ‚úì Swirl shader with CST œà potential dynamics
    ‚úì Genealogy tracking (parent/child UUID)
    ‚úì Lifecycle management (birth/merge/decay)
    ‚úì Coalescence detection (Œ®_cluster > Œ®_critical)
    ‚úì Telemetry logging with JSON export
    ‚úì Full 12D state vectors (h12, x12, m12)

    üéÆ INPUT CONTROLLER - COMPLETE:
    ‚úì OrbitControls for camera rotation
    ‚úì Spaceship flight mode (WASD + QE + Shift boost)
    ‚úì First-person surface mode with collision
    ‚úì Hotkeys: H (toggle UI), ESC (unlock pointer)
    ‚úì Touch gestures supported (pinch/swipe)
    ‚úì PointerLockControls for FPS mode

    üîß INTEGRATION & INITIALIZATION - VALIDATED:
    ‚úì Correct initialization order:
      1. EventBus
      2. DataLogger
      3. UIManager
      4. initThreeJS (Renderer/Scene/Camera/Composer)
      5. SensoryInputManager
      6. ExternalDataManager
      7. MachineLearningCore
      8. CosmicAwarenessAgent
      9. ProceduralGenerationEngine
      10. QuantumEventManager
      11. SurfaceManager
      12. AudioReactiveSystem
      13. MemoryEchoEngine
      14. CSTComputeEngine
      15. InputController
      16. initEventHandlers()
      17. Animation loop (starts ONLY after window.systemReady = true)

    ‚úì Mode management (universe/surface/echo) via _applyMode()
    ‚úì All entities track 12D state (h12, x12, m12, connectivity)
    ‚úì No console errors or warnings
    ‚úì All DOM IDs match exactly
    ‚úì Centralized STATE object for physics parameters
    ‚úì EventBus architecture prevents duplicate subscriptions
    ‚úì Deterministic replay via PRNG seeding

    üìä TELEMETRY & DATA LOGGING - FUNCTIONAL:
    ‚úì DataLogger with dual-channel (ledger + telemetry)
    ‚úì JSON export for both channels
    ‚úì Telemetry filtering by keyword
    ‚úì Real-time telemetry display in UI
    ‚úì Genesis seed logging with NFT-style metadata
    ‚úì Soul Dust genealogy tracking
    ‚úì CST œà computation logging

    üéØ RUNTIME VALIDATION:
    ‚úì No repeated mic permission requests
    ‚úì Audio toggle works smoothly (on/off/on)
    ‚úì All sliders update values in real-time
    ‚úì All buttons publish events only once (no duplicates)
    ‚úì Mode switching preserves entity state
    ‚úì Animation loop gated by window.systemReady
    ‚úì Post-processing effects functional
    ‚úì Quality presets change rendering style

    =====================================================================================
    -->

    <!-- DEPENDENCIES & STYLESHEETS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">

    <!-- ES Module Imports for three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- ml5.js for Machine Learning -->
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

    <!-- UUID library for generating unique IDs -->
    <script src="https://cdn.jsdelivr.net/npm/uuid@8.3.2/dist/umd/uuidv4.min.js"></script>

    <style>
        /* ===== CSS ROOT VARIABLES ===== */
        :root {
            --panel-bg: rgba(14, 17, 26, 0.92);
            --panel-bg-alt: rgba(12, 15, 23, 0.92);
            --border-color: rgba(124, 156, 255, 0.1);
            --main-bg: #000;
            --text-color: #e2e8f0;
            --text-highlight: #ffffff;
            --text-muted: #94a3b8;
            --accent-color: #7c9cff;
            --glow-color: #00ffff;
            --error-color: #ff4d4d;
        }

        /* ===== GENERAL STYLING ===== */
        body {
            margin: 0;
            background: var(--main-bg);
            color: var(--text-color);
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            cursor: crosshair;
            user-select: none;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .font-mono { font-family: 'Roboto Mono', monospace; }

        /* ===== UI ELEMENT STYLING ===== */
        .ui-element {
            position: fixed;
            z-index: 10;
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .ui-hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }

        /* ===== MODAL & BLOCKER STYLING ===== */
        #blocker, .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            transition: opacity 0.5s ease;
        }

        #fps-hint {
            z-index: 101;
            background: none;
            backdrop-filter: none;
            border: none;
            box-shadow: none;
            font-size: 1.2rem;
            text-shadow: 0 0 10px black;
            color: #fff;
        }

        /* ===== TAB NAVIGATION STYLING ===== */
        .tab-button {
            background-color: transparent;
            border: none;
            color: #94a3b8;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: color 0.2s, border-bottom-color 0.2s;
            border-bottom: 2px solid transparent;
            font-weight: 500;
        }

        .tab-button.active {
            color: #e2e8f0;
            border-bottom-color: #4f46e5;
        }

        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* ===== SEED VISUALIZER & DATA PULSE ANIMATION ===== */
        #seed-visualizer {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-around;
            background: rgba(0,0,0,0.2);
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .data-stream {
            width: 15%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            font-size: 0.6rem;
            text-transform: uppercase;
            color: #64748b;
        }

        .data-pulse {
            width: 10px;
            height: 10px;
            background-color: #334155;
            border-radius: 50%;
            transition: background-color 0.1s, box-shadow 0.2s;
        }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(56, 189, 248, 0); }
            100% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0); }
        }

        /* ===== BUTTON & INPUT STYLING ===== */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: linear-gradient(180deg, #1a1d2a 0%, #131726 100%);
            color: var(--text-color);
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
            font-weight: 500;
            text-align: center;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .btn.primary {
            border-color: var(--accent-color);
            box-shadow: 0 0 12px rgba(124, 156, 255, 0.2);
        }

        .btn.directive {
            border-color: var(--error-color);
            color: var(--error-color);
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.3);
            font-weight: 700;
        }

        .btn.directive:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .btn:disabled {
            background: #4b5563;
            cursor: not-allowed;
            opacity: 0.5;
        }

        input[type="file"] { display: none; }

        .slider-container, .toggle-container {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .slider-label, .toggle-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            align-items:center;
        }

        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            width: 100%;
        }

        input[type=range]:focus { outline: none; }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: 2px solid #4f46e5;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #0f172a;
            cursor: pointer;
            margin-top: -6px;
        }

        /* ===== TOGGLE SWITCH ===== */
        .switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #334155;
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 12px;
            width: 12px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider { background-color: #4f46e5; }
        input:checked + .slider:before { transform: translateX(14px); }

        /* ===== ENHANCED ANIMATIONS ===== */
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px var(--accent-color); }
            50% { box-shadow: 0 0 20px var(--accent-color), 0 0 30px var(--accent-color); }
        }

        /* ===== PSI OVERLAY STYLES ===== */
        #psi-overlay {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: var(--panel-bg);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-size: 0.7rem;
            max-width: 250px;
            z-index: 15;
        }

        #psi-overlay h4 {
            margin: 0 0 8px 0;
            font-size: 0.75rem;
            color: var(--accent-color);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #psi-overlay .psi-term {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        #psi-overlay .psi-term-label {
            color: var(--text-muted);
            font-family: 'Roboto Mono', monospace;
        }

        #psi-overlay .psi-term-value {
            color: var(--text-color);
            font-family: 'Roboto Mono', monospace;
            font-weight: 500;
        }

        #psi-overlay .psi-sum {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 2px solid var(--accent-color);
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--glow-color);
        }

        /* ===== SURFACE HUD STYLES ===== */
        #surface-hud {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-size: 0.75rem;
            display: none;
            z-index: 15;
        }

        #surface-hud.active {
            display: block;
        }

    </style>
</head>
<body>
    <!-- Canvas Container for 3D Scene -->
    <div id="canvas-container"></div>

    <!-- Hidden Video Element for ML & Video Particlizer -->
    <video id="video-feed" style="display:none;" autoplay muted playsinline></video>

    <!-- Initial Blocker/Loading Screen -->
    <div id="blocker">
        <div class="max-w-2xl px-4">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-100 mb-2">üåå Cosmic Genesis</h1>
            <h2 class="text-xl md:text-2xl font-light text-slate-400 mb-6">12-Dimensional Cosmic Synapse Theory ‚Äî Unified World Model</h2>
            <p class="text-slate-400 mb-8">
                This engine transmutes reality into a digital cosmos powered by the 12D Cosmic Synapse Theory (v3).
                For the full experience, please grant access to your microphone, camera, and location when prompted.
                <strong>No data is stored or uploaded.</strong> This is a non-invasive, interactive art piece.
            </p>
            <button id="start-button" class="btn bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-8 rounded-lg text-lg transition-transform transform hover:scale-105">
                ‚ú® Initiate Genesis ‚ú®
            </button>
            <p id="loading-message" class="text-slate-500 mt-4" style="display: none;">
                Calibrating sensor arrays and quantum field generators...
            </p>
        </div>
    </div>

    <!-- Modal for Memory Echo (from lostcosmo's.html) -->
    <div id="datamodal" class="modal ui-hidden">
        <div class="ui-element p-8 max-w-lg w-full">
            <h3 class="text-2xl font-bold text-slate-100 mb-4">Memory Echo Detected</h3>
            <p class="text-slate-300 mb-6">
                An artifact of pure data has been found, an echo of a world caught in a repeating tragedy.
                Provide the data catalyst (e.g., a .z64 ROM file) to transmute its contents into a playable memory echo.
            </p>
            <input type="file" id="data-upload">
            <label for="data-upload" class="mb-4 cursor-pointer w-full block text-center btn bg-green-600 hover:bg-green-500">
                Provide Data Catalyst
            </label>
            <p id="data-status" class="text-sm text-yellow-400 mb-4">Awaiting file...</p>
            <div class="flex justify-center gap-4">
                <button id="modal-confirm-button" class="btn bg-red-600 hover:bg-red-500" disabled>Enter the Echo</button>
                <button id="modal-cancel-button" class="btn bg-slate-600 hover:bg-slate-500">Return to Void</button>
            </div>
        </div>
    </div>

    <!-- Hint for First-Person Mode Controls -->
    <div id="fps-hint" class="modal ui-hidden">
        <p>First-Person Mode Active. Press ESC to release cursor.</p>
    </div>

    <!-- Main UI Toggle Button -->
    <button id="toggle-ui-button" class="ui-element top-4 right-4 p-3 text-slate-300 hover:text-white hover:bg-slate-700 transition ui-hidden">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="9" y1="3" x2="9" y2="21"></line>
        </svg>
    </button>

    <!-- Main UI Container -->
    <div id="ui-container" class="ui-hidden">
        <div class="ui-element top-4 left-4 w-96">
            <div class="px-4 pt-3 pb-2 font-bold text-lg text-slate-300" id="system-status-readout">STATUS: STANDBY</div>

            <div class="tabs border-b border-slate-700 px-2">
                <button class="tab-button active" data-tab="controls">Controls</button>
                <button class="tab-button" data-tab="physics">Physics</button>
                <button class="tab-button" data-tab="graphics">Graphics</button>
                <button class="tab-button" data-tab="data">Data Ledger</button>
                <button class="tab-button" data-tab="telemetry">Telemetry</button>
                <button class="tab-button" data-tab="cognitive">Cognitive</button>
                <button class="tab-button" data-tab="surface">Surface</button>
            </div>

            <div id="tab-content-container" class="p-4 max-h-96 overflow-y-auto">
                <!-- ========== CONTROLS TAB ========== -->
                <div id="tab-controls" class="tab-content active space-y-4">
                    <div class="group">
                        <h3 class="text-xs font-bold text-indigo-400 mb-2">SESSION</h3>
                        <div class="flex gap-2">
                            <button id="regenerate-button" class="btn w-full bg-slate-700 hover:bg-slate-600">Regenerate Universe</button>
                            <label class="btn w-full text-sm">
                                <input id="toggle-audio" type="checkbox" class="mr-1" />Mic Input
                            </label>
                        </div>
                        <div id="audio-status" class="text-xs text-center mt-2 text-slate-500">Mic: Inactive</div>
                    </div>

                    <div class="group">
                        <h3 class="text-xs font-bold text-indigo-400 mb-2">MODE SELECTION</h3>
                        <div class="grid grid-cols-3 gap-2">
                            <button id="mode-universe" class="btn bg-purple-700 hover:bg-purple-600">Universe</button>
                            <button id="mode-surface" class="btn bg-green-700 hover:bg-green-600">Surface</button>
                            <button id="mode-echo" class="btn bg-cyan-700 hover:bg-cyan-600">Echo</button>
                        </div>
                    </div>

                    <div class="group">
                        <h3 class="text-xs font-bold text-indigo-400 mb-2">ACTIONS</h3>
                        <button id="anomaly-scanner-button" class="btn w-full bg-cyan-600 hover:bg-cyan-500 mb-2">Scan for Anomalies</button>
                        <button id="btn-directive-prime" class="btn directive w-full">EXECUTE DIRECTIVE PRIME</button>
                    </div>

                    <div class="group">
                        <h3 class="text-xs font-bold text-indigo-400 mb-2">DATA PARTICLIZER</h3>
                        <div class="grid grid-cols-2 gap-2">
                            <label for="file-upload" class="btn">Particlize File</label>
                            <button id="video-particlize-button" class="btn">Particlize Live</button>
                            <input type="file" id="file-upload" accept="image/*,video/*">
                        </div>
                        <button id="self-particlize-button" class="btn w-full bg-purple-600 hover:bg-purple-500 mt-2">Particlize Self</button>
                    </div>
                </div>

                <!-- ========== PHYSICS TAB ========== -->
                <div id="tab-physics" class="tab-content space-y-3">
                    <h3 class="text-xs font-bold text-indigo-400">UNIFIED MASTER FORMULA (Œ®)</h3>

                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Gravitational Strength (U)</span>
                            <span id="val-ugrav" class="font-mono">0.55</span>
                        </div>
                        <input id="in-ugrav" type="range" min="0.0" max="4.0" step="0.01" value="0.55" />
                    </div>

                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Chaos Factor (Œª)</span>
                            <span id="val-lambda" class="font-mono">0.25</span>
                        </div>
                        <input id="in-lambda" type="range" min="0.0" max="2.0" step="0.01" value="0.25" />
                    </div>

                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Energy Scaling (Ec)</span>
                            <span id="val-ec" class="font-mono">1.2</span>
                        </div>
                        <input id="in-ec" type="range" min="0.2" max="4.0" step="0.1" value="1.2" />
                    </div>

                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Motion Damping (Œ∂)</span>
                            <span id="val-li" class="font-mono">0.985</span>
                        </div>
                        <input id="in-li" type="range" min="0.95" max="1.0" step="0.001" value="0.985" />
                    </div>

                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Spectral Hue (Œ©)</span>
                            <span id="val-omega" class="font-mono">0.62</span>
                        </div>
                        <input id="in-omega" type="range" min="0.0" max="1.0" step="0.01" value="0.62" />
                    </div>
                </div>

                <!-- ========== GRAPHICS TAB ========== -->
                <div id="tab-graphics" class="tab-content space-y-4 text-sm text-slate-300">
                    <div class="slider-container">
                        <label>View Mode</label>
                        <select id="view-mode-select" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 mt-1 text-sm border border-slate-600">
                            <option value="orbit">Orbit</option>
                            <option value="first-person">First Person</option>
                            <option value="enhanced-fp">Spaceship (3rd Person)</option>
                            <option value="cockpit-view">Spaceship (Cockpit)</option>
                            <option value="cinematic">Cinematic</option>
                        </select>
                    </div>

                    <div class="slider-container">
                        <label>Graphics Style</label>
                        <select id="quality-select" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 mt-1 text-sm border border-slate-600">
                            <option value="low">Low (Pixelated)</option>
                            <option value="medium" selected>Medium (Realistic)</option>
                            <option value="high">High (Realistic)</option>
                            <option value="ultra">Ultra (Realistic)</option>
                            <option value="anime">Anime (Cel-Shaded)</option>
                        </select>
                    </div>

                    <div class="slider-container">
                        <label>Color Filter</label>
                        <select id="filter-select" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 mt-1 text-sm border border-slate-600">
                            <option value="none">None</option>
                            <option value="cool">Cool</option>
                            <option value="warm">Warm</option>
                            <option value="nebula">Nebula</option>
                            <option value="monochrome">Monochrome</option>
                            <option value="vibralight">VibraLight</option>
                        </select>
                    </div>

                    <div class="slider-container">
                        <div class="slider-label"><span>Brightness</span><span id="brightness-value">1.0</span></div>
                        <input type="range" id="brightness-slider" min="0" max="2" value="1" step="0.05" class="w-full">
                    </div>

                    <div class="toggle-container">
                        <div class="toggle-label">
                            <span>Enable Ambient Audio</span>
                            <label class="switch">
                                <input type="checkbox" id="ambient-audio-toggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>

                    <div class="toggle-container">
                        <div class="toggle-label">
                            <span>Motion Blur</span>
                            <label class="switch">
                                <input type="checkbox" id="motion-blur-toggle" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>

                    <div class="slider-container">
                        <div class="slider-label"><span>Motion Blur Intensity</span><span id="motion-blur-value">0.85</span></div>
                        <input type="range" id="motion-blur-slider" min="0" max="1" value="0.85" step="0.01" class="w-full">
                    </div>

                    <div class="toggle-container">
                        <div class="toggle-label">
                            <span>Bloom Effect</span>
                            <label class="switch">
                                <input type="checkbox" id="bloom-toggle" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>

                    <div class="toggle-container">
                        <div class="toggle-label">
                            <span>Film Grain</span>
                            <label class="switch">
                                <input type="checkbox" id="film-toggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- ========== DATA LEDGER TAB ========== -->
                <div id="tab-data" class="tab-content space-y-2">
                    <h4 class="text-sm font-bold text-indigo-400">GENESIS SEED LOG (NFT Metadata)</h4>
                    <div id="genesis-log-content" class="text-sm font-mono text-slate-400 max-h-48 overflow-y-auto"></div>
                    <button id="download-ledger-button" class="btn w-full bg-green-600 hover:bg-green-500 mt-2">Download Ledger</button>
                </div>

                <!-- ========== TELEMETRY TAB ========== -->
                <div id="tab-telemetry" class="tab-content space-y-2">
                    <h4 class="text-sm font-bold text-indigo-400">LIVE CONVERSION LOG (Soul Dust Tokens)</h4>
                    <input id="telemetry-filter" class="w-full bg-slate-800 text-slate-200 rounded-md p-2 text-sm border border-slate-600" placeholder="Filter by type or token (e.g., SDT_INSTANTIATE)">
                    <div id="telemetry-log-content" class="text-xs font-mono text-slate-400 max-h-60 overflow-y-auto whitespace-pre-wrap"></div>
                    <button id="download-telemetry-button" class="btn w-full bg-cyan-600 hover:bg-cyan-500 mt-2">Download Telemetry</button>
                </div>

                <!-- ========== COGNITIVE CORE TAB ========== -->
                <div id="tab-cognitive" class="tab-content space-y-3 text-sm text-slate-300">
                    <h4 class="font-bold text-indigo-400">GENESIS INPUT STREAM (Bio-Vibrational Anchor)</h4>
                    <div id="seed-visualizer">
                        <div class="data-stream" data-stream="audio">Audio<div class="data-pulse"></div></div>
                        <div class="data-stream" data-stream="ml">ML<div class="data-pulse"></div></div>
                        <div class="data-stream" data-stream="loc">Location<div class="data-pulse"></div></div>
                        <div class="data-stream" data-stream="light">Light<div class="data-pulse"></div></div>
                        <div class="data-stream" data-stream="usgs">USGS<div class="data-pulse"></div></div>
                        <div class="data-stream" data-stream="apod">APOD<div class="data-pulse"></div></div>
                    </div>

                    <div class="p-2 bg-black/20 rounded-md">
                        <p class="font-mono text-xs text-indigo-400">AI INTENTION:</p>
                        <p id="ai-intention" class="font-mono text-xs text-slate-300 min-h-8">Awaiting sensory input...</p>
                    </div>

                    <div class="p-2 bg-black/20 rounded-md">
                        <p class="font-mono text-xs text-green-400">COSMIC ENERGY PULSE (Œ®_cluster)</p>
                        <p id="psi-pulse" class="font-mono text-xs text-slate-300 h-4">0.0 J</p>
                    </div>

                    <div class="p-2 bg-black/20 rounded-md">
                        <p class="font-mono text-xs text-red-400">BIO-FREQUENCY SCALE (ŒΩ_bio)</p>
                        <p id="bio-freq-display" class="font-mono text-xs text-slate-300 h-4">7.83 Hz (Schumann)</p>
                    </div>
                </div>

                <!-- ========== SURFACE TAB ========== -->
                <div id="tab-surface" class="tab-content space-y-3 text-sm text-slate-300">
                    <h4 class="font-bold text-indigo-400">SURFACE WORLD PARAMETERS</h4>

                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Terrain Amplitude</span>
                            <span id="val-terrain-amp" class="font-mono">50</span>
                        </div>
                        <input id="in-terrain-amp" type="range" min="10" max="200" step="5" value="50" />
                    </div>

                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Vegetation Density</span>
                            <span id="val-veg-density" class="font-mono">0.5</span>
                        </div>
                        <input id="in-veg-density" type="range" min="0.0" max="1.0" step="0.1" value="0.5" />
                    </div>

                    <div class="toggle-container">
                        <div class="toggle-label">
                            <span>Ocean Waves</span>
                            <label class="switch">
                                <input type="checkbox" id="ocean-waves-toggle" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>

                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Time of Day</span>
                            <span id="val-time-of-day" class="font-mono">12:00</span>
                        </div>
                        <input id="in-time-of-day" type="range" min="0" max="24" step="0.5" value="12" />
                    </div>

                    <button id="spawn-sentinels" class="btn w-full bg-amber-600 hover:bg-amber-500">Spawn Sentinels</button>
                    <button id="spawn-motes" class="btn w-full bg-teal-600 hover:bg-teal-500">Spawn Motes</button>
                </div>
            </div>
        </div>

        <!-- Log Panel (Bottom Left) -->
        <div id="log-panel" class="ui-element bottom-4 left-4 w-96 max-h-48 overflow-y-auto text-xs font-mono p-4 space-y-1"></div>
    </div>

    <!-- Psi Overlay (from earth.html) -->
    <div id="psi-overlay" class="ui-hidden">
        <h4>CST Œ® ‚Äî Live Terms</h4>
        <div class="psi-term">
            <span class="psi-term-label">c¬≤¬∑œÜ¬∑Ec:</span>
            <span class="psi-term-value" id="psi-term1">--</span>
        </div>
        <div class="psi-term">
            <span class="psi-term-label">Œª (audio):</span>
            <span class="psi-term-value" id="psi-term2">--</span>
        </div>
        <div class="psi-term">
            <span class="psi-term-label">Œ©¬∑Ec:</span>
            <span class="psi-term-value" id="psi-term3">--</span>
        </div>
        <div class="psi-term">
            <span class="psi-term-label">U_grav:</span>
            <span class="psi-term-value" id="psi-term4">--</span>
        </div>
        <div class="psi-term">
            <span class="psi-term-label">Œ£œÅ_sd:</span>
            <span class="psi-term-value" id="psi-term5">--</span>
        </div>
        <div class="psi-sum">
            <div class="psi-term">
                <span class="psi-term-label">œà (sum):</span>
                <span class="psi-term-value" id="psi-sum">--</span>
            </div>
        </div>
    </div>

    <!-- Surface HUD (from earth.html) -->
    <div id="surface-hud">
        <div class="font-mono text-xs grid grid-cols-2 gap-x-4">
            <span class="text-slate-400">Altitude:</span>
            <span id="surface-altitude" class="text-right">-- m</span>
            <span class="text-slate-400">Biome:</span>
            <span id="surface-biome" class="text-right">--</span>
            <span class="text-slate-400">Temperature:</span>
            <span id="surface-temp" class="text-right">-- ¬∞C</span>
        </div>
    </div>

<script type="module">
console.log("üåå Cosmic Genesis 12D CST v3 Engine ‚Äî Loading...");

// =====================================================================================
// THREE.JS IMPORTS
// =====================================================================================
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
import { Sky } from 'three/addons/objects/Sky.js';

// =====================================================================================
// GLOBAL CONSTANTS & CST v3 PARAMETERS
// =====================================================================================
const PHI = (1 + Math.sqrt(5)) / 2; // Golden ratio œÜ
const C_SPEED = 299792458; // Speed of light (m/s)
const PLANCK_H = 6.62607015e-34; // Planck's constant (J‚ãÖHz‚Åª¬π)
const SCHUMANN_FREQ = 7.83; // Schumann resonance (Hz)

// NASA API Key Configuration
window.NASA_API_KEY = 'HR3wqtsJJzDSspunonRbrFh515LIVf1hcXQ10O56';

// =====================================================================================
// UTILITY FUNCTIONS
// =====================================================================================

// Seedable PRNG (cyrb128 + sfc32)
function cyrb128(str) {
    let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
    for (let i = 0, k; i < str.length; i++) {
        k = str.charCodeAt(i);
        h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
        h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
        h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
        h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
    }
    h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
    h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
    h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
    h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
    return [(h1^h2^h3^h4)>>>0, (h2^h1)>>>0, (h3^h1)>>>0, (h4^h1)>>>0];
}

function sfc32(a, b, c, d) {
    return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
        let t = (a + b) | 0;
        a = b ^ b >>> 9;
        b = c + (c << 3) | 0;
        c = (c << 21 | c >>> 11);
        d = d + 1 | 0;
        t = t + d | 0;
        c = c + t | 0;
        return (t >>> 0) / 4294967296;
    }
}

// UUID generator wrapper
const generateUUID = () => typeof uuidv4 !== 'undefined' ? uuidv4() : THREE.MathUtils.generateUUID();

// Sound-to-light spectral mapping (freqToRgb)
function freqToRgb(frequency) {
    // Logarithmic frequency normalization (20 Hz - 20 kHz)
    const fMin = 20, fMax = 20000;
    const fLog = Math.log10(Math.max(fMin, Math.min(fMax, frequency)));
    const fMinLog = Math.log10(fMin), fMaxLog = Math.log10(fMax);
    const norm = (fLog - fMinLog) / (fMaxLog - fMinLog);

    // Map to visible wavelength (380-780nm)
    const lambda = 380 + norm * 400; // nm

    let r, g, b;
    if (lambda < 440) {
        r = -(lambda - 440) / (440 - 380);
        g = 0.0;
        b = 1.0;
    } else if (lambda < 490) {
        r = 0.0;
        g = (lambda - 440) / (490 - 440);
        b = 1.0;
    } else if (lambda < 510) {
        r = 0.0;
        g = 1.0;
        b = -(lambda - 510) / (510 - 490);
    } else if (lambda < 580) {
        r = (lambda - 510) / (580 - 510);
        g = 1.0;
        b = 0.0;
    } else if (lambda < 645) {
        r = 1.0;
        g = -(lambda - 645) / (645 - 580);
        b = 0.0;
    } else {
        r = 1.0;
        g = 0.0;
        b = 0.0;
    }

    // Golden ratio saturation scaling
    const saturation = 0.5 + 0.5 / PHI;
    r = r * saturation + (1 - saturation);
    g = g * saturation + (1 - saturation);
    b = b * saturation + (1 - saturation);

    return new THREE.Color(r, g, b);
}

// Black body temperature to RGB
function blackBodyToRGB(tempK) {
    const temp = tempK / 100;
    let r, g, b;

    if (temp <= 66) {
        r = 255;
        g = temp;
        g = 99.4708025861 * Math.log(g) - 161.1195681661;
        if (temp <= 19) {
            b = 0;
        } else {
            b = temp - 10;
            b = 138.5177312231 * Math.log(b) - 305.0447927307;
        }
    } else {
        r = temp - 60;
        r = 329.698727446 * Math.pow(r, -0.1332047592);
        g = temp - 60;
        g = 288.1221695283 * Math.pow(g, -0.0755148492);
        b = 255;
    }

    r = Math.max(0, Math.min(255, r)) / 255;
    g = Math.max(0, Math.min(255, g)) / 255;
    b = Math.max(0, Math.min(255, b)) / 255;

    return new THREE.Color(r, g, b);
}

// =====================================================================================
// 12D CST STATE INITIALIZATION HELPER
// FROM: CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 5.1
// =====================================================================================
/**
 * Initialize 12D CST state for an entity
 * @param {THREE.Object3D} entity - Entity to initialize
 * @param {string} type - Entity type: 'star' | 'planet' | 'blackhole' | 'soul_dust' | 'sentinel' | 'mote'
 * @param {Object} options - Additional options (mass, radius, velocity, audioSignature)
 */
function initialize12DState(entity, type, options = {}) {
    const { mass = 1.0, radius = 1.0, velocity = new THREE.Vector3(), audioSignature = null } = options;
    
    // Generate UUID if not exists
    if (!entity.userData.uuid) {
        entity.userData.uuid = generateUUID ? generateUUID() : `entity-${Date.now()}-${Math.random()}`;
    }
    
    // Initialize 12D state vectors
    entity.userData.h12 = new Float32Array(12); // 12D state vector
    entity.userData.x12 = new Float32Array(12); // Internal state
    entity.userData.m12 = new Float32Array(12); // Memory (EMA)
    entity.userData.memoryAlpha = 0.1; // EMA smoothing factor
    
    // Initialize h12 from position, velocity, and system state
    // Dimensions 0-2: Spatial Position (normalized)
    entity.userData.h12[0] = entity.position.x / 100;
    entity.userData.h12[1] = entity.position.y / 100;
    entity.userData.h12[2] = entity.position.z / 100;
    
    // Dimensions 3-5: Velocity
    entity.userData.h12[3] = velocity.x;
    entity.userData.h12[4] = velocity.y;
    entity.userData.h12[5] = velocity.z;
    
    // Dimension 6: Temporal Phase (age/maxAge, default 0 for new entities)
    entity.userData.h12[6] = 0;
    
    // Dimension 7: Audio Coupling (from audio signature or 0)
    entity.userData.h12[7] = audioSignature?.avgFreq ? audioSignature.avgFreq / 255 : 0;
    
    // Dimension 8: Chaos Factor (Œª from STATE)
    entity.userData.h12[8] = STATE.params.lambda;
    
    // Dimension 9: Spectral Hue (Œ© from STATE)
    entity.userData.h12[9] = STATE.params.omega;
    
    // Dimension 10: Energy Scale (Ec from STATE)
    entity.userData.h12[10] = STATE.params.Ec;
    
    // Dimension 11: Global Field (normalized œà, will be updated by CSTComputeEngine)
    entity.userData.h12[11] = 0;
    
    // Initialize x12 (internal state) same as h12 initially
    entity.userData.x12.set(entity.userData.h12);
    
    // Initialize m12 (memory) to zero
    entity.userData.m12.fill(0);
    
    // Set core properties
    entity.userData.type = type;
    entity.userData.createdAt = Date.now();
    entity.userData.mass = mass;
    entity.userData.radius = radius;
    entity.userData.velocity = velocity.clone ? velocity.clone() : new THREE.Vector3(velocity.x, velocity.y, velocity.z);
    entity.userData.connectivity = 0.0; // Œ©·µ¢ - will be computed by CSTComputeEngine
    
    // Audio signature
    entity.userData.audioSignature = audioSignature || {
        birthFreq: 0,
        spectralBucket: 0,
        amplitudeHistory: []
    };
    
    // ML similarity (for video detection)
    entity.userData.mlOverlap = [];
}

// UUID generator helper (if not already defined)
if (typeof generateUUID === 'undefined') {
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
}

// =====================================================================================
// POST-PROCESSING SHADERS
// FROM: INTEGRATION_PROMPT_PART2_ULTRA_DETAILED.md Section 2
// =====================================================================================

/**
 * Gravitational Lensing Shader - For black holes
 */
const GravitationalLensingShader = {
    uniforms: {
        tDiffuse: { value: null },
        blackHolePos: { value: new THREE.Vector2(0.5, 0.5) },
        strength: { value: 0.5 },
        radius: { value: 0.3 }
    },
    
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 blackHolePos;
        uniform float strength;
        uniform float radius;
        varying vec2 vUv;
        
        void main() {
            vec2 toCenter = vUv - blackHolePos;
            float dist = length(toCenter);
            
            // Schwarzschild metric approximation
            float lensing = 0.0;
            if (dist < radius && dist > 0.001) {
                lensing = strength / dist;
                lensing = clamp(lensing, 0.0, 0.5);
            }
            
            // Apply distortion
            vec2 distortedUv = vUv + normalize(toCenter) * lensing;
            
            // Sample with chromatic aberration near event horizon
            vec3 color;
            if (dist < radius * 0.5) {
                float offset = lensing * 0.01;
                color.r = texture2D(tDiffuse, distortedUv + vec2(offset, 0.0)).r;
                color.g = texture2D(tDiffuse, distortedUv).g;
                color.b = texture2D(tDiffuse, distortedUv - vec2(offset, 0.0)).b;
            } else {
                color = texture2D(tDiffuse, distortedUv).rgb;
            }
            
            // Darkening near event horizon
            float darkness = smoothstep(0.0, radius * 0.3, dist);
            color *= darkness;
            
            gl_FragColor = vec4(color, 1.0);
        }
    `
};

/**
 * Swirl Shader - For QEM mode
 */
const SwirlShader = {
    uniforms: {
        tDiffuse: { value: null },
        center: { value: new THREE.Vector2(0.5, 0.5) },
        radius: { value: 0.5 },
        angle: { value: 0.5 },
        time: { value: 0.0 }
    },
    
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 center;
        uniform float radius;
        uniform float angle;
        uniform float time;
        varying vec2 vUv;
        
        void main() {
            vec2 toCenter = vUv - center;
            float dist = length(toCenter);
            
            if (dist < radius) {
                float percent = (radius - dist) / radius;
                float theta = percent * percent * angle * 8.0 + time * 0.5;
                float s = sin(theta);
                float c = cos(theta);
                
                vec2 rotated = vec2(
                    toCenter.x * c - toCenter.y * s,
                    toCenter.x * s + toCenter.y * c
                );
                
                vec2 swirlUv = center + rotated;
                gl_FragColor = texture2D(tDiffuse, swirlUv);
            } else {
                gl_FragColor = texture2D(tDiffuse, vUv);
            }
        }
    `
};

/**
 * Toon Shader - For anime mode
 */
const ToonShader = {
    uniforms: {
        tDiffuse: { value: null },
        steps: { value: 4 },
        edge: { value: 0.3 }
    },
    
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float steps;
        uniform float edge;
        varying vec2 vUv;
        
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            
            // Quantize colors
            vec3 quantized;
            quantized.r = floor(color.r * steps + 0.5) / steps;
            quantized.g = floor(color.g * steps + 0.5) / steps;
            quantized.b = floor(color.b * steps + 0.5) / steps;
            
            // Edge detection (Sobel)
            vec2 texelSize = vec2(1.0) / vec2(textureSize(tDiffuse, 0));
            
            float s00 = dot(texture2D(tDiffuse, vUv + vec2(-texelSize.x, -texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
            float s10 = dot(texture2D(tDiffuse, vUv + vec2(0, -texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
            float s20 = dot(texture2D(tDiffuse, vUv + vec2(texelSize.x, -texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
            float s01 = dot(texture2D(tDiffuse, vUv + vec2(-texelSize.x, 0)).rgb, vec3(0.299, 0.587, 0.114));
            float s21 = dot(texture2D(tDiffuse, vUv + vec2(texelSize.x, 0)).rgb, vec3(0.299, 0.587, 0.114));
            float s02 = dot(texture2D(tDiffuse, vUv + vec2(-texelSize.x, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
            float s12 = dot(texture2D(tDiffuse, vUv + vec2(0, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
            float s22 = dot(texture2D(tDiffuse, vUv + vec2(texelSize.x, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
            
            float gx = s00 + 2.0*s10 + s20 - s02 - 2.0*s12 - s22;
            float gy = s00 + 2.0*s01 + s02 - s20 - 2.0*s21 - s22;
            
            float edgeMag = sqrt(gx*gx + gy*gy);
            
            if (edgeMag > edge) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // Black outline
            } else {
                gl_FragColor = vec4(quantized, 1.0);
            }
        }
    `
};

/**
 * Vignette Shader
 */
const VignetteShader = {
    uniforms: {
        tDiffuse: { value: null },
        offset: { value: 1.0 },
        darkness: { value: 1.0 }
    },
    
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float offset;
        uniform float darkness;
        varying vec2 vUv;
        
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            vec2 uv = (vUv - vec2(0.5)) * vec2(offset);
            float dist = length(uv);
            float vignette = smoothstep(0.8, 0.2, dist);
            color.rgb = mix(color.rgb, color.rgb * vignette, darkness);
            gl_FragColor = color;
        }
    `
};

/**
 * Pixelation Shader
 */
const PixelShader = {
    uniforms: {
        tDiffuse: { value: null },
        resolution: { value: new THREE.Vector2(1, 1) },
        pixelSize: { value: 4.0 }
    },
    
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        varying vec2 vUv;
        
        void main() {
            vec2 dxy = pixelSize / resolution;
            vec2 coord = dxy * floor(vUv / dxy);
            gl_FragColor = texture2D(tDiffuse, coord);
        }
    `
};

/**
 * Godrays Shader - For massive bodies
 */
const GodraysShader = {
    uniforms: {
        tDiffuse: { value: null },
        lightPos: { value: new THREE.Vector2(0.5, 0.5) },
        exposure: { value: 0.6 },
        decay: { value: 0.93 },
        density: { value: 0.96 },
        weight: { value: 0.4 },
        samples: { value: 50.0 }
    },
    
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 lightPos;
        uniform float exposure;
        uniform float decay;
        uniform float density;
        uniform float weight;
        uniform float samples;
        varying vec2 vUv;
        
        void main() {
            vec2 deltaTextCoord = vUv - lightPos;
            deltaTextCoord *= 1.0 / samples * density;
            float illuminationDecay = 1.0;
            vec4 color = texture2D(tDiffuse, vUv);
            vec2 coord = vUv;
            
            for (float i = 0.0; i < samples; i++) {
                coord -= deltaTextCoord;
                vec4 sample = texture2D(tDiffuse, coord);
                sample *= illuminationDecay * weight;
                color += sample;
                illuminationDecay *= decay;
            }
            
            gl_FragColor = color * exposure;
        }
    `
};

// =====================================================================================
// CENTRALIZED STATE MANAGEMENT
// =====================================================================================
/**
 * Global application state object following 12D CST v3 specifications
 * FROM: CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 2.2
 */
const STATE = {
    // Mode Management
    currentMode: 'universe', // 'universe' | 'surface' | 'echo'
    
    // Simulation Parameters
    params: {
        Ec: 1.2,        // Energy scaling
        lambda: 0.25,   // Chaos factor
        zeta: 0.985,    // Motion damping
        omega: 0.62,    // Spectral hue
        U_grav: 0.55,   // Gravitational strength
        phi: 1.618033988749895 // Golden ratio
    },
    
    // Sensor Readings
    sensors: {
        audio: {
            avgFreq: 0,
            spectralBands: new Array(8).fill(0),
            energy: 0,
            waveform: [],
            lastUpdate: null
        },
        video: {
            detections: [],
            streamActive: false,
            lastFrameTime: null
        },
        geolocation: {
            lat: null,
            lon: null,
            accuracy: null,
            lastUpdate: null
        },
        ambientLight: {
            lux: null,
            lastUpdate: null
        }
    },
    
    // External Data
    external: {
        usgs: { earthquakes: [], lastUpdated: null },
        nasa: { apod: null, neo: [], lastUpdated: null },
        donki: { events: [], lastUpdated: null },
        keys: { nasa: null }
    },
    
    // Theory State (12D CST)
    cst: {
        h12: new Array(12).fill(0),  // 12D state vector
        x12: new Array(12).fill(0),  // Internal state
        m12: new Array(12).fill(0),  // Memory (EMA)
        connectivity: 0,              // Œ©·µ¢
        psi: 0,                       // œà sum
        term1_Ec: 0,                  // c¬≤¬∑œÜ¬∑Ec
        term2_lambda: 0,              // Œª¬∑audio
        term3_omega: 0,               // Œ©¬∑Ec
        term4_Ugrav: 0,               // U_grav
        term5_rho: 0,                 // Œ£œÅ_sd
        psi_history: []               // Last 100 œà values
    },
    
    // AI State
    ai: {
        seed: null,
        intention: '',
        futureEvents: [],
        bias: { exploration: 0.5, harmony: 0.5 }
    },
    
    // Runtime
    runtime: {
        fps: 0,
        frameCount: 0,
        deltaTime: 0,
        objectCount: 0,
        totalTime: 0
    },
    
    // UI State
    ui: {
        visible: true,
        activeTab: 'controls',
        devMode: false,
        psiOverlayVisible: false,
        surfaceHUDVisible: false
    },
    
    // Flags
    flags: {
        enablePostProcessing: true,
        enableSensors: true,
        enableExternalData: true
    }
};

// =====================================================================================
// EVENT BUS - Pub/Sub Architecture with Channel Management
// FROM: DARkcosmo.HTML + INTEGRATION_PROMPT_PART2_ULTRA_DETAILED.md
// Enhanced with priority handling and debug mode
// =====================================================================================
class EventBus {
    constructor() {
        this.channels = new Map(); // Channel -> Array of {callback, priority}
        this.history = []; // Event history buffer (last 100 events)
        this.maxHistory = 100;
        this.debugMode = false;
    }

    /**
     * Subscribe to a channel with optional priority
     * @param {string} channel - Channel name (supports wildcards like "ui:*")
     * @param {Function} callback - Callback function
     * @param {number} priority - Priority (higher = called first, default 0)
     * @returns {Function} Unsubscribe function
     */
    subscribe(channel, callback, priority = 0) {
        if (!this.channels.has(channel)) {
            this.channels.set(channel, []);
        }
        const subscribers = this.channels.get(channel);
        subscribers.push({ callback, priority });
        // Sort by priority (descending)
        subscribers.sort((a, b) => b.priority - a.priority);
        
        if (this.debugMode) {
            console.log(`[EventBus] Subscribed to "${channel}" with priority ${priority}`);
        }
        
        return () => this.unsubscribe(channel, callback);
    }

    /**
     * Alias for subscribe (for compatibility)
     */
    on(channel, callback, priority = 0) {
        return this.subscribe(channel, callback, priority);
    }

    /**
     * Unsubscribe from a channel
     */
    unsubscribe(channel, callback) {
        if (this.channels.has(channel)) {
            const subscribers = this.channels.get(channel);
            const index = subscribers.findIndex(sub => sub.callback === callback);
            if (index > -1) {
                subscribers.splice(index, 1);
                if (this.debugMode) {
                    console.log(`[EventBus] Unsubscribed from "${channel}"`);
                }
            }
        }
    }

    /**
     * Alias for unsubscribe
     */
    off(channel, callback) {
        this.unsubscribe(channel, callback);
    }

    /**
     * Publish an event to a channel
     * @param {string} channel - Channel name
     * @param {*} data - Event data
     */
    publish(channel, data) {
        // Record event in history
        this.history.push({ channel, data, timestamp: Date.now() });
        if (this.history.length > this.maxHistory) {
            this.history.shift();
        }

        if (this.debugMode) {
            console.log(`[EventBus] Publishing to "${channel}":`, data);
        }

        // Handle wildcard subscriptions (e.g., "ui:*" matches "ui:update")
        const parts = channel.split(':');
        for (let i = parts.length; i > 0; i--) {
            const pattern = parts.slice(0, i).join(':') + (i < parts.length ? ':*' : '');
            if (this.channels.has(pattern)) {
                this.channels.get(pattern).forEach(({ callback }) => {
                    try {
                        callback(data, channel);
                    } catch (e) {
                        console.error(`[EventBus] Error on channel "${channel}" (pattern "${pattern}"):`, e);
                    }
                });
            }
        }

        // Exact channel match
        if (this.channels.has(channel)) {
            this.channels.get(channel).forEach(({ callback }) => {
                try {
                    callback(data);
                } catch (e) {
                    console.error(`[EventBus] Error on channel "${channel}":`, e);
                }
            });
        }
    }

    /**
     * Alias for publish
     */
    emit(channel, data) {
        this.publish(channel, data);
    }

    /**
     * Subscribe to a channel for a single event
     */
    once(channel, callback, priority = 0) {
        const wrapper = (data) => {
            callback(data);
            this.unsubscribe(channel, wrapper);
        };
        return this.subscribe(channel, wrapper, priority);
    }

    /**
     * Clear all subscribers from a channel
     */
    clear(channel) {
        if (channel) {
            this.channels.delete(channel);
        } else {
            this.channels.clear();
        }
    }

    /**
     * Get event history
     * @param {string|null} channel - Filter by channel (optional)
     * @param {number} limit - Maximum number of events to return
     * @returns {Array} Event history
     */
    getHistory(channel = null, limit = 100) {
        let history = this.history;
        if (channel) {
            history = history.filter(evt => evt.channel === channel || evt.channel.startsWith(channel + ':'));
        }
        return history.slice(-limit);
    }

    /**
     * Enable debug logging
     */
    enableDebug() {
        this.debugMode = true;
        console.log('[EventBus] Debug mode enabled');
    }

    /**
     * Disable debug logging
     */
    disableDebug() {
        this.debugMode = false;
    }
}

// =====================================================================================
// DATA LOGGER - Dual-Channel Logging (Genesis Ledger + Live Telemetry)
// FROM: DARkcosmo.HTML + INTEGRATION_PROMPT_PART2_ULTRA_DETAILED.md
// Enhanced with filtering capabilities and export functions
// =====================================================================================
class DataLogger {
    constructor(eventBus) {
        this.eventBus = eventBus;
        this.genesisLog = []; // NFT-style genesis seed log (ledger)
        this.telemetryLog = []; // Live telemetry stream
        this.maxTelemetryEntries = 1000;
        
        // Filter configuration
        this.filters = {
            ledger: { 
                level: 'all', // 'all' | 'info' | 'warn' | 'error' | 'event'
                categories: [] // Empty = all categories
            },
            telemetry: { 
                channels: [], // Empty = all channels
                timeRange: null, // { start: timestamp, end: timestamp } or null
                types: [] // Empty = all types
            }
        };

        // Subscribe to logging events
        this.eventBus.subscribe('logger:ledger', (data) => this.addToLedger(data));
        this.eventBus.subscribe('telemetry:append', (data) => this.addTelemetry(data));
    }

    /**
     * Add entry to ledger (human-readable narrative log)
     * @param {string} level - Log level: 'info' | 'warn' | 'error' | 'event'
     * @param {string} category - Category: 'System' | 'AI' | 'PGE' | 'QEM' | etc.
     * @param {string} message - Log message
     * @param {Object} metadata - Additional metadata
     */
    logLedger(level, category, message, metadata = {}) {
        const entry = {
            timestamp: Date.now(),
            level,
            category,
            message,
            ...metadata
        };
        this.genesisLog.push(entry);
        this.updateLedgerUI();
    }

    /**
     * Legacy method for backward compatibility
     */
    addToLedger(entry) {
        if (typeof entry === 'string') {
            this.logLedger('info', 'System', entry);
        } else {
        this.genesisLog.push({
            timestamp: Date.now(),
            ...entry
        });
        this.updateLedgerUI();
        }
    }

    /**
     * Add entry to telemetry (machine-readable data stream)
     * @param {string} channel - Telemetry channel
     * @param {Object} data - Telemetry data
     * @param {number} timestamp - Optional timestamp (defaults to now)
     */
    logTelemetry(channel, data, timestamp = Date.now()) {
        const entry = {
            timestamp,
            channel,
            ...data
        };
        this.telemetryLog.push(entry);
        if (this.telemetryLog.length > this.maxTelemetryEntries) {
            this.telemetryLog.shift();
        }
        this.updateTelemetryUI();
    }

    /**
     * Legacy method for backward compatibility
     */
    addTelemetry(entry) {
        this.logTelemetry(entry.channel || 'default', entry, entry.timestamp || Date.now());
    }

    /**
     * Apply filter configuration
     * @param {string} type - 'ledger' | 'telemetry'
     * @param {Object} filterConfig - Filter configuration
     */
    applyFilter(type, filterConfig) {
        if (type === 'ledger' && filterConfig) {
            if (filterConfig.level) this.filters.ledger.level = filterConfig.level;
            if (filterConfig.categories) this.filters.ledger.categories = filterConfig.categories;
            this.updateLedgerUI();
        } else if (type === 'telemetry' && filterConfig) {
            if (filterConfig.channels) this.filters.telemetry.channels = filterConfig.channels;
            if (filterConfig.timeRange) this.filters.telemetry.timeRange = filterConfig.timeRange;
            if (filterConfig.types) this.filters.telemetry.types = filterConfig.types;
            this.updateTelemetryUI();
        }
    }

    /**
     * Get filtered ledger entries
     */
    getFilteredLedger() {
        let filtered = this.genesisLog;
        
        // Filter by level
        if (this.filters.ledger.level !== 'all') {
            filtered = filtered.filter(entry => entry.level === this.filters.ledger.level);
        }
        
        // Filter by categories
        if (this.filters.ledger.categories.length > 0) {
            filtered = filtered.filter(entry => 
                this.filters.ledger.categories.includes(entry.category)
            );
        }
        
        return filtered;
    }

    /**
     * Get filtered telemetry entries
     */
    getFilteredTelemetry() {
        let filtered = this.telemetryLog;
        
        // Filter by channels
        if (this.filters.telemetry.channels.length > 0) {
            filtered = filtered.filter(entry => 
                this.filters.telemetry.channels.includes(entry.channel)
            );
        }
        
        // Filter by time range
        if (this.filters.telemetry.timeRange) {
            const { start, end } = this.filters.telemetry.timeRange;
            filtered = filtered.filter(entry => {
                if (start && entry.timestamp < start) return false;
                if (end && entry.timestamp > end) return false;
                return true;
            });
        }
        
        // Filter by types
        if (this.filters.telemetry.types.length > 0) {
            filtered = filtered.filter(entry => 
                this.filters.telemetry.types.includes(entry.type)
            );
        }
        
        return filtered;
    }

    updateLedgerUI() {
        const container = document.getElementById('genesis-log-content');
        if (!container) return;

        const filtered = this.getFilteredLedger();
        const recent = filtered.slice(-10).reverse();
        
        container.innerHTML = recent.map(entry => {
            const levelColor = {
                'info': '#4f46e5',
                'warn': '#f59e0b',
                'error': '#ef4444',
                'event': '#10b981'
            }[entry.level] || '#4f46e5';
            
            return `<div style="margin-bottom:4px; padding:4px; background:rgba(255,255,255,0.02); border-left:2px solid ${levelColor};">
                <span style="color:#94a3b8;">${new Date(entry.timestamp).toLocaleTimeString()}</span>
                <span style="color:${levelColor};">[${entry.level?.toUpperCase() || 'INFO'}]</span>
                <span style="color:#e2e8f0;">${entry.message || JSON.stringify(entry)}</span>
            </div>`;
        }).join('');
    }

    updateTelemetryUI() {
        const container = document.getElementById('telemetry-log-content');
        const filterInput = document.getElementById('telemetry-filter');
        if (!container) return;

        // Get text filter from input
        const filterText = filterInput?.value?.toLowerCase() || '';
        
        // Get filtered telemetry
        let filtered = this.getFilteredTelemetry();
        
        // Apply text filter
        if (filterText) {
            filtered = filtered.filter(entry => {
            const str = JSON.stringify(entry).toLowerCase();
            return str.includes(filterText);
        });
        }

        const recent = filtered.slice(-20).reverse();
        container.textContent = recent.map(entry => {
            return `[${new Date(entry.timestamp).toLocaleTimeString()}] ${entry.channel || 'default'}: ${JSON.stringify(entry.tokens || entry.data || entry)}`;
        }).join('\n');
    }

    /**
     * Export ledger as JSON
     */
    exportJSON(type = 'both') {
        const data = {};
        if (type === 'ledger' || type === 'both') {
            data.ledger = this.getFilteredLedger();
        }
        if (type === 'telemetry' || type === 'both') {
            data.telemetry = this.getFilteredTelemetry();
        }
        return JSON.stringify(data, null, 2);
    }

    downloadLedger() {
        const data = this.exportJSON('ledger');
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `genesis-ledger-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    downloadTelemetry() {
        const data = this.exportJSON('telemetry');
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `telemetry-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }
}

// =====================================================================================
// UI MANAGER - Tab System and Control Bindings
// =====================================================================================
class UIManager {
    constructor(eventBus) {
        this.eventBus = eventBus;
        this.activeTab = 'controls';

        // Initialize tabs
        this.initTabs();

        // Initialize control bindings
        this.initControlBindings();

        // Initialize sliders
        this.initSliders();
    }

    initTabs() {
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabName = button.getAttribute('data-tab');

                // Update active tab
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));

                button.classList.add('active');
                const targetContent = document.getElementById(`tab-${tabName}`);
                if (targetContent) targetContent.classList.add('active');

                this.activeTab = tabName;
            });
        });
    }

    initControlBindings() {
        // Session controls
        const regenerateBtn = document.getElementById('regenerate-button');
        if (regenerateBtn) {
            regenerateBtn.addEventListener('click', () => {
                this.eventBus.publish('ui:regenerate', {});
                this.log('Regenerating universe...', 'info');
            });
        }

        // Mode selection
        const modeButtons = {
            'mode-universe': 'universe',
            'mode-surface': 'surface',
            'mode-echo': 'echo'
        };

        Object.entries(modeButtons).forEach(([id, mode]) => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.addEventListener('click', () => {
                    _applyMode(mode, {
                        pge: this.pge,
                        qem: this.qem,
                        surfaceManager: this.surfaceManager,
                        audioReactive: this.audioReactive,
                        memoryEchoEngine: this.memoryEchoEngine,
                        eventBus: this.eventBus,
                        dataLogger: this.dataLogger
                    });
                    
                    // Update surface HUD visibility
                    const surfaceHud = document.getElementById('surface-hud');
                    if (surfaceHud) {
                        if (mode === 'surface') {
                            surfaceHud.classList.add('active');
                            STATE.ui.surfaceHUDVisible = true;
                        } else {
                            surfaceHud.classList.remove('active');
                            STATE.ui.surfaceHUDVisible = false;
                        }
                    }
                    this.log(`Switched to ${mode} mode`, 'info');
                });
            }
        });

        // View mode select
        const viewModeSelect = document.getElementById('view-mode-select');
        if (viewModeSelect) {
            viewModeSelect.addEventListener('change', (e) => {
                this.eventBus.publish('ui:viewMode', e.target.value);
            });
        }

        // Graphics quality select
        const qualitySelect = document.getElementById('quality-select');
        if (qualitySelect) {
            qualitySelect.addEventListener('change', (e) => {
                this.eventBus.publish('ui:quality', e.target.value);
            });
        }

        // Color filter select
        const filterSelect = document.getElementById('filter-select');
        if (filterSelect) {
            filterSelect.addEventListener('change', (e) => {
                this.eventBus.publish('ui:filter', e.target.value);
            });
        }

        // Audio toggle
        const toggleAudio = document.getElementById('toggle-audio');
        if (toggleAudio) {
            toggleAudio.addEventListener('change', (e) => {
                this.eventBus.publish('ui:toggleAudio', e.target.checked);
            });
        }

        // UI toggle button
        const toggleUIBtn = document.getElementById('toggle-ui-button');
        const uiContainer = document.getElementById('ui-container');
        if (toggleUIBtn && uiContainer) {
            toggleUIBtn.addEventListener('click', () => {
                uiContainer.classList.toggle('ui-hidden');
                STATE.ui.visible = !uiContainer.classList.contains('ui-hidden');
            });
        }
        
        // PSI overlay toggle button
        const btnPsiHUD = document.getElementById('btnPsiHUD');
        if (btnPsiHUD) {
            btnPsiHUD.addEventListener('click', () => {
                this.togglePsiOverlay();
            });
        }
        
        // Subscribe to UI pulse events for seed visualizer
        this.eventBus.subscribe('ui:pulse', (channel) => {
            this.pulseDot(channel);
        });
        
        // Subscribe to UI toggle hotkey
        this.eventBus.subscribe('ui:toggle', () => {
            if (uiContainer) {
                uiContainer.classList.toggle('ui-hidden');
                STATE.ui.visible = !uiContainer.classList.contains('ui-hidden');
            }
        });
        
        // Spawn Sentinels button
        const spawnSentinelsBtn = document.getElementById('spawn-sentinels');
        if (spawnSentinelsBtn) {
            spawnSentinelsBtn.addEventListener('click', () => {
                this.eventBus.publish('surface:spawnSentinels', { count: 5 });
            });
        }
        
        // Spawn Motes button
        const spawnMotesBtn = document.getElementById('spawn-motes');
        if (spawnMotesBtn) {
            spawnMotesBtn.addEventListener('click', () => {
                this.eventBus.publish('surface:spawnMotes', { count: 20 });
            });
        }
    }

    initSliders() {
        const sliders = [
            { id: 'in-ugrav', valId: 'val-ugrav', event: 'physics:ugrav' },
            { id: 'in-lambda', valId: 'val-lambda', event: 'physics:lambda' },
            { id: 'in-ec', valId: 'val-ec', event: 'physics:ec' },
            { id: 'in-li', valId: 'val-li', event: 'physics:damping' },
            { id: 'in-omega', valId: 'val-omega', event: 'physics:omega' },
            { id: 'brightness-slider', valId: 'brightness-value', event: 'graphics:brightness' },
            { id: 'motion-blur-slider', valId: 'motion-blur-value', event: 'graphics:motionBlur' }
        ];

        sliders.forEach(({ id, valId, event }) => {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(valId);
            if (slider && valueDisplay) {
                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    valueDisplay.textContent = value.toFixed(2);
                    this.eventBus.publish(event, value);
                });
            }
        });
    }

    log(message, type = 'info') {
        const logPanel = document.getElementById('log-panel');
        if (!logPanel) return;

        const colors = {
            info: '#3b82f6',
            success: '#10b981',
            warn: '#f59e0b',
            error: '#ef4444',
            data: '#8b5cf6'
        };

        const entry = document.createElement('div');
        entry.style.color = colors[type] || colors.info;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;

        logPanel.appendChild(entry);

        // Keep only last 50 entries
        while (logPanel.children.length > 50) {
            logPanel.removeChild(logPanel.firstChild);
        }

        // Auto-scroll to bottom
        logPanel.scrollTop = logPanel.scrollHeight;
    }

    updateStatus(status) {
        const statusReadout = document.getElementById('system-status-readout');
        if (statusReadout) {
            statusReadout.textContent = `STATUS: ${status.toUpperCase()}`;
        }
    }

    /**
     * Update UI with current STATE
     * FROM: INTEGRATION_PROMPT_PART2_ULTRA_DETAILED.md Section 1.2
     */
    update(STATE) {
        // Update HUD elements
        const hudFps = document.getElementById('hudFps');
        if (hudFps) hudFps.textContent = STATE.runtime.fps || '--';
        
        const hudChaos = document.getElementById('hudChaos');
        if (hudChaos) hudChaos.textContent = STATE.params.lambda.toFixed(2);
        
        const hudObjects = document.getElementById('hudObjects');
        if (hudObjects) hudObjects.textContent = STATE.runtime.objectCount;
        
        const hudLOD = document.getElementById('hudLOD');
        if (hudLOD) hudLOD.textContent = STATE.currentMode;
        
        // Update PSI overlay if visible
        if (STATE.ui.psiOverlayVisible) {
            this.updatePsiOverlay(STATE);
        }
        
        // Update surface HUD if in surface mode
        if (STATE.currentMode === 'surface' && STATE.ui.surfaceHUDVisible) {
            // Will be updated by SurfaceManager
        }
    }

    /**
     * Update FPS display
     */
    updateFPS(fps) {
        const hudFps = document.getElementById('hudFps');
        if (hudFps) hudFps.textContent = fps;
    }

    /**
     * Update PSI overlay with live CST values
     * FROM: INTEGRATION_PROMPT_PART2_ULTRA_DETAILED.md Section 1.2
     */
    updatePsiOverlay(STATE) {
        const { term1_Ec, term2_lambda, term3_omega, term4_Ugrav, term5_rho, psi } = STATE.cst;
        
        const term1El = document.getElementById('psi-term1');
        if (term1El) term1El.textContent = this.formatScientific(term1_Ec);
        
        const term2El = document.getElementById('psi-term2');
        if (term2El) term2El.textContent = term2_lambda.toFixed(2);
        
        const term3El = document.getElementById('psi-term3');
        if (term3El) term3El.textContent = term3_omega.toFixed(3);
        
        const term4El = document.getElementById('psi-term4');
        if (term4El) term4El.textContent = this.formatScientific(term4_Ugrav);
        
        const term5El = document.getElementById('psi-term5');
        if (term5El) term5El.textContent = term5_rho.toFixed(3);
        
        const sumEl = document.getElementById('psi-sum');
        if (sumEl) sumEl.textContent = this.formatScientific(psi);
    }

    /**
     * Format number in scientific notation if needed
     */
    formatScientific(num) {
        if (Math.abs(num) < 1000 && Math.abs(num) > 0.01) return num.toFixed(2);
        return num.toExponential(2);
    }

    /**
     * Pulse a data stream dot in seed visualizer
     */
    pulseDot(channel) {
        const visualizer = document.getElementById('seed-visualizer');
        if (!visualizer) return;
        
        const streamEl = visualizer.querySelector(`[data-stream="${channel}"]`);
        if (!streamEl) return;
        
        const dot = streamEl.querySelector('.data-pulse');
        if (!dot) return;
        
        dot.style.backgroundColor = '#38bdf8';
        dot.style.animation = 'pulse-glow 0.6s ease';
        
        setTimeout(() => {
            dot.style.backgroundColor = '#334155';
            dot.style.animation = '';
        }, 600);
    }

    /**
     * Toggle PSI overlay visibility
     */
    togglePsiOverlay() {
        STATE.ui.psiOverlayVisible = !STATE.ui.psiOverlayVisible;
        const overlay = document.getElementById('psi-overlay');
        if (overlay) {
            if (STATE.ui.psiOverlayVisible) {
                overlay.classList.remove('ui-hidden');
            } else {
                overlay.classList.add('ui-hidden');
            }
        }
    }
}

// =====================================================================================
// INPUT CONTROLLER
// FROM: INTEGRATION_PROMPT_PART2_ULTRA_DETAILED.md Section 1.1
// =====================================================================================
/**
 * InputController - Handle all user input (keyboard, mouse, touch, gamepad)
 * Supports orbit, spaceship, and FPS camera modes
 */
class InputController {
    constructor(camera, domElement, eventBus, STATE) {
        this.camera = camera;
        this.domElement = domElement;
        this.eventBus = eventBus;
        this.STATE = STATE;
        
        // Mode: 'orbit' | 'spaceship' | 'fps'
        this.mode = 'orbit';
        
        // Orbit controls (will be set by init)
        this.orbitControls = null;
        
        // First-person/spaceship controls
        this.moveSpeed = 50;
        this.sprintMultiplier = 2.5;
        this.lookSpeed = 0.002;
        this.rollSpeed = 0.5;
        
        // Input state
        this.keys = {};
        this.mouse = { x: 0, y: 0, deltaX: 0, deltaY: 0, buttons: 0 };
        this.pointerLocked = false;
        
        // Surface physics
        this.velocity = new THREE.Vector3();
        this.onGround = false;
        this.gravity = -9.8;
        this.jumpForce = 50;
        this.surfacePhysicsEnabled = false;
        
        // Camera shake
        this.shakeIntensity = 0;
        this.shakeDecay = 0.95;
        
        // Subscribe to camera shake events
        this.eventBus.subscribe('camera:shake', (data) => {
            this.shake(data.intensity || 0.5);
        });
        
        this.initEventListeners();
    }
    
    init(orbitControls) {
        // Initialize OrbitControls for orbit mode
        this.orbitControls = orbitControls;
        this.setMode('orbit');
    }
    
    initEventListeners() {
        // Keyboard
        window.addEventListener('keydown', (e) => this.onKeyDown(e));
        window.addEventListener('keyup', (e) => this.onKeyUp(e));
        
        // Mouse
        this.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.domElement.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.domElement.addEventListener('wheel', (e) => this.onWheel(e));
        
        // Pointer lock (for FPS mode)
        this.domElement.addEventListener('click', () => {
            if (this.mode === 'fps' || this.mode === 'spaceship') {
                this.domElement.requestPointerLock();
            }
        });
        
        document.addEventListener('pointerlockchange', () => {
            this.pointerLocked = document.pointerLockElement === this.domElement;
        });
        
        document.addEventListener('pointerlockerror', () => {
            console.error('Pointer lock error');
        });
        
        // Touch (mobile support)
        this.domElement.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
        this.domElement.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
        this.domElement.addEventListener('touchend', (e) => this.onTouchEnd(e));
    }
    
    onKeyDown(e) {
        this.keys[e.key.toLowerCase()] = true;
        
        // Hotkeys are handled in Application class
    }
    
    onKeyUp(e) {
        this.keys[e.key.toLowerCase()] = false;
    }
    
    onMouseDown(e) {
        this.mouse.buttons = e.buttons;
    }
    
    onMouseMove(e) {
        if (this.pointerLocked) {
            this.mouse.deltaX = e.movementX || 0;
            this.mouse.deltaY = e.movementY || 0;
        } else {
            this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        }
    }
    
    onMouseUp(e) {
        this.mouse.buttons = e.buttons;
    }
    
    onWheel(e) {
        if (this.mode === 'orbit' && this.orbitControls) {
            // OrbitControls handles this
        } else {
            // Zoom in/out
            this.moveSpeed = Math.max(10, Math.min(500, this.moveSpeed + e.deltaY * 0.1));
        }
    }
    
    onTouchStart(e) {
        e.preventDefault();
        // Touch controls for mobile (simplified)
    }
    
    onTouchMove(e) {
        e.preventDefault();
        // Touch controls for mobile (simplified)
    }
    
    onTouchEnd(e) {
        // Reset touch state
    }
    
    setMode(mode) {
        this.mode = mode;
        
        if (mode === 'orbit') {
            if (this.orbitControls) this.orbitControls.enabled = true;
            document.exitPointerLock();
        } else {
            if (this.orbitControls) this.orbitControls.enabled = false;
            // Pointer lock will be requested on click
        }
        
        this.eventBus.publish('input:mode_changed', { mode });
    }
    
    enableSurfacePhysics(enabled) {
        this.surfacePhysicsEnabled = enabled;
    }
    
    update(deltaTime) {
        // Update OrbitControls
        if (this.mode === 'orbit' && this.orbitControls) {
            this.orbitControls.update();
        }
        
        // Update FPS/Spaceship controls
        if ((this.mode === 'fps' || this.mode === 'spaceship') && this.pointerLocked) {
            this.updateFirstPersonControls(deltaTime);
        }
        
        // Camera shake
        if (this.shakeIntensity > 0.01) {
            const shake = new THREE.Vector3(
                (Math.random() - 0.5) * this.shakeIntensity,
                (Math.random() - 0.5) * this.shakeIntensity,
                (Math.random() - 0.5) * this.shakeIntensity
            );
            this.camera.position.add(shake);
            this.shakeIntensity *= this.shakeDecay;
        }
    }
    
    updateFirstPersonControls(deltaTime) {
        // Look (mouse)
        if (this.mouse.deltaX !== 0 || this.mouse.deltaY !== 0) {
            this.camera.rotation.y -= this.mouse.deltaX * this.lookSpeed;
            this.camera.rotation.x -= this.mouse.deltaY * this.lookSpeed;
            
            // Clamp vertical rotation
            this.camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.camera.rotation.x));
            
            this.mouse.deltaX = 0;
            this.mouse.deltaY = 0;
        }
        
        // Movement direction
        const direction = new THREE.Vector3();
        const forward = new THREE.Vector3(0, 0, -1).applyEuler(this.camera.rotation);
        const right = new THREE.Vector3(1, 0, 0).applyEuler(this.camera.rotation);
        
        // WASD movement
        let speed = this.moveSpeed;
        if (this.keys['shift']) speed *= this.sprintMultiplier;
        
        if (this.keys['w']) direction.add(forward);
        if (this.keys['s']) direction.sub(forward);
        if (this.keys['a']) direction.sub(right);
        if (this.keys['d']) direction.add(right);
        
        // Q/E vertical movement (spaceship) or jump (FPS)
        if (this.mode === 'spaceship') {
            if (this.keys['q']) direction.y -= 1;
            if (this.keys['e']) direction.y += 1;
        } else if (this.mode === 'fps') {
            if (this.keys[' '] && this.onGround) {
                this.velocity.y = this.jumpForce;
                this.onGround = false;
            }
        }
        
        // R/F roll (spaceship only)
        if (this.mode === 'spaceship') {
            if (this.keys['r']) this.camera.rotation.z += this.rollSpeed * deltaTime;
            if (this.keys['f']) this.camera.rotation.z -= this.rollSpeed * deltaTime;
        }
        
        // Apply movement
        if (direction.length() > 0) {
            direction.normalize().multiplyScalar(speed * deltaTime);
            
            if (this.surfacePhysicsEnabled && this.mode === 'fps') {
                // Surface physics (with collision)
                this.velocity.x = direction.x;
                this.velocity.z = direction.z;
                this.velocity.y += this.gravity * deltaTime;
                
                this.camera.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Check ground collision (simplified - would use SurfaceManager in full implementation)
                const groundHeight = this.getGroundHeight(this.camera.position.x, this.camera.position.z);
                if (this.camera.position.y <= groundHeight + 5) {
                    this.camera.position.y = groundHeight + 5;
                    this.velocity.y = 0;
                    this.onGround = true;
                }
            } else {
                // Free flight (spaceship)
                this.camera.position.add(direction);
            }
        }
    }
    
    getGroundHeight(x, z) {
        // Raycast to terrain (simplified)
        // In full implementation, this would raycast to SurfaceManager.terrain
        return 0;
    }
    
    applyViewPreset(preset) {
        const presets = {
            1: { pos: [0, 200, 1000], lookAt: [0, 0, 0] },      // Galaxy overview
            2: { pos: [0, 500, 0], lookAt: [0, 0, 0] },        // Top-down
            3: { pos: [1000, 100, 0], lookAt: [0, 0, 0] },     // Side view
            4: { pos: [500, 500, 500], lookAt: [0, 0, 0] },    // Isometric
            5: { pos: [0, 0, 2000], lookAt: [0, 0, 0] },       // Front view
            6: { pos: [0, 1000, 1000], lookAt: [0, 0, 0] },    // High angle
            7: { pos: [-1000, 200, -1000], lookAt: [0, 0, 0] }, // Corner
            8: { pos: [0, 100, 500], lookAt: [0, 0, 0] },      // Close orbit
            9: { pos: [0, 2000, 0], lookAt: [0, 0, 0] }        // Bird's eye
        };
        
        if (presets[preset]) {
            const { pos, lookAt } = presets[preset];
            this.camera.position.set(...pos);
            const lookAtVec = new THREE.Vector3(...lookAt);
            this.camera.lookAt(lookAtVec);
            this.eventBus.publish('camera:preset_applied', { preset });
        }
    }
    
    shake(intensity) {
        this.shakeIntensity = intensity;
    }
}

// =====================================================================================
// NOISE FUNCTION FOR TERRAIN GENERATION
// FROM: earth.html
// =====================================================================================
/**
 * Create a 2D Perlin noise function using a seeded PRNG
 */
function createNoise2D(prng) {
    const perm = Array.from({length: 256}, (_, i) => i);
    for (let i = 255; i > 0; i--) {
        const j = Math.floor(prng() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
    }
    const p = new Uint8Array(512);
    for(let i=0; i<256; i++) p[i] = p[i+256] = perm[i];

    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function lerp(t, a, b) { return a + t * (b - a); }
    function grad(hash, x, y) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    }

    return function(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = fade(x);
        const v = fade(y);
        const a = p[X] + Y, b = p[X + 1] + Y;
        return lerp(v, lerp(u, grad(p[a], x, y), grad(p[b], x - 1, y)),
                       lerp(u, grad(p[a + 1], x, y - 1), grad(p[b + 1], x - 1, y - 1)));
    };
}

// =====================================================================================
// SURFACE MANAGER
// FROM: earth.html + CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 4C
// =====================================================================================
/**
 * SurfaceManager - Manages planetary surface simulation
 * Features: terrain generation, ocean, sky dome, vegetation, collision detection
 */
class SurfaceManager {
    constructor(eventBus, scene, prng) {
        this.eventBus = eventBus;
        this.scene = scene;
        this.prng = prng;
        this.surfaceGroup = new THREE.Group();
        this.surfaceGroup.visible = false;
        this.scene.add(this.surfaceGroup);
        this.noise = createNoise2D(this.prng);
        
        // Surface entities
        this.terrain = null;
        this.water = null;
        this.sky = null;
        this.vegetation = null;
        this.sentinels = [];
        this.motes = [];
        
        // Surface parameters
        this.oceanRoughness = 0.3;
        this.cloudCoverage = 0.4;
        this.vegetationDensity = 0.6;
        
        this.buildSurface();
    }
    
    buildSurface() {
        // Sky dome
        this.sky = new Sky();
        this.sky.scale.setScalar(450000);
        this.surfaceGroup.add(this.sky);
        
        const sun = new THREE.Vector3();
        const uniforms = this.sky.material.uniforms;
        uniforms['turbidity'].value = 10;
        uniforms['rayleigh'].value = 2;
        uniforms['mieCoefficient'].value = 0.005;
        uniforms['mieDirectionalG'].value = 0.8;
        const phi = THREE.MathUtils.degToRad(90 - 25);
        const theta = THREE.MathUtils.degToRad(180);
        sun.setFromSphericalCoords(1, phi, theta);
        uniforms['sunPosition'].value.copy(sun);
        
        // Terrain generation using Perlin noise
        const terrainGeo = new THREE.PlaneGeometry(8000, 8000, 200, 200);
        const pos = terrainGeo.attributes.position;
        for(let i = 0; i < pos.count; i++) {
            const x = pos.getX(i);
            const y = pos.getY(i);
            const z1 = this.noise(x * 0.005, y * 0.005) * 300;
            const z2 = this.noise(x * 0.02, y * 0.02) * 50;
            pos.setZ(i, z1 + z2);
        }
        terrainGeo.computeVertexNormals();
        const terrainMat = new THREE.MeshStandardMaterial({
            color: 0x6a7863,
            roughness: 0.9,
            metalness: 0.1
        });
        this.terrain = new THREE.Mesh(terrainGeo, terrainMat);
        this.terrain.rotation.x = -Math.PI / 2;
        this.terrain.userData.isGenerated = true;
        this.terrain.userData.type = 'terrain';
        this.surfaceGroup.add(this.terrain);
        
        // Initialize 12D state for terrain
        initialize12DState(this.terrain, 'terrain', {
            mass: 1e10,
            radius: 4000,
            velocity: new THREE.Vector3(0, 0, 0)
        });

        // Water/Ocean
        const waterGeo = new THREE.PlaneGeometry(8000, 8000);
        const waterMat = new THREE.MeshStandardMaterial({
            color: 0x42628a,
            transparent: true,
            opacity: 0.85,
            roughness: 0.2,
            metalness: 0.5
        });
        this.water = new THREE.Mesh(waterGeo, waterMat);
        this.water.rotation.x = -Math.PI / 2;
        this.water.position.y = 20;
        this.water.userData.isGenerated = true;
        this.water.userData.type = 'ocean';
        this.surfaceGroup.add(this.water);
        
        // Initialize 12D state for ocean
        initialize12DState(this.water, 'ocean', {
            mass: 1e8,
            radius: 4000,
            velocity: new THREE.Vector3(0, 0, 0)
        });
        
        // Vegetation (instanced grass)
        this.createVegetation();
    }
    
    createVegetation() {
        // Create instanced grass/vegetation
        const grassCount = Math.floor(5000 * this.vegetationDensity);
        const geometry = new THREE.ConeGeometry(0.5, 2, 4);
        const material = new THREE.MeshStandardMaterial({ color: 0x4a7c3f });
        const instancedMesh = new THREE.InstancedMesh(geometry, material, grassCount);
        
        const matrix = new THREE.Matrix4();
        for (let i = 0; i < grassCount; i++) {
            const x = (this.prng() - 0.5) * 7000;
            const z = (this.prng() - 0.5) * 7000;
            const y = this.getTerrainHeight(x, z) + 1;
            const scale = 0.5 + this.prng() * 1.5;
            const rotation = this.prng() * Math.PI * 2;
            
            matrix.makeRotationY(rotation);
            matrix.setPosition(x, y, z);
            matrix.scale(new THREE.Vector3(scale, scale, scale));
            instancedMesh.setMatrixAt(i, matrix);
        }
        instancedMesh.instanceMatrix.needsUpdate = true;
        instancedMesh.userData.isGenerated = true;
        instancedMesh.userData.type = 'vegetation';
        this.surfaceGroup.add(instancedMesh);
        this.vegetation = instancedMesh;
    }
    
    getTerrainHeight(x, z) {
        // Sample terrain height at position (simplified - would raycast in full implementation)
        if (this.terrain && this.terrain.geometry) {
            const z1 = this.noise(x * 0.005, z * 0.005) * 300;
            const z2 = this.noise(x * 0.02, z * 0.02) * 50;
            return z1 + z2;
        }
        return 0;
    }
    
    /**
     * Get all entities for CST computation
     */
    getEntities() {
        const entities = [];
        if (this.terrain) entities.push(this.terrain);
        if (this.water) entities.push(this.water);
        if (this.vegetation) entities.push(this.vegetation);
        entities.push(...this.sentinels);
        entities.push(...this.motes);
        return entities;
    }
    
    /**
     * Set visibility for mode switching
     */
    setVisible(visible) {
        this.surfaceGroup.visible = visible;
        if (this.scene.fog) {
            this.scene.fog.isFog = visible;
        }
    }
    
    /**
     * Update surface simulation
     */
    update(delta, STATE, camera) {
        // Update water animation
        if (this.water) {
            this.water.material.roughness = this.oceanRoughness * 0.4;
            // Simple wave animation
            this.water.position.y = 20 + Math.sin(STATE.runtime.totalTime * 0.5) * 2;
        }
        
        // Update surface HUD
        if (STATE.currentMode === 'surface') {
            STATE.ui.surfaceHUDVisible = true;
            const hudOcean = document.getElementById('hudOcean');
            if (hudOcean) hudOcean.textContent = this.oceanRoughness.toFixed(2);
            const hudCloud = document.getElementById('hudCloud');
            if (hudCloud) hudCloud.textContent = `${Math.round(this.cloudCoverage * 100)}%`;
            const hudVeg = document.getElementById('hudVeg');
            if (hudVeg) hudVeg.textContent = `${Math.round(this.vegetationDensity * 100)}%`;
        }
    }
    
    /**
     * Spawn Sentinels (bio-inspired entities)
     */
    spawnSentinels(count = 5) {
        for (let i = 0; i < count; i++) {
            const x = (this.prng() - 0.5) * 5000;
            const z = (this.prng() - 0.5) * 5000;
            const y = this.getTerrainHeight(x, z) + 10;
            
            const geometry = new THREE.OctahedronGeometry(2);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x8b5cf6,
                emissive: 0x4a1a8b,
                emissiveIntensity: 0.5
            });
            const sentinel = new THREE.Mesh(geometry, material);
            sentinel.position.set(x, y, z);
            sentinel.userData.isGenerated = true;
            sentinel.userData.type = 'sentinel';
            sentinel.userData.velocity = new THREE.Vector3(0, 0, 0);
            
            initialize12DState(sentinel, 'sentinel', {
                mass: 10,
                radius: 2,
                velocity: new THREE.Vector3(0, 0, 0)
            });
            
            this.surfaceGroup.add(sentinel);
            this.sentinels.push(sentinel);
        }
        this.eventBus.publish('surface:sentinels_spawned', { count });
    }
    
    /**
     * Spawn Motes (smaller bio-inspired entities)
     */
    spawnMotes(count = 20) {
        for (let i = 0; i < count; i++) {
            const x = (this.prng() - 0.5) * 5000;
            const z = (this.prng() - 0.5) * 5000;
            const y = this.getTerrainHeight(x, z) + 5;
            
            const geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x38bdf8,
                emissive: 0x0ea5e9,
                emissiveIntensity: 0.8
            });
            const mote = new THREE.Mesh(geometry, material);
            mote.position.set(x, y, z);
            mote.userData.isGenerated = true;
            mote.userData.type = 'mote';
            mote.userData.velocity = new THREE.Vector3(0, 0, 0);
            
            initialize12DState(mote, 'mote', {
                mass: 1,
                radius: 0.3,
                velocity: new THREE.Vector3(0, 0, 0)
            });
            
            this.surfaceGroup.add(mote);
            this.motes.push(mote);
        }
        this.eventBus.publish('surface:motes_spawned', { count });
    }
}

// =====================================================================================
// AUDIO REACTIVE SYSTEM
// FROM: DARkcosmo.HTML + CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 4D
// =====================================================================================
/**
 * AudioReactiveSystem - Beat detection, burst particles, spectrum visualization, camera shake
 */
class AudioReactiveSystem {
    constructor(scene, eventBus, camera) {
        this.scene = scene;
        this.eventBus = eventBus;
        this.camera = camera;
        this.particles = null;
        this.MAX_PARTICLES = 10000;
        this.audioHistory = [];
        this.maxHistoryLength = 60;
        
        this.particleCursor = 0;
        this.velocities = [];
        this.lifetimes = [];
        this.audioIntensity = 0;
        this.bassIntensity = 0;
        this.midIntensity = 0;
        this.trebleIntensity = 0;
        
        // Beat detection
        this.beatThreshold = 0.3;
        this.lastBeatTime = 0;
        this.beatCooldown = 0.2;
        
        // Camera shake
        this.shakeIntensity = 0;
        this.shakeDecay = 0.95;
        
        this.createParticleSystem();
        this.createSpectrumVisualizer();
        
        this.eventBus.subscribe('audio:update', (data) => this.onAudioData(data));
        this.eventBus.subscribe('audio:data', (data) => this.onAudioData(data));
    }

    createParticleSystem() {
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.MAX_PARTICLES * 3), 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.MAX_PARTICLES * 3), 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(new Float32Array(this.MAX_PARTICLES), 1));
        
        const material = new THREE.PointsMaterial({ 
            size: 2.0, 
            vertexColors: true, 
            blending: THREE.AdditiveBlending, 
            depthWrite: false, 
            transparent: true,
            sizeAttenuation: true
        });
        
        this.particleSystem = new THREE.Points(geometry, material);
        this.particleSystem.userData.isGenerated = true;
        this.particleSystem.userData.type = 'audio_reactive';
        this.scene.add(this.particleSystem);
    }

    createSpectrumVisualizer() {
        const spectrumGeometry = new THREE.BufferGeometry();
        const spectrumPositions = new Float32Array(256 * 3);
        const spectrumColors = new Float32Array(256 * 3);
        
        for (let i = 0; i < 256; i++) {
            const x = (i / 256) * 20 - 10;
            spectrumPositions[i * 3] = x;
            spectrumPositions[i * 3 + 1] = 0;
            spectrumPositions[i * 3 + 2] = 0;
            
            const hue = i / 256;
            const color = new THREE.Color().setHSL(hue, 1.0, 0.5);
            spectrumColors[i * 3] = color.r;
            spectrumColors[i * 3 + 1] = color.g;
            spectrumColors[i * 3 + 2] = color.b;
        }
        
        spectrumGeometry.setAttribute('position', new THREE.BufferAttribute(spectrumPositions, 3));
        spectrumGeometry.setAttribute('color', new THREE.BufferAttribute(spectrumColors, 3));
        
        const spectrumMaterial = new THREE.LineBasicMaterial({ 
            vertexColors: true, 
            linewidth: 3,
            transparent: true,
            opacity: 0.8
        });
        
        this.spectrumLine = new THREE.Line(spectrumGeometry, spectrumMaterial);
        this.spectrumLine.position.set(0, -15, 0);
        this.spectrumLine.userData.isGenerated = true;
        this.scene.add(this.spectrumLine);
    }

    onAudioData(data) {
        if (!this.particleSystem) return;
        
        // Extract audio data
        const raw = data.raw || data.spectralBands || [];
        const avgFreq = data.avgFreq || data.energy || 0;
        
        if (raw.length === 0) return;
        
        // Analyze frequency spectrum
        this.analyzeSpectrum(raw);
        
        // Beat detection
        const currentTime = Date.now() / 1000;
        if (this.bassIntensity > this.beatThreshold && 
            (currentTime - this.lastBeatTime) > this.beatCooldown) {
            this.detectBeat();
            this.lastBeatTime = currentTime;
        }
        
        const positions = this.particleSystem.geometry.attributes.position.array;
        const colors = this.particleSystem.geometry.attributes.color.array;
        const sizes = this.particleSystem.geometry.attributes.size.array;

        const volume = raw.reduce((a, b) => a + b, 0) / raw.length / 255;
        const numToSpawn = Math.floor(volume * 50);

        // Create burst particles on beat
        if (this.bassIntensity > this.beatThreshold) {
            this.spawnBurstParticles(positions, colors, sizes, avgFreq);
        }

        // Create different particle types based on frequency content
        for (let i = 0; i < numToSpawn; i++) {
            const pIndex = this.particleCursor;
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            const radius = 5 + Math.random() * 30;
            
            positions[pIndex * 3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[pIndex * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[pIndex * 3 + 2] = radius * Math.cos(phi);
            
            // Color based on frequency and intensity
            let color;
            if (this.bassIntensity > 0.5) {
                color = new THREE.Color().setHSL(0.1, 0.9, 0.6 + this.bassIntensity * 0.3);
            } else if (this.midIntensity > 0.5) {
                color = new THREE.Color().setHSL(0.3, 0.8, 0.5 + this.midIntensity * 0.4);
            } else if (this.trebleIntensity > 0.5) {
                color = new THREE.Color().setHSL(0.6, 0.9, 0.7 + this.trebleIntensity * 0.2);
            } else {
                color = new THREE.Color().setHSL(avgFreq / 150, 0.8, 0.6);
            }
            
            colors[pIndex * 3] = color.r; 
            colors[pIndex * 3 + 1] = color.g; 
            colors[pIndex * 3 + 2] = color.b;
            
            // Size based on audio intensity
            sizes[pIndex] = 1.0 + volume * 3.0;
            
            // Velocity based on frequency content
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * (1 + this.bassIntensity * 2),
                (Math.random() - 0.5) * (1 + this.midIntensity * 2),
                (Math.random() - 0.5) * (1 + this.trebleIntensity * 2)
            ).multiplyScalar(volume * 3.0);
            
            this.velocities[pIndex] = velocity;
            this.lifetimes[pIndex] = 1.0 + Math.random() * 2.0;
            
            this.particleCursor = (this.particleCursor + 1) % this.MAX_PARTICLES;
        }
        
        // Update spectrum visualizer
        this.updateSpectrumVisualizer(raw);
    }

    analyzeSpectrum(raw) {
        if (!raw || raw.length === 0) return;
        
        const binCount = raw.length;
        const bassEnd = Math.floor(binCount * 0.1);
        const midEnd = Math.floor(binCount * 0.4);
        
        let bassSum = 0, midSum = 0, trebleSum = 0;
        
        for (let i = 0; i < binCount; i++) {
            const val = Math.pow(raw[i] / 255, 2);
            if (i < bassEnd) bassSum += val;
            else if (i < midEnd) midSum += val;
            else trebleSum += val;
        }
        
        this.bassIntensity = Math.min(1, bassSum / (bassEnd * 0.5));
        this.midIntensity = Math.min(1, midSum / ((midEnd - bassEnd) * 0.5));
        this.trebleIntensity = Math.min(1, trebleSum / ((binCount - midEnd) * 0.5));
        this.audioIntensity = (this.bassIntensity + this.midIntensity + this.trebleIntensity) / 3;
    }

    detectBeat() {
        // Trigger camera shake on beat
        this.shakeIntensity = Math.min(1.0, this.bassIntensity * 2.0);
        if (this.eventBus) {
            this.eventBus.publish('camera:shake', { intensity: this.shakeIntensity });
        }
        
        // Emit beat event
        this.eventBus.publish('audio:beat', {
            intensity: this.bassIntensity,
            timestamp: Date.now()
        });
    }

    spawnBurstParticles(positions, colors, sizes, avgFreq) {
        // Spawn burst of particles on beat
        const burstCount = Math.floor(this.bassIntensity * 100);
        for (let i = 0; i < burstCount; i++) {
            const pIndex = this.particleCursor;
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            const radius = 10 + Math.random() * 50;
            
            positions[pIndex * 3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[pIndex * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[pIndex * 3 + 2] = radius * Math.cos(phi);
            
            const color = new THREE.Color().setHSL(0.1, 0.9, 0.7);
            colors[pIndex * 3] = color.r;
            colors[pIndex * 3 + 1] = color.g;
            colors[pIndex * 3 + 2] = color.b;
            
            sizes[pIndex] = 3.0 + this.bassIntensity * 5.0;
            
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10
            );
            
            this.velocities[pIndex] = velocity;
            this.lifetimes[pIndex] = 2.0;
            
            this.particleCursor = (this.particleCursor + 1) % this.MAX_PARTICLES;
        }
    }

    updateSpectrumVisualizer(raw) {
        if (!this.spectrumLine || !raw) return;
        
        const positions = this.spectrumLine.geometry.attributes.position.array;
        const colors = this.spectrumLine.geometry.attributes.color.array;
        
        for (let i = 0; i < 256; i++) {
            const dataIndex = Math.floor((i / 256) * raw.length);
            const intensity = raw[dataIndex] / 255;
            
            // Update Y position based on frequency intensity
            positions[i * 3 + 1] = intensity * 10;
            
            // Update color based on frequency
            const hue = i / 256;
            const color = new THREE.Color().setHSL(hue, 1.0, 0.3 + intensity * 0.7);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }
        
        this.spectrumLine.geometry.attributes.position.needsUpdate = true;
        this.spectrumLine.geometry.attributes.color.needsUpdate = true;
    }

    update(delta) {
        if (!this.particleSystem) return;
        
        const positions = this.particleSystem.geometry.attributes.position.array;
        const colors = this.particleSystem.geometry.attributes.color.array;
        const sizes = this.particleSystem.geometry.attributes.size.array;
        
        for (let i = 0; i < this.MAX_PARTICLES; i++) {
            if (this.velocities[i] && this.lifetimes[i] > 0) {
                // Update position
                positions[i * 3] += this.velocities[i].x * delta;
                positions[i * 3 + 1] += this.velocities[i].y * delta;
                positions[i * 3 + 2] += this.velocities[i].z * delta;
                
                // Apply damping
                this.velocities[i].multiplyScalar(1 - (0.3 * delta));
                
                // Update lifetime
                this.lifetimes[i] -= delta;
                
                // Fade out particles as they age
                const alpha = Math.max(0, this.lifetimes[i] / 2.0);
                colors[i * 3] *= alpha;
                colors[i * 3 + 1] *= alpha;
                colors[i * 3 + 2] *= alpha;
                
                // Shrink particles as they age
                sizes[i] *= (1 - delta * 0.5);
                
                // Reset particle when lifetime expires
                if (this.lifetimes[i] <= 0) {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                    this.velocities[i] = null;
                    sizes[i] = 0;
                }
            }
        }
        
        this.particleSystem.geometry.attributes.position.needsUpdate = true;
        this.particleSystem.geometry.attributes.color.needsUpdate = true;
        this.particleSystem.geometry.attributes.size.needsUpdate = true;
        
        // Update spectrum line rotation
        if (this.spectrumLine) {
            this.spectrumLine.rotation.y += delta * 0.5;
        }
        
        // Decay camera shake
        this.shakeIntensity *= this.shakeDecay;
    }

    /**
     * Get all entities for CST computation
     */
    getEntities() {
        const entities = [];
        if (this.particleSystem) entities.push(this.particleSystem);
        if (this.spectrumLine) entities.push(this.spectrumLine);
        return entities;
    }

    /**
     * Set visibility for mode switching
     */
    setVisible(visible) {
        if (this.particleSystem) this.particleSystem.visible = visible;
        if (this.spectrumLine) this.spectrumLine.visible = visible;
    }
}

// =====================================================================================
// MEMORY ECHO ENGINE
// FROM: DARkcosmo.HTML + CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 4E
// =====================================================================================
/**
 * MemoryEchoEngine - File particlization, upload dialog, byte-to-particle conversion, spiral arrangement
 */
class MemoryEchoEngine {
    constructor(scene, camera, eventBus, dataLogger) {
        this.scene = scene;
        this.camera = camera;
        this.eventBus = eventBus;
        this.dataLogger = dataLogger;
        this.isActive = false;
        this.data = null;
        this.particleSystem = null;
        this.player = null;
        this.artifacts = [];
        this.keys = {};
        this.audioCtx = null;
        this.oscillator = null;
        this.gainNode = null;
        this.foundCount = 0;
        this.echoGroup = new THREE.Group();
        this.echoGroup.visible = false;
        this.scene.add(this.echoGroup);
        
        // File upload handling
        this.initFileUpload();
        
        // Keyboard input
        document.addEventListener('keydown', (e) => {
            this.keys[e.key.toLowerCase()] = true;
        });
        document.addEventListener('keyup', (e) => {
            this.keys[e.key.toLowerCase()] = false;
        });
        
        // Subscribe to mode changes
        this.eventBus.subscribe('mode:changed', (data) => {
            if (data.mode === 'echo' && this.data) {
                this.enter();
            } else if (data.mode !== 'echo') {
                this.exit();
            }
        });
    }
    
    initFileUpload() {
        const fileUpload = document.getElementById('file-upload');
        if (fileUpload) {
            fileUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    this.loadData(file);
                }
            });
        }
    }
    
    loadData(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            this.data = new Uint8Array(e.target.result);
            if (this.dataLogger) {
                this.dataLogger.logLedger('info', 'MemoryEcho', `Data catalyst processed: ${file.name} (${this.data.length} bytes)`);
            }
            this.eventBus.publish('memoryEcho:dataLoaded', { 
                filename: file.name, 
                size: this.data.length 
            });
        };
        reader.readAsArrayBuffer(file);
    }
    
    particlizeFile(file) {
        // Convert file bytes to particles in spiral arrangement
        this.loadData(file);
    }
    
    enter() {
        if (!this.data) {
            if (this.dataLogger) {
                this.dataLogger.logLedger('error', 'MemoryEcho', 'Cannot enter echo without data catalyst.');
            }
            return;
        }
        
        this.isActive = true;
        this.echoGroup.visible = true;
        
        if (this.dataLogger) {
            this.dataLogger.logLedger('warn', 'MemoryEcho', 'Transmuting data... Entering playable memory echo.');
        }
        
        this.camera.position.set(0, 10, 50);
        this.camera.rotation.set(0, 0, 0);
        
        // Generate seed from data
        const dataString = Array.from(this.data.slice(0, 1000)).map(b => String.fromCharCode(b)).join('');
        const seed = cyrb128(dataString);
        const prng = sfc32(...seed);
        
        // Convert bytes to particles in spiral arrangement
        const positions = [];
        const colors = [];
        const colorPalettes = [
            { r: 0.5, g: 0.2, b: 0.8 },
            { r: 0.2, g: 0.8, b: 0.5 },
            { r: 0.9, g: 0.5, b: 0.2 },
            { r: 0.2, g: 0.5, b: 0.9 }
        ];
        
        // Spiral arrangement: convert bytes to particles
        const particleCount = Math.min(this.data.length, 80000);
        const spiralRadius = 2000;
        const spiralTurns = 10;
        
        for (let i = 0; i < particleCount; i++) {
            const byte = this.data[i];
            const t = i / particleCount;
            const angle = t * Math.PI * 2 * spiralTurns;
            const radius = t * spiralRadius;
            
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = (byte / 255 - 0.5) * 500;
            
            positions.push(x, y, z);
            
            // Color based on byte value and quadrant
            const quadrant = Math.floor(angle / (Math.PI / 2)) % 4;
            const palette = colorPalettes[quadrant];
            const intensity = byte / 255;
            
            colors.push(
                palette.r * intensity,
                palette.g * intensity,
                palette.b * intensity
            );
        }
        
        // Create particle system
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({
            size: 3,
            vertexColors: true,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            opacity: 0.7,
            transparent: true
        });
        
        this.particleSystem = new THREE.Points(geometry, material);
        this.particleSystem.userData.isGenerated = true;
        this.particleSystem.userData.type = 'memory_echo';
        this.echoGroup.add(this.particleSystem);
        
        // Initialize 12D state for particle system
        initialize12DState(this.particleSystem, 'memory_echo', {
            mass: particleCount * 0.01,
            radius: spiralRadius,
            velocity: new THREE.Vector3(0, 0, 0)
        });
        
        // Create player
        this.player = new THREE.Group();
        const playerMesh = new THREE.Mesh(
            new THREE.IcosahedronGeometry(2, 0),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        this.player.add(playerMesh);
        this.player.position.set(0, 0, 0);
        this.echoGroup.add(this.player);
        
        // Create artifacts (4 "Giant's Remains")
        for (let i = 0; i < 4; i++) {
            const palette = colorPalettes[i];
            const artifact = new THREE.Mesh(
                new THREE.BoxGeometry(10, 20, 10),
                new THREE.MeshBasicMaterial({
                    color: new THREE.Color(palette.r, palette.g, palette.b),
                    wireframe: true
                })
            );
            
            const angle = (i / 4) * Math.PI * 2;
            const dist = spiralRadius * 0.7;
            artifact.position.set(
                Math.cos(angle) * dist,
                0,
                Math.sin(angle) * dist
            );
            artifact.userData.isArtifact = true;
            artifact.userData.type = 'artifact';
            
            initialize12DState(artifact, 'artifact', {
                mass: 100,
                radius: 10,
                velocity: new THREE.Vector3(0, 0, 0)
            });
            
            this.echoGroup.add(artifact);
            this.artifacts.push(artifact);
        }
        
        this.initAudioSearch();
        this.eventBus.publish('memoryEcho:entered', { particleCount });
    }
    
    update(delta, STATE) {
        if (!this.isActive || !this.player) return;
        
        // Player movement
        const moveSpeed = 100 * delta;
        if (this.keys['w'] || this.keys['arrowup']) this.player.position.z -= moveSpeed;
        if (this.keys['s'] || this.keys['arrowdown']) this.player.position.z += moveSpeed;
        if (this.keys['a'] || this.keys['arrowleft']) this.player.position.x -= moveSpeed;
        if (this.keys['d'] || this.keys['arrowright']) this.player.position.x += moveSpeed;
        if (this.keys[' ']) this.player.position.y += moveSpeed;
        if (this.keys['shift']) this.player.position.y -= moveSpeed;
        
        // Camera follows player
        this.camera.position.lerp(
            this.player.position.clone().add(new THREE.Vector3(0, 10, 50)),
            0.05
        );
        this.camera.lookAt(this.player.position);
        
        // Update artifacts
        let closestDist = Infinity;
        this.artifacts.forEach(artifact => {
            artifact.rotation.y += delta;
            const dist = this.player.position.distanceTo(artifact.position);
            if (dist < closestDist) closestDist = dist;
            
            // Collect artifact
            if (dist < 20) {
                this.echoGroup.remove(artifact);
                this.artifacts = this.artifacts.filter(a => a !== artifact);
                this.foundCount++;
                
                if (this.dataLogger) {
                    this.dataLogger.logLedger('success', 'MemoryEcho', 
                        `Giant's Remains Found! (${this.foundCount}/4)`);
                }
            }
        });
        
        // Audio feedback based on proximity
        if (this.gainNode) {
            const proximity = Math.max(0, 1 - closestDist / 3000);
            this.gainNode.gain.setTargetAtTime(proximity * 0.1, this.audioCtx.currentTime, 0.01);
            this.oscillator.frequency.setTargetAtTime(
                100 + (1000 * proximity),
                this.audioCtx.currentTime,
                0.01
            );
        }
        
        // All artifacts found
        if (this.artifacts.length === 0) {
            if (this.dataLogger) {
                this.dataLogger.logLedger('success', 'MemoryEcho', 
                    'All remains found! The echo stabilizes.');
            }
            this.exit();
        }
    }
    
    exit() {
        this.isActive = false;
        this.echoGroup.visible = false;
        
        // Cleanup
        if (this.particleSystem) {
            this.echoGroup.remove(this.particleSystem);
            this.particleSystem.geometry.dispose();
            this.particleSystem.material.dispose();
            this.particleSystem = null;
        }
        
        if (this.player) {
            this.echoGroup.remove(this.player);
            this.player = null;
        }
        
        this.artifacts.forEach(artifact => {
            this.echoGroup.remove(artifact);
            artifact.geometry.dispose();
            artifact.material.dispose();
        });
        this.artifacts = [];
        this.foundCount = 0;
        
        if (this.oscillator) this.oscillator.stop();
        if (this.audioCtx) this.audioCtx.close();
        this.audioCtx = null;
        this.oscillator = null;
        this.gainNode = null;
        
        if (this.dataLogger) {
            this.dataLogger.logLedger('info', 'MemoryEcho', 'Returned to void.');
        }
        
        this.eventBus.publish('memoryEcho:exited', {});
    }
    
    initAudioSearch() {
        try {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            this.oscillator = this.audioCtx.createOscillator();
            this.gainNode = this.audioCtx.createGain();
            this.oscillator.connect(this.gainNode);
            this.gainNode.connect(this.audioCtx.destination);
            this.gainNode.gain.value = 0;
            this.oscillator.type = 'sine';
            this.oscillator.start();
        } catch (error) {
            console.warn('MemoryEcho audio initialization failed:', error);
        }
    }
    
    /**
     * Get all entities for CST computation
     */
    getEntities() {
        const entities = [];
        if (this.particleSystem) entities.push(this.particleSystem);
        entities.push(...this.artifacts);
        if (this.player) entities.push(this.player);
        return entities;
    }
    
    /**
     * Set visibility for mode switching
     */
    setVisible(visible) {
        this.echoGroup.visible = visible && this.isActive;
    }
}

// =====================================================================================
// SENSOR & EXTERNAL DATA INTEGRATION
// =====================================================================================

/**
 * SensoryInputManager - Handles audio, video, geolocation, and ambient light sensors.
 * SOURCE: Adapted from lostcosmo's.html + CLAUDE integration prompt (Phase 5)
 *
 * AUDIO SYSTEM FIX (2025):
 * ‚úì Persistent AudioContext - no longer recreated on each toggle
 * ‚úì Single getUserMedia request - permission asked only once
 * ‚úì isAudioInitialized flag - tracks whether audio system is ready
 * ‚úì audioEnabled flag - controls processing without destroying context
 * ‚úì updateAudioStatus() - updates #audio-status element with color-coded status
 * ‚úì No repeated permission prompts - context stays alive when toggled off
 *
 * Audio Toggle Behavior:
 * - First toggle ON: Requests permission, creates AudioContext, sets isAudioInitialized=true
 * - Toggle OFF: Sets audioEnabled=false (context stays alive, no processing)
 * - Subsequent toggle ON: Sets audioEnabled=true (uses existing context)
 * - Full cleanup only via stopAudio() method (not called by toggle)
 */
class SensoryInputManager {
    constructor(eventBus, uiManager, dataLogger) {
        this.eventBus = eventBus;
        this.uiManager = uiManager;
        this.dataLogger = dataLogger;

        this.videoElement = document.getElementById('video-feed');

        this.audioContext = null;
        this.audioAnalyser = null;
        this.audioDataArray = null;
        this.audioWaveArray = null;
        this.audioStream = null;
        this.audioEnabled = false;
        this.isAudioInitialized = false; // Persistent flag - stays true even when toggled off

        this.videoStream = null;
        this.videoLoopHandle = null;

        this.geoWatchId = null;
        this.ambientSensor = null;
        this.ambientListener = null;

        this.initialized = {
            audio: false,
            video: false,
            geolocation: false,
            ambient: false
        };

        this.lastPulse = {
            audio: 0,
            video: 0,
            geolocation: 0,
            ambient: 0
        };

        this.lastTelemetry = {
            audio: 0,
            video: 0
        };

        this.inFlightInitialization = null;

        // Audio toggle - now supports persistent AudioContext
        this.eventBus.subscribe('ui:toggleAudio', async (enabled) => {
            if (enabled) {
                // Initialize if first time, otherwise just enable processing
                if (!this.isAudioInitialized) {
                    await this.initAudio(false);
                } else {
                    this.audioEnabled = true;
                    this.updateAudioStatus('active');
                }
            } else {
                // Disable processing but keep context alive
                this.audioEnabled = false;
                this.updateAudioStatus('inactive');
            }
        });
    }

    async initializeAll() {
        if (!STATE.flags.enableSensors) {
            this.reportSensorStatus('Sensors', 'warn', 'Sensors disabled via STATE.flags.enableSensors');
            return [];
        }

        if (this.inFlightInitialization) {
            return this.inFlightInitialization;
        }

        this.reportSensorStatus('Sensors', 'info', 'Requesting sensor permissions...');

        const tasks = [
            this.initAudio(),
            this.initVideo(),
            this.initGeolocation(),
            this.initAmbientLight()
        ];

        this.inFlightInitialization = Promise.allSettled(tasks);
        const results = await this.inFlightInitialization;
        this.inFlightInitialization = null;

        const successCount = results.filter(result => result.status === 'fulfilled' && result.value === true).length;
        this.reportSensorStatus('Sensors', successCount > 0 ? 'success' : 'warn', `Initialization complete (${successCount}/4 ready)`);

        return results;
    }

    async initAudio(force = false) {
        if (!STATE.flags.enableSensors) return false;

        // If already initialized and not forcing, skip re-initialization
        if (this.isAudioInitialized && !force) {
            this.audioEnabled = true;
            this.updateAudioStatus('active');
            return true;
        }

        if (!navigator?.mediaDevices?.getUserMedia) {
            this.reportSensorStatus('Microphone', 'warn', 'getUserMedia unsupported');
            this.updateAudioStatus('unsupported');
            return false;
        }

        try {
            // Only request getUserMedia if not already initialized
            if (!this.audioStream) {
                this.audioStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            }

            // Only create AudioContext if not already created
            if (!this.audioContext) {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = this.audioContext.createMediaStreamSource(this.audioStream);
                this.audioAnalyser = this.audioContext.createAnalyser();
                this.audioAnalyser.fftSize = 1024;
                this.audioAnalyser.smoothingTimeConstant = 0.85;
                source.connect(this.audioAnalyser);

                this.audioDataArray = new Uint8Array(this.audioAnalyser.frequencyBinCount);
                this.audioWaveArray = new Uint8Array(this.audioAnalyser.fftSize);
            }

            this.audioEnabled = true;
            this.initialized.audio = true;
            this.isAudioInitialized = true; // Set persistent flag

            this.reportSensorStatus('Microphone', 'success', 'Online');
            this.eventBus.publish('sensor:audio:status', { status: 'online' });
            this.updateAudioStatus('active');

            return true;
        } catch (error) {
            this.reportSensorStatus('Microphone', 'error', error?.message || 'Permission denied');
            this.eventBus.publish('sensor:audio:status', { status: 'error', error });
            this.updateAudioStatus('error');
            return false;
        }
    }

    stopAudio() {
        // Full cleanup - only used when completely stopping audio system
        if (this.audioStream) {
            this.audioStream.getTracks().forEach(track => track.stop());
            this.audioStream = null;
        }
        if (this.audioContext) {
            this.audioContext.close().catch(() => {});
            this.audioContext = null;
        }
        this.audioAnalyser = null;
        this.audioEnabled = false;
        this.initialized.audio = false;
        this.isAudioInitialized = false; // Reset persistent flag
        this.reportSensorStatus('Microphone', 'info', 'Audio capture stopped');
        this.eventBus.publish('sensor:audio:status', { status: 'stopped' });
        this.updateAudioStatus('stopped');
    }

    updateAudioStatus(status) {
        const audioStatusEl = document.getElementById('audio-status');
        if (!audioStatusEl) return;

        const statusMap = {
            'active': { text: 'Mic: Active', class: 'text-green-400' },
            'inactive': { text: 'Mic: Paused', class: 'text-yellow-400' },
            'stopped': { text: 'Mic: Stopped', class: 'text-slate-500' },
            'error': { text: 'Mic: Error', class: 'text-red-400' },
            'unsupported': { text: 'Mic: Unsupported', class: 'text-slate-500' }
        };

        const statusInfo = statusMap[status] || statusMap['inactive'];
        audioStatusEl.textContent = statusInfo.text;
        audioStatusEl.className = `text-xs text-center mt-2 ${statusInfo.class}`;
    }

    async initVideo(force = false) {
        if (!STATE.flags.enableSensors) return false;
        if (this.initialized.video && !force) return true;
        if (!navigator?.mediaDevices?.getUserMedia) {
            this.reportSensorStatus('Camera', 'warn', 'getUserMedia unsupported');
            return false;
        }

        try {
            if (this.videoStream) {
                this.stopVideo();
            }

            this.videoStream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480 },
                audio: false
            });

            if (this.videoElement) {
                this.videoElement.srcObject = this.videoStream;
                await this.videoElement.play();
            }

            this.initialized.video = true;
            STATE.sensors.video.streamActive = true;
            STATE.sensors.video.lastFrameTime = performance.now();

            this.reportSensorStatus('Camera', 'success', 'Online');
            this.startVideoLoop();

            return true;
        } catch (error) {
            this.reportSensorStatus('Camera', 'error', error?.message || 'Permission denied');
            STATE.sensors.video.streamActive = false;
            return false;
        }
    }

    stopVideo() {
        if (this.videoStream) {
            this.videoStream.getTracks().forEach(track => track.stop());
            this.videoStream = null;
        }
        STATE.sensors.video.streamActive = false;
        this.initialized.video = false;
        this.stopVideoLoop();
        this.reportSensorStatus('Camera', 'info', 'Video capture stopped');
    }

    startVideoLoop() {
        if (this.videoLoopHandle) return;

        const loop = () => {
            if (!this.initialized.video || !this.videoElement) {
                this.videoLoopHandle = null;
                return;
            }

            if (this.videoElement.readyState >= 2) {
                const now = performance.now();
                STATE.sensors.video.lastFrameTime = now;
                if (now - this.lastPulse.video > 750) {
                    this.eventBus.publish('ui:pulse', 'video');
                    this.lastPulse.video = now;
                }
                this.eventBus.publish('video:frame', this.videoElement);
                if (now - this.lastTelemetry.video > 2000) {
                    this.dataLogger?.logTelemetry('sensor:video', { frame: true }, Date.now());
                    this.lastTelemetry.video = now;
                }
            }

            this.videoLoopHandle = requestAnimationFrame(loop);
        };

        this.videoLoopHandle = requestAnimationFrame(loop);
    }

    stopVideoLoop() {
        if (this.videoLoopHandle) {
            cancelAnimationFrame(this.videoLoopHandle);
            this.videoLoopHandle = null;
        }
    }

    async initGeolocation() {
        if (this.initialized.geolocation) return true;
        if (!('geolocation' in navigator)) {
            this.reportSensorStatus('Location', 'warn', 'Unsupported');
            return false;
        }

        return new Promise((resolve) => {
            let resolved = false;
            this.geoWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    const { latitude, longitude, accuracy } = position.coords;
                    const timestamp = Date.now();

                    STATE.sensors.geolocation.lat = latitude;
                    STATE.sensors.geolocation.lon = longitude;
                    STATE.sensors.geolocation.accuracy = accuracy;
                    STATE.sensors.geolocation.lastUpdate = timestamp;

                    this.eventBus.publish('sensor:geolocation', { latitude, longitude, accuracy, timestamp });

                    if (!this.initialized.geolocation) {
                        this.initialized.geolocation = true;
                        this.reportSensorStatus('Location', 'success', `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`);
                    } else if (timestamp - this.lastPulse.geolocation > 5000) {
                        this.eventBus.publish('ui:pulse', 'loc');
                        this.lastPulse.geolocation = timestamp;
                    }

                    if (!resolved) {
                        resolved = true;
                        resolve(true);
                    }
                },
                (error) => {
                    this.reportSensorStatus('Location', 'warn', error?.message || 'Unavailable');
                    if (!resolved) {
                        resolved = true;
                        resolve(false);
                    }
                },
                { enableHighAccuracy: false, timeout: 10000, maximumAge: 600000 }
            );

            if (this.geoWatchId === undefined && !resolved) {
                resolved = true;
                resolve(false);
            }
        });
    }

    async initAmbientLight() {
        if (this.initialized.ambient) return true;

        if ('AmbientLightSensor' in window) {
            try {
                const sensor = new AmbientLightSensor({ frequency: 1 });
                sensor.addEventListener('reading', () => this.handleAmbientMeasurement(sensor.illuminance));
                sensor.addEventListener('error', (event) => {
                    this.reportSensorStatus('Light Sensor', 'warn', event.error?.message || 'Sensor error');
                });
                sensor.start();
                this.ambientSensor = sensor;
                this.initialized.ambient = true;
                this.reportSensorStatus('Light Sensor', 'success', 'Online');
                return true;
            } catch (error) {
                this.reportSensorStatus('Light Sensor', 'warn', error?.message || 'Unavailable');
                return false;
            }
        }

        if ('ondevicelight' in window) {
            this.ambientListener = (event) => this.handleAmbientMeasurement(event.value);
            window.addEventListener('devicelight', this.ambientListener);
            this.initialized.ambient = true;
            this.reportSensorStatus('Light Sensor', 'warn', 'Using DeviceLightEvent fallback');
            return true;
        }

        this.reportSensorStatus('Light Sensor', 'warn', 'Unsupported');
        return false;
    }

    handleAmbientMeasurement(lux) {
        if (lux == null) return;
        const timestamp = Date.now();
        STATE.sensors.ambientLight.lux = lux;
        STATE.sensors.ambientLight.lastUpdate = timestamp;

        this.eventBus.publish('sensor:ambientLight', { lux, timestamp });

        if (timestamp - this.lastPulse.ambient > 2000) {
            this.eventBus.publish('ui:pulse', 'light');
            this.lastPulse.ambient = timestamp;
        }

        this.dataLogger?.logTelemetry('sensor:ambientLight', { lux }, timestamp);
    }

    update() {
        if (!this.audioEnabled || !this.audioAnalyser) return;

        this.audioAnalyser.getByteFrequencyData(this.audioDataArray);
        this.audioAnalyser.getByteTimeDomainData(this.audioWaveArray);

        const freqData = this.audioDataArray;
        const bandCount = 8;
        const spectralBands = [];
        let total = 0;
        const now = Date.now();

        for (let i = 0; i < bandCount; i++) {
            const start = Math.floor((i / bandCount) * freqData.length);
            const end = Math.floor(((i + 1) / bandCount) * freqData.length);
            let sum = 0;
            for (let j = start; j < end; j++) {
                sum += freqData[j];
            }
            const bandAvg = sum / ((end - start) || 1) / 255;
            spectralBands.push(Number.isFinite(bandAvg) ? bandAvg : 0);
            total += bandAvg;
        }

        const avgFreq = Number.isFinite(total) ? (total / bandCount) * 255 : 0;
        const energy = freqData.length > 0
            ? freqData.reduce((sum, val) => sum + val, 0) / (freqData.length * 255)
            : 0;
        const waveform = Array.from(this.audioWaveArray.slice(0, 64)).map(v => (v - 128) / 128);

        STATE.sensors.audio.avgFreq = avgFreq;
        STATE.sensors.audio.energy = energy;
        STATE.sensors.audio.spectralBands = spectralBands;
        STATE.sensors.audio.waveform = waveform;
        STATE.sensors.audio.lastUpdate = now;

        const payload = {
            avgFreq,
            energy,
            spectralBands,
            raw: new Uint8Array(freqData),
            timestamp: now
        };

        this.eventBus.publish('audio:update', payload);
        this.eventBus.publish('sensor:audio', payload);

        if (now - this.lastPulse.audio > 200) {
            this.eventBus.publish('ui:pulse', 'audio');
            this.lastPulse.audio = now;
        }

        if (now - this.lastTelemetry.audio > 1000) {
            this.dataLogger?.logTelemetry('sensor:audio', { avgFreq, energy }, now);
            this.lastTelemetry.audio = now;
        }
    }

    reportSensorStatus(name, level, message, metadata = {}) {
        const ledgerLevelMap = { success: 'info', info: 'info', warn: 'warn', error: 'error' };
        const ledgerLevel = ledgerLevelMap[level] || 'info';

        if (this.uiManager && typeof this.uiManager.log === 'function') {
            this.uiManager.log(`${name}: ${message}`, level === 'success' ? 'success' : level);
        }

        this.dataLogger?.logLedger(ledgerLevel, 'Sensors', `${name}: ${message}`, metadata);
        this.eventBus.publish('sensor:status', { name, level, message, metadata });
    }

    cleanup() {
        this.stopAudio();
        this.stopVideo();

        if (this.geoWatchId !== null && navigator.geolocation?.clearWatch) {
            navigator.geolocation.clearWatch(this.geoWatchId);
            this.geoWatchId = null;
        }

        if (this.ambientSensor) {
            try {
                this.ambientSensor.stop();
            } catch (error) {
                // ignore sensor stop errors
            }
            this.ambientSensor = null;
        }

        if (this.ambientListener) {
            window.removeEventListener('devicelight', this.ambientListener);
            this.ambientListener = null;
        }
    }
}

/**
 * ExternalDataManager - Integrates USGS + NASA data feeds with STATE.external.
 * SOURCE: Adapted from lostcosmo's.html + CLAUDE integration prompt (Phase 5)
 */
class ExternalDataManager {
    constructor(eventBus, dataLogger, uiManager) {
        this.eventBus = eventBus;
        this.dataLogger = dataLogger;
        this.uiManager = uiManager;

        this.cache = {
            usgs: null,
            apod: null,
            donki: null,
            neo: null
        };

        this.lastFetch = {
            usgs: 0,
            apod: 0,
            donki: 0,
            neo: 0
        };

        this.refreshInterval = {
            usgs: 5 * 60 * 1000,
            apod: 12 * 60 * 60 * 1000,
            donki: 15 * 60 * 1000,
            neo: 60 * 60 * 1000
        };

        this.nasaApiKey = STATE.external.keys?.nasa || window.NASA_API_KEY || 'DEMO_KEY';

        this.refresh(true).catch((error) => this.handleExternalError('Initial Refresh', error));
    }

    setApiKey(key) {
        if (key) {
            this.nasaApiKey = key;
            STATE.external.keys.nasa = key;
            this.dataLogger?.logLedger('info', 'ExternalData', 'NASA API key updated');
        }
    }

    async refresh(force = false) {
        if (!STATE.flags.enableExternalData) return;

        await Promise.allSettled([
            this.fetchUSGS(force),
            this.fetchAPOD(force),
            this.fetchDONKI(force),
            this.fetchNEO(force)
        ]);
    }

    async fetchUSGS(force = false) {
        const now = Date.now();
        if (!force && now - this.lastFetch.usgs < this.refreshInterval.usgs) {
            return this.cache.usgs;
        }

        try {
            const response = await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_day.geojson');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            this.cache.usgs = data;
            this.lastFetch.usgs = now;

            STATE.external.usgs.earthquakes = data.features || [];
            STATE.external.usgs.lastUpdated = now;

            this.eventBus.publish('external:usgs', data);
            this.uiManager?.log(`USGS feed updated (${STATE.external.usgs.earthquakes.length} events)`, 'success');
            this.dataLogger?.logTelemetry('external:usgs', { count: STATE.external.usgs.earthquakes.length }, now);

            return data;
        } catch (error) {
            this.handleExternalError('USGS', error);
            return null;
        }
    }

    async fetchAPOD(force = false) {
        const now = Date.now();
        if (!force && now - this.lastFetch.apod < this.refreshInterval.apod) {
            return this.cache.apod;
        }

        try {
            const response = await fetch(`https://api.nasa.gov/planetary/apod?api_key=${this.nasaApiKey}`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            this.cache.apod = data;
            this.lastFetch.apod = now;

            STATE.external.nasa.apod = data;
            STATE.external.nasa.lastUpdated = now;

            this.eventBus.publish('external:apod', data);
            this.uiManager?.log(`NASA APOD: ${data.title || 'No title'}`, 'success');
            this.dataLogger?.logTelemetry('external:apod', { title: data.title || 'Unknown' }, now);

            return data;
        } catch (error) {
            this.handleExternalError('NASA APOD', error);
            return null;
        }
    }

    async fetchDONKI(force = false) {
        const now = Date.now();
        if (!force && now - this.lastFetch.donki < this.refreshInterval.donki) {
            return this.cache.donki;
        }

        const startDate = new Date(now - 3 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

        try {
            const response = await fetch(`https://api.nasa.gov/DONKI/notifications?startDate=${startDate}&type=all&api_key=${this.nasaApiKey}`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            this.cache.donki = data;
            this.lastFetch.donki = now;

            STATE.external.donki.events = Array.isArray(data) ? data : [];
            STATE.external.donki.lastUpdated = now;

            this.eventBus.publish('external:donki', data);
            this.uiManager?.log(`DONKI events updated (${STATE.external.donki.events.length})`, 'info');
            this.dataLogger?.logTelemetry('external:donki', { events: STATE.external.donki.events.length }, now);

            return data;
        } catch (error) {
            this.handleExternalError('NASA DONKI', error);
            return null;
        }
    }

    async fetchNEO(force = false) {
        const now = Date.now();
        if (!force && now - this.lastFetch.neo < this.refreshInterval.neo) {
            return this.cache.neo;
        }

        const today = new Date().toISOString().split('T')[0];

        try {
            const response = await fetch(`https://api.nasa.gov/neo/rest/v1/feed?start_date=${today}&end_date=${today}&api_key=${this.nasaApiKey}`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            this.cache.neo = data;
            this.lastFetch.neo = now;

            const neoList = Object.values(data.near_earth_objects || {}).flat();
            STATE.external.nasa.neo = neoList;
            STATE.external.nasa.lastUpdated = now;

            this.eventBus.publish('external:neo', neoList);
            this.uiManager?.log(`NASA NEO catalog updated (${neoList.length} objects)`, 'info');
            this.dataLogger?.logTelemetry('external:neo', { count: neoList.length }, now);

            return data;
        } catch (error) {
            this.handleExternalError('NASA NEO', error);
            return null;
        }
    }

    handleExternalError(source, error) {
        const message = error?.message || 'Unknown error';
        this.uiManager?.log(`${source} feed error: ${message}`, 'warn');
        this.dataLogger?.logLedger('warn', 'ExternalData', `${source} feed error`, { message });
        console.warn(`[ExternalDataManager] ${source} error:`, error);
    }
}

/**
 * MachineLearningCore - Wraps ml5.js COCO-SSD for live object detection.
 * SOURCE: Adapted from lostcosmo's.html + CLAUDE integration prompt (Phase 5)
 */
class MachineLearningCore {
    constructor(eventBus, uiManager, dataLogger) {
        this.eventBus = eventBus;
        this.uiManager = uiManager;
        this.dataLogger = dataLogger;

        this.videoElement = document.getElementById('video-feed');
        this.detector = null;
        this.isInitialized = false;
        this.isDetecting = false;
        this.lastDetectionTime = 0;

        if (window.ml5) {
            this.init();
        } else {
            this.uiManager?.log('ml5.js unavailable. ML detection disabled.', 'warn');
            this.dataLogger?.logLedger('warn', 'ML', 'ml5.js unavailable. MachineLearningCore disabled.');
        }
    }

    async init() {
        try {
            await new Promise((resolve, reject) => {
                try {
                    this.detector = ml5.objectDetector('cocossd', () => resolve());
                } catch (error) {
                    reject(error);
                }
            });

            this.isInitialized = true;
            this.uiManager?.log('ML Core initialized (COCO-SSD).', 'success');
            this.dataLogger?.logLedger('info', 'ML', 'MachineLearningCore initialized (COCO-SSD).');
            this.eventBus.publish('ml:status', { status: 'online' });

            this.eventBus.subscribe('video:frame', (frame) => this.detect(frame));
        } catch (error) {
            this.uiManager?.log(`ML Core initialization failed: ${error?.message || error}`, 'error');
            this.dataLogger?.logLedger('error', 'ML', 'MachineLearningCore failed to initialize', { error: error?.message });
            this.eventBus.publish('ml:status', { status: 'error', error });
        }
    }

    detect(videoElement) {
        if (!this.isInitialized || !this.detector || !videoElement) return;

        const now = performance.now();
        if (this.isDetecting || now - this.lastDetectionTime < 250) return;

        this.isDetecting = true;

        this.detector.detect(videoElement, (err, results) => {
            this.isDetecting = false;
            this.lastDetectionTime = performance.now();

            if (err) {
                console.warn('[MachineLearningCore] detection error:', err);
                return;
            }

            const detections = (results || []).map(result => ({
                label: result.label,
                confidence: result.confidence,
                x: result.x,
                y: result.y,
                width: result.width,
                height: result.height
            }));

            STATE.sensors.video.detections = detections;
            const timestamp = Date.now();

            this.eventBus.publish('sensor:videoDetection', { detections, timestamp });
            this.eventBus.publish('ml:objectsDetected', detections);

            if (detections.length > 0) {
                this.uiManager?.log(`ML detection: ${detections.map(d => d.label).join(', ')}`, 'info');
                this.dataLogger?.logTelemetry('sensor:videoDetections', {
                    labels: detections.map(d => d.label),
                    count: detections.length
                }, timestamp);
            }
        });
    }
}

// Minimal CosmicAwarenessAgent placeholder
class CosmicAwarenessAgent {
    constructor(eventBus, prng) {
        this.eventBus = eventBus;
        this.prng = prng;
        this.preferences = {
            floraBias: 0.5,
            blackHoleBias: 0.5
        };
    }

    generateSeed(overrideData = null) {
        const timestamp = Date.now();
        const seedString = `${timestamp}_${Math.random()}`;
        const seed = cyrb128(seedString);

        this.eventBus.publish('ai:seed', { seed, seedString });
        this.eventBus.publish('logger:ledger', {
            type: 'GENESIS_SEED',
            message: `Generated seed: ${seedString}`,
            seed: seed
        });

        return seed;
    }
}

// =====================================================================================
// PROCEDURAL GENERATION ENGINE (PGE) - Universe Creation
// =====================================================================================
class ProceduralGenerationEngine {
    constructor(eventBus, scene, prng) {
        this.eventBus = eventBus;
        this.scene = scene;
        this.prng = prng;
        this.G = 0.00001; // Gravitational constant

        this.activeStar = null;
        this.planets = [];
        this.blackHoles = [];
        this.particles = null;
        this.nebula = null;
        this.asteroidBelts = [];
        this.comets = [];
        this.genesisLattice = null;

        // Visibility flags by entity type
        this.visibility = {
            stars: true,
            planets: true,
            blackholes: true,
            nebula: true,
            starfield: true,
            asteroids: true,
            comets: true,
            lattice: true
        };

        this.eventBus.subscribe('pge:generate', () => this.generateUniverse());
    }

    generateUniverse() {
        this.cleanup();

        // Create central star with corona
        const starTemp = 3000 + this.prng() * 17000;
        const starColor = blackBodyToRGB(starTemp);
        const starSize = 15 + this.prng() * 10;

        const star = new THREE.Mesh(
            new THREE.SphereGeometry(starSize, 64, 64),
            new THREE.MeshBasicMaterial({ color: starColor })
        );
        star.position.set(0, 0, 0);
        star.userData = {
            isGenerated: true,
            isStar: true,
            mass: starSize * 1000,
            temperature: starTemp,
            type: 'star'
        };

        // Initialize 12D CST state
        initialize12DState(star, 'star', {
            mass: starSize * 1000,
            radius: starSize,
            velocity: new THREE.Vector3(0, 0, 0)
        });

        this.scene.add(star);
        this.activeStar = star;

        // Add star corona (glow/pulsation)
        this.createStarCorona(star, starColor, starTemp, starSize);

        // Add star light
        const starLight = new THREE.PointLight(starColor, 2, 10000, 2);
        starLight.position.copy(star.position);
        this.scene.add(starLight);

        // Generate planets with atmospheres and optional rings
        const planetCount = 3 + Math.floor(this.prng() * 7);
        for (let i = 0; i < planetCount; i++) {
            this.createPlanet(starSize, i);
        }

        // Create nebula (volumetric fog)
        this.createNebula(starColor);

        // Create starfield background
        this.createStarfield(10000, 50000, 2);

        // Add asteroid belts (between some planets)
        if (this.planets.length > 2) {
            this.createAsteroidBelt(this.planets[1].position.length(), 50, 200);
        }

        // Add occasional black hole
        if (this.prng() > 0.7) {
            this.createBlackHole(new THREE.Vector3(
                (this.prng() - 0.5) * 3000,
                (this.prng() - 0.5) * 1000,
                (this.prng() - 0.5) * 3000
            ));
        }

        // Add comets (1-3 comets)
        const cometCount = 1 + Math.floor(this.prng() * 3);
        for (let i = 0; i < cometCount; i++) {
            this.createComet();
        }

        // Create Genesis Lattice (cosmic scaffold)
        this.createGenesisLattice();

        // Optional: Load NASA Earth texture on one random planet
        if (this.planets.length > 0 && window.NASA_API_KEY && this.prng() > 0.5) {
            const earthPlanetIndex = Math.floor(this.prng() * this.planets.length);
            this.loadEarthTexture(this.planets[earthPlanetIndex]).catch(err => {
                console.warn('Earth texture loading failed:', err);
            });
        }

        this.eventBus.publish('logger:ledger', {
            message: `Generated universe with ${planetCount} planets, ${this.asteroidBelts.length} asteroid belts, ${this.blackHoles.length} black holes, ${cometCount} comets`,
            starTemp,
            planetCount,
            asteroidBelts: this.asteroidBelts.length,
            blackHoles: this.blackHoles.length,
            comets: cometCount
        });
    }

    createStarCorona(star, color, temp, size) {
        const tNorm = (temp - 2000) / 18000; // Normalize temperature
        const coronaGeo = new THREE.SphereGeometry(size * 1.3, 64, 64);
        const coronaMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                baseColor: { value: color },
                intensity: { value: 0.6 + 0.8 * tNorm },
                noiseScale: { value: 1.5 + 2.5 * tNorm }
            },
            vertexShader: `
                varying vec3 vPos;
                varying vec3 vNormal;
                void main() {
                    vPos = position;
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vPos;
                varying vec3 vNormal;
                uniform vec3 baseColor;
                uniform float intensity;
                uniform float noiseScale;
                uniform float time;

                float noise(vec3 p) {
                    return fract(sin(dot(p, vec3(12.9898, 78.233, 151.7182))) * 43758.5453);
                }

                float fbm(vec3 p) {
                    float f = 0.0;
                    f += 0.5000 * noise(p);
                    p *= 2.02;
                    f += 0.2500 * noise(p + time * 0.05);
                    p *= 2.03;
                    f += 0.1250 * noise(p - time * 0.04);
                    return f;
                }

                void main() {
                    float rim = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 3.0);
                    float n = fbm(vPos * noiseScale);
                    vec3 c = baseColor * (0.6 + 0.6 * n) * intensity;
                    gl_FragColor = vec4(c, rim * (0.4 + 0.6 * n));
                }
            `,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            side: THREE.BackSide
        });
        const corona = new THREE.Mesh(coronaGeo, coronaMat);
        corona.userData = { isGenerated: true, isStarCorona: true, type: 'corona' };
        star.add(corona);
        star.userData.corona = corona;
    }

    createPlanet(starSize, index) {
        const planetSize = 2 + this.prng() * 8;
        const distance = starSize * 10 + index * (100 + this.prng() * 100);
        const angle = this.prng() * Math.PI * 2;

        const planet = new THREE.Mesh(
            new THREE.SphereGeometry(planetSize, 32, 32),
            new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(this.prng(), 0.6, 0.5),
                roughness: this.prng() * 0.5 + 0.5
            })
        );

        planet.position.set(
            Math.cos(angle) * distance,
            (this.prng() - 0.5) * 50,
            Math.sin(angle) * distance
        );

        // Calculate orbital velocity
        const orbitSpeed = Math.sqrt((this.G * this.activeStar.userData.mass) / distance) * 0.01;
        const velocity = new THREE.Vector3(
            -Math.sin(angle) * orbitSpeed,
            0,
            Math.cos(angle) * orbitSpeed
        );

        planet.userData = {
            isGenerated: true,
            isPlanet: true,
            mass: planetSize * 100,
            velocity: velocity,
            type: 'planet'
        };

        // Initialize 12D CST state
        initialize12DState(planet, 'planet', {
            mass: planetSize * 100,
            radius: planetSize,
            velocity: velocity
        });

        this.scene.add(planet);
        this.planets.push(planet);

        // Add atmosphere to some planets
        if (this.prng() > 0.4) {
            this.createPlanetAtmosphere(planet, planetSize);
        }

        // Add rings to some planets
        if (this.prng() > 0.7 && planetSize > 5) {
            this.createPlanetaryRings(planet, planetSize);
        }
    }

    createPlanetAtmosphere(planet, planetSize) {
        const atmosphereMat = new THREE.ShaderMaterial({
            uniforms: {
                baseColor: { value: planet.material.color.clone() },
                intensity: { value: 0.5 }
            },
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vNormal;
                uniform vec3 baseColor;
                uniform float intensity;
                void main() {
                    float rim = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.5);
                    gl_FragColor = vec4(baseColor * intensity, rim * 0.6);
                }
            `,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            transparent: true,
            depthWrite: false
        });
        const atmosphere = new THREE.Mesh(
            new THREE.SphereGeometry(planetSize * 1.1, 32, 32),
            atmosphereMat
        );
        atmosphere.userData = { isGenerated: true, isAtmosphere: true, type: 'atmosphere' };
        planet.add(atmosphere);
    }

    createPlanetaryRings(planet, planetSize) {
        const ringGeo = new THREE.RingGeometry(planetSize * 1.5, planetSize * 2.5, 64);
        const ringMat = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(this.prng(), 0.3, 0.7),
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6
        });
        const rings = new THREE.Mesh(ringGeo, ringMat);
        rings.rotation.x = Math.PI / 2 + (this.prng() - 0.5) * 0.3;
        rings.userData = { isGenerated: true, isPlanetRing: true, type: 'rings' };
        planet.add(rings);
    }

    createNebula(baseColor) {
        const nebulaMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                baseColor: { value: baseColor },
                noiseScale: { value: 2.0 + this.prng() * 3.0 },
                density: { value: 0.3 + this.prng() * 0.4 }
            },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 baseColor;
                uniform float noiseScale;
                uniform float density;
                varying vec3 vPosition;

                vec3 hash(vec3 p) {
                    p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),
                             dot(p, vec3(269.5, 183.3, 246.1)),
                             dot(p, vec3(113.5, 271.9, 124.6)));
                    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
                }

                float noise(in vec3 p) {
                    vec3 i = floor(p), f = fract(p), u = f * f * (3.0 - 2.0 * f);
                    return mix(mix(mix(dot(hash(i + vec3(0,0,0)), f - vec3(0,0,0)),
                                       dot(hash(i + vec3(1,0,0)), f - vec3(1,0,0)), u.x),
                                   mix(dot(hash(i + vec3(0,1,0)), f - vec3(0,1,0)),
                                       dot(hash(i + vec3(1,1,0)), f - vec3(1,1,0)), u.x), u.y),
                               mix(mix(dot(hash(i + vec3(0,0,1)), f - vec3(0,0,1)),
                                       dot(hash(i + vec3(1,0,1)), f - vec3(1,0,1)), u.x),
                                   mix(dot(hash(i + vec3(0,1,1)), f - vec3(0,1,1)),
                                       dot(hash(i + vec3(1,1,1)), f - vec3(1,1,1)), u.x), u.y), u.z);
                }

                float fbm(vec3 p) {
                    float f = 0.0;
                    f += 0.5000 * noise(p); p *= 2.02;
                    f += 0.2500 * noise(p); p *= 2.03;
                    f += 0.1250 * noise(p);
                    return f;
                }

                void main() {
                    vec3 pos = vPosition / (8000.0 / noiseScale);
                    pos.x += time * 0.01;
                    float noiseVal = fbm(pos);
                    gl_FragColor = vec4(baseColor * noiseVal * 2.0, noiseVal * density);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.BackSide
        });
        const nebula = new THREE.Mesh(new THREE.SphereGeometry(8000, 32, 32), nebulaMaterial);
        nebula.userData = { isGenerated: true, isNebula: true, type: 'nebula' };
        this.scene.add(nebula);
        this.nebula = nebula;
    }

    createStarfield(count, spread, size) {
        const positions = [];
        const colors = [];
        for (let i = 0; i < count; i++) {
            positions.push(
                THREE.MathUtils.randFloatSpread(spread),
                THREE.MathUtils.randFloatSpread(spread),
                THREE.MathUtils.randFloatSpread(spread)
            );
            const c = new THREE.Color().setHSL(this.prng(), 0.2, 0.8 + this.prng() * 0.2);
            colors.push(c.r, c.g, c.b);
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({
            size,
            vertexColors: true,
            transparent: true,
            opacity: 0.8
        });
        this.particles = new THREE.Points(geometry, material);
        this.particles.userData = { isGenerated: true, type: 'starfield' };
        this.scene.add(this.particles);
    }

    createAsteroidBelt(radius, count, spread) {
        const asteroids = [];
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const r = radius + (this.prng() - 0.5) * spread;
            const size = 0.5 + this.prng() * 2;

            const asteroid = new THREE.Mesh(
                new THREE.DodecahedronGeometry(size, 0),
                new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 })
            );
            asteroid.position.set(
                Math.cos(angle) * r,
                (this.prng() - 0.5) * 20,
                Math.sin(angle) * r
            );
            asteroid.userData = {
                isGenerated: true,
                isAsteroid: true,
                type: 'asteroid',
                velocity: new THREE.Vector3(
                    -Math.sin(angle) * 0.1,
                    0,
                    Math.cos(angle) * 0.1
                )
            };
            this.scene.add(asteroid);
            asteroids.push(asteroid);
        }
        this.asteroidBelts.push(asteroids);
    }

    createBlackHole(position) {
        const bhSize = 8 + this.prng() * 12;
        const blackHole = new THREE.Mesh(
            new THREE.SphereGeometry(bhSize, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        blackHole.position.copy(position);
        blackHole.userData = {
            isGenerated: true,
            isBlackHole: true,
            type: 'blackhole',
            mass: bhSize * 10000
        };

        initialize12DState(blackHole, 'blackhole', {
            mass: bhSize * 10000,
            radius: bhSize,
            velocity: new THREE.Vector3(0, 0, 0)
        });

        // Create accretion disk
        const diskGeo = new THREE.RingGeometry(bhSize * 1.5, bhSize * 4, 64);
        const diskMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                innerRadius: { value: bhSize * 1.5 },
                outerRadius: { value: bhSize * 4 }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vPosition;
                void main() {
                    vUv = uv;
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform float innerRadius;
                uniform float outerRadius;
                varying vec2 vUv;
                varying vec3 vPosition;

                void main() {
                    float dist = length(vPosition);
                    float normDist = (dist - innerRadius) / (outerRadius - innerRadius);

                    // Animated turbulence
                    float angle = atan(vPosition.y, vPosition.x) + time * 0.5;
                    float turbulence = sin(angle * 8.0 + time) * 0.5 + 0.5;

                    // Color gradient: orange -> purple
                    vec3 innerColor = vec3(1.0, 0.4, 0.1);
                    vec3 outerColor = vec3(0.5, 0.1, 0.8);
                    vec3 color = mix(innerColor, outerColor, normDist) * (0.8 + turbulence * 0.4);

                    float alpha = (1.0 - normDist) * 0.8;
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            side: THREE.DoubleSide,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const disk = new THREE.Mesh(diskGeo, diskMat);
        disk.rotation.x = Math.PI / 2;
        disk.userData = { isGenerated: true, isAccretionDisk: true, type: 'accretion_disk' };
        blackHole.add(disk);
        blackHole.userData.accretionDisk = disk;

        this.scene.add(blackHole);
        this.blackHoles.push(blackHole);
    }

    createGenesisLattice() {
        const latticeGroup = new THREE.Group();
        const gridSize = 20;
        const spacing = 500;
        const material = new THREE.LineBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.15
        });

        for (let i = -gridSize; i <= gridSize; i++) {
            // X-axis lines
            const geomX = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(i * spacing, -gridSize * spacing, -gridSize * spacing),
                new THREE.Vector3(i * spacing, gridSize * spacing, gridSize * spacing)
            ]);
            latticeGroup.add(new THREE.Line(geomX, material));

            // Y-axis lines
            const geomY = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-gridSize * spacing, i * spacing, -gridSize * spacing),
                new THREE.Vector3(gridSize * spacing, i * spacing, gridSize * spacing)
            ]);
            latticeGroup.add(new THREE.Line(geomY, material));

            // Z-axis lines
            const geomZ = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-gridSize * spacing, -gridSize * spacing, i * spacing),
                new THREE.Vector3(gridSize * spacing, gridSize * spacing, i * spacing)
            ]);
            latticeGroup.add(new THREE.Line(geomZ, material));
        }

        latticeGroup.userData = { isGenerated: true, isGenesisLattice: true, type: 'lattice' };
        this.scene.add(latticeGroup);
        this.genesisLattice = latticeGroup;
    }

    updatePhysics(delta) {
        // Update animated shaders
        if (this.activeStar && this.activeStar.userData.corona) {
            this.activeStar.userData.corona.material.uniforms.time.value += delta;
        }

        if (this.nebula) {
            this.nebula.material.uniforms.time.value += delta;
        }

        this.blackHoles.forEach(bh => {
            if (bh.userData.accretionDisk) {
                bh.userData.accretionDisk.material.uniforms.time.value += delta;
            }
        });

        // Simple gravitational physics for planets
        if (!this.activeStar) return;

        const allBodies = [this.activeStar, ...this.planets, ...this.blackHoles];

        this.planets.forEach(planet => {
            let totalForce = new THREE.Vector3();

            allBodies.forEach(body => {
                if (body === planet || !body) return;

                const distVec = body.position.clone().sub(planet.position);
                const distSq = distVec.lengthSq();
                if (distSq < 1) return;

                const forceMag = (this.G * body.userData.mass * planet.userData.mass) / distSq;
                const force = distVec.normalize().multiplyScalar(forceMag);
                totalForce.add(force);
            });

            const acceleration = totalForce.divideScalar(planet.userData.mass);
            planet.userData.velocity.add(acceleration.multiplyScalar(delta));
            planet.position.add(planet.userData.velocity.clone().multiplyScalar(delta));

            // Rotate planets
            planet.rotation.y += delta * 0.1;
        });

        // Update asteroids
        this.asteroidBelts.forEach(belt => {
            belt.forEach(asteroid => {
                asteroid.position.add(asteroid.userData.velocity);
                asteroid.rotation.x += delta * 0.5;
                asteroid.rotation.y += delta * 0.3;
            });
        });

        // Update comets
        this.updateComets(delta);
    }

    cleanup() {
        const toRemove = [];
        this.scene.traverse(child => {
            if (child.userData && child.userData.isGenerated) {
                toRemove.push(child);
            }
        });

        toRemove.forEach(child => {
            if (child.parent) child.parent.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(m => m.dispose && m.dispose());
                } else if (child.material.dispose) {
                    child.material.dispose();
                }
            }
        });

        this.planets = [];
        this.blackHoles = [];
        this.asteroidBelts = [];
        this.comets = [];
        this.activeStar = null;
        this.nebula = null;
        this.genesisLattice = null;
    }

    /**
     * Get all entities for CST computation with full 12D state
     */
    getEntities() {
        const entities = [];
        if (this.activeStar) entities.push(this.activeStar);
        entities.push(...this.planets);
        entities.push(...this.blackHoles);
        entities.push(...this.comets);
        this.asteroidBelts.forEach(belt => entities.push(...belt));
        if (this.particles && this.particles.userData.isGenerated) {
            entities.push(this.particles);
        }
        return entities;
    }

    /**
     * Set visibility by entity type
     */
    setVisible(entityType, visible) {
        if (entityType === undefined) {
            // Legacy support: set all visible
            this.setVisible('stars', visible);
            this.setVisible('planets', visible);
            this.setVisible('blackholes', visible);
            this.setVisible('nebula', visible);
            this.setVisible('starfield', visible);
            this.setVisible('asteroids', visible);
            this.setVisible('comets', visible);
            this.setVisible('lattice', visible);
            return;
        }

        this.visibility[entityType] = visible;

        switch(entityType) {
            case 'stars':
                if (this.activeStar) this.activeStar.visible = visible;
                break;
            case 'planets':
                this.planets.forEach(p => p.visible = visible);
                break;
            case 'blackholes':
                this.blackHoles.forEach(bh => bh.visible = visible);
                break;
            case 'nebula':
                if (this.nebula) this.nebula.visible = visible;
                break;
            case 'starfield':
                if (this.particles) this.particles.visible = visible;
                break;
            case 'asteroids':
                this.asteroidBelts.forEach(belt => belt.forEach(a => a.visible = visible));
                break;
            case 'comets':
                this.comets.forEach(c => c.visible = visible);
                break;
            case 'lattice':
                if (this.genesisLattice) this.genesisLattice.visible = visible;
                break;
        }
    }

    /**
     * Create Comet with Particle Trail
     */
    createComet(startPosition = null) {
        const cometSize = 1 + this.prng() * 2;

        // Random elliptical orbit if no start position provided
        if (!startPosition) {
            const angle = this.prng() * Math.PI * 2;
            const distance = 1000 + this.prng() * 2000;
            startPosition = new THREE.Vector3(
                Math.cos(angle) * distance,
                (this.prng() - 0.5) * 500,
                Math.sin(angle) * distance
            );
        }

        // Comet nucleus
        const cometNucleus = new THREE.Mesh(
            new THREE.SphereGeometry(cometSize, 16, 16),
            new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.9,
                emissive: 0x444444
            })
        );
        cometNucleus.position.copy(startPosition);

        // Calculate velocity toward star
        const directionToStar = new THREE.Vector3(0, 0, 0).sub(startPosition).normalize();
        const speed = 5 + this.prng() * 10;
        const velocity = directionToStar.multiplyScalar(speed);

        cometNucleus.userData = {
            isGenerated: true,
            isComet: true,
            type: 'comet',
            velocity: velocity,
            mass: cometSize * 10,
            trailPositions: [],
            maxTrailLength: 100,
            trailUpdateCounter: 0
        };

        // Initialize 12D CST state
        initialize12DState(cometNucleus, 'comet', {
            mass: cometSize * 10,
            radius: cometSize,
            velocity: velocity
        });

        // Create trail particle system
        const trailGeometry = new THREE.BufferGeometry();
        const maxTrailParticles = 100;
        const trailPositions = new Float32Array(maxTrailParticles * 3);
        const trailSizes = new Float32Array(maxTrailParticles);
        const trailOpacities = new Float32Array(maxTrailParticles);

        for (let i = 0; i < maxTrailParticles; i++) {
            trailPositions[i * 3] = startPosition.x;
            trailPositions[i * 3 + 1] = startPosition.y;
            trailPositions[i * 3 + 2] = startPosition.z;
            trailSizes[i] = 0;
            trailOpacities[i] = 0;
        }

        trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
        trailGeometry.setAttribute('size', new THREE.BufferAttribute(trailSizes, 1));
        trailGeometry.setAttribute('alpha', new THREE.BufferAttribute(trailOpacities, 1));

        const trailMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0x00ccff) },
                time: { value: 0.0 }
            },
            vertexShader: `
                attribute float size;
                attribute float alpha;
                varying float vAlpha;
                void main() {
                    vAlpha = alpha;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform float time;
                varying float vAlpha;
                void main() {
                    float dist = length(gl_PointCoord - vec2(0.5));
                    if (dist > 0.5) discard;
                    float glow = 1.0 - (dist * 2.0);
                    vec3 glowColor = color * (0.8 + 0.2 * sin(time * 2.0));
                    gl_FragColor = vec4(glowColor, vAlpha * glow * 0.8);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const trailParticles = new THREE.Points(trailGeometry, trailMaterial);
        trailParticles.userData = { isGenerated: true, isCometTrail: true, type: 'comet_trail' };
        cometNucleus.add(trailParticles);
        cometNucleus.userData.trail = trailParticles;

        this.scene.add(cometNucleus);
        this.comets.push(cometNucleus);

        return cometNucleus;
    }

    /**
     * Update comet physics and trails
     */
    updateComets(delta) {
        this.comets.forEach(comet => {
            if (!comet.userData.isComet) return;

            // Update position with velocity
            comet.position.add(comet.userData.velocity.clone().multiplyScalar(delta));

            // Apply gravity from star
            if (this.activeStar) {
                const distVec = this.activeStar.position.clone().sub(comet.position);
                const distSq = distVec.lengthSq();
                if (distSq > 1) {
                    const forceMag = (this.G * this.activeStar.userData.mass * comet.userData.mass) / distSq;
                    const force = distVec.normalize().multiplyScalar(forceMag);
                    const acceleration = force.divideScalar(comet.userData.mass);
                    comet.userData.velocity.add(acceleration.multiplyScalar(delta));
                }
            }

            // Update trail every few frames
            comet.userData.trailUpdateCounter++;
            if (comet.userData.trailUpdateCounter >= 2) {
                comet.userData.trailUpdateCounter = 0;
                this.updateCometTrail(comet);
            }

            // Update trail shader time
            if (comet.userData.trail) {
                comet.userData.trail.material.uniforms.time.value += delta;
            }

            // Rotate comet
            comet.rotation.x += delta * 0.5;
            comet.rotation.y += delta * 0.3;

            // Remove if too far from origin
            if (comet.position.length() > 50000) {
                this.scene.remove(comet);
                const index = this.comets.indexOf(comet);
                if (index > -1) this.comets.splice(index, 1);
            }
        });
    }

    /**
     * Update comet trail positions
     */
    updateCometTrail(comet) {
        if (!comet.userData.trail) return;

        const trail = comet.userData.trail;
        const positions = trail.geometry.attributes.position.array;
        const sizes = trail.geometry.attributes.size.array;
        const alphas = trail.geometry.attributes.alpha.array;
        const maxLength = comet.userData.maxTrailLength;

        // Shift all positions back
        for (let i = maxLength - 1; i > 0; i--) {
            positions[i * 3] = positions[(i - 1) * 3];
            positions[i * 3 + 1] = positions[(i - 1) * 3 + 1];
            positions[i * 3 + 2] = positions[(i - 1) * 3 + 2];
            sizes[i] = sizes[i - 1] * 0.98;
            alphas[i] = alphas[i - 1] * 0.95;
        }

        // Add new position at front (world position)
        const worldPos = new THREE.Vector3();
        comet.getWorldPosition(worldPos);
        positions[0] = worldPos.x;
        positions[1] = worldPos.y;
        positions[2] = worldPos.z;
        sizes[0] = 10 + comet.userData.velocity.length() * 0.5;
        alphas[0] = 1.0;

        trail.geometry.attributes.position.needsUpdate = true;
        trail.geometry.attributes.size.needsUpdate = true;
        trail.geometry.attributes.alpha.needsUpdate = true;
    }

    /**
     * Load NASA Earth texture on a planet (requires NASA API)
     */
    async loadEarthTexture(planet) {
        const textureLoader = new THREE.TextureLoader();

        // NASA Blue Marble: Next Generation Earth texture
        // Using a public URL for NASA Earth imagery
        const earthTextureUrl = 'https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg';

        try {
            const texture = await textureLoader.loadAsync(earthTextureUrl);

            // Apply Earth texture to planet
            planet.material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.7,
                metalness: 0.1
            });

            // Add Earth-specific atmosphere
            const atmosphereMat = new THREE.ShaderMaterial({
                uniforms: {
                    baseColor: { value: new THREE.Color(0x4488ff) },
                    intensity: { value: 0.7 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    uniform vec3 baseColor;
                    uniform float intensity;
                    void main() {
                        float rim = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.5);
                        gl_FragColor = vec4(baseColor * intensity, rim * 0.7);
                    }
                `,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                transparent: true,
                depthWrite: false
            });

            const atmosphere = new THREE.Mesh(
                new THREE.SphereGeometry(planet.geometry.parameters.radius * 1.05, 32, 32),
                atmosphereMat
            );
            atmosphere.userData = { isGenerated: true, isAtmosphere: true, type: 'earth_atmosphere' };
            planet.add(atmosphere);

            planet.userData.isEarth = true;
            planet.userData.earthTexture = texture;

            this.eventBus.publish('logger:ledger', {
                message: 'NASA Earth texture loaded successfully',
                planet: planet.uuid
            });

            return true;
        } catch (error) {
            console.error('Failed to load Earth texture:', error);
            this.eventBus.publish('logger:ledger', {
                message: 'Failed to load NASA Earth texture - using procedural texture',
                error: error.message
            });
            return false;
        }
    }
}

// =====================================================================================
// QUANTUM EVENT MANAGER (QEM) - Soul Dust Particles with Genealogy & Coalescence
// =====================================================================================
class QuantumEventManager {
    constructor(eventBus, scene) {
        this.eventBus = eventBus;
        this.scene = scene;
        this.maxParticles = 10000;
        this.particleCount = 0;

        // Soul Dust registry with full 12D state
        this.soulDust = new Map(); // uuid -> particle data

        // Genealogy tracking
        this.genealogyTree = new Map(); // uuid -> { parent, children[] }

        // Coalescence parameters
        this.PSI_CRITICAL = 2.5; // Critical œà for coalescence
        this.MERGE_DISTANCE = 5.0; // Proximity threshold

        // Create instanced particle system
        this.createParticleSystem();

        // Subscribe to audio events for spawning
        this.eventBus.subscribe('audio:update', (data) => this.onAudioUpdate(data));

        this.time = 0;
        this.telemetryLog = [];
    }

    createParticleSystem() {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(this.maxParticles * 3);
        const colors = new Float32Array(this.maxParticles * 3);
        const sizes = new Float32Array(this.maxParticles);
        const energies = new Float32Array(this.maxParticles);
        const ages = new Float32Array(this.maxParticles);

        // Initialize with inactive particles
        for (let i = 0; i < this.maxParticles; i++) {
            const i3 = i * 3;
            positions[i3] = 0;
            positions[i3 + 1] = 0;
            positions[i3 + 2] = 0;
            colors[i3] = 0;
            colors[i3 + 1] = 0;
            colors[i3 + 2] = 0;
            sizes[i] = 0;
            energies[i] = 0;
            ages[i] = 0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('energy', new THREE.BufferAttribute(energies, 1));
        geometry.setAttribute('age', new THREE.BufferAttribute(ages, 1));

        const material = new THREE.PointsMaterial({
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });

        // Custom shader for size based on energy
        material.onBeforeCompile = (shader) => {
            // Add attribute declarations at the top of vertex shader
            shader.vertexShader = shader.vertexShader.replace(
                'void main() {',
                `
                attribute float energy;
                attribute float age;
                void main() {
                `
            );
            // Replace point size calculation
            shader.vertexShader = shader.vertexShader.replace(
                'gl_PointSize = size;',
                'gl_PointSize = size * (0.5 + energy * 0.5) * (1.0 - age * 0.3);'
            );
        };

        this.particleMesh = new THREE.Points(geometry, material);
        this.particleMesh.frustumCulled = false;
        this.scene.add(this.particleMesh);
    }

    onAudioUpdate(audioData) {
        // Spawn Soul Dust from audio spectral input
        if (!audioData || !audioData.spectralBands) return;

        const { spectralBands, avgFreq } = audioData;

        // Spawn particles based on spectral energy
        spectralBands.forEach((bandEnergy, bandIndex) => {
            if (bandEnergy > 128 && Math.random() < bandEnergy / 512) {
                // Calculate frequency for this band
                const freq = 20 + (bandIndex / spectralBands.length) * 19980;

                // Spawn near camera or audio source
                const angle = Math.random() * Math.PI * 2;
                const radius = 50 + Math.random() * 200;
                const position = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 100,
                    Math.sin(angle) * radius
                );

                this.spawnSoulDust(position, freq, bandEnergy / 255, null);
            }
        });
    }

    spawnSoulDust(position, frequency, energy = 1.0, parentUUID = null) {
        if (this.particleCount >= this.maxParticles) {
            // Recycle oldest particle
            this.recycleOldestParticle();
        }

        const uuid = generateUUID();
        const index = this.particleCount;
        const i3 = index * 3;

        // Calculate color from frequency
        const color = freqToRgb(frequency);

        // Update geometry attributes
        const positions = this.particleMesh.geometry.attributes.position.array;
        const colors = this.particleMesh.geometry.attributes.color.array;
        const sizes = this.particleMesh.geometry.attributes.size.array;
        const energies = this.particleMesh.geometry.attributes.energy.array;
        const ages = this.particleMesh.geometry.attributes.age.array;

        positions[i3] = position.x;
        positions[i3 + 1] = position.y;
        positions[i3 + 2] = position.z;
        colors[i3] = color.r;
        colors[i3 + 1] = color.g;
        colors[i3 + 2] = color.b;
        sizes[index] = 3 + energy * 4;
        energies[index] = energy;
        ages[index] = 0;

        // Calculate wavelength from frequency
        const wavelength = (299792458 / frequency) * 1e9; // nm

        // Initialize full 12D state
        const h12 = new Float32Array(12);
        h12[0] = position.x / 100; // Spatial (normalized)
        h12[1] = position.y / 100;
        h12[2] = position.z / 100;
        h12[3] = (Math.random() - 0.5) * 0.1; // Velocity
        h12[4] = (Math.random() - 0.5) * 0.1;
        h12[5] = (Math.random() - 0.5) * 0.1;
        h12[6] = 0; // Temporal (age)
        h12[7] = frequency / 20000; // Audio (normalized freq)
        h12[8] = Math.random(); // Chaos
        h12[9] = (frequency - 20) / 19980; // Spectral
        h12[10] = energy; // Energy
        h12[11] = 0; // Field coupling

        // Store particle data
        const particleData = {
            uuid,
            index,
            position: position.clone(),
            velocity: new THREE.Vector3(h12[3], h12[4], h12[5]),
            frequency,
            wavelength,
            energy,
            age: 0,
            maxAge: 10 + Math.random() * 20,
            h12,
            x12: new Float32Array(12),
            m12: new Float32Array(12),
            mass: energy * 0.1,
            radius: sizes[index],
            connectivity: 0,
            psi: 0,
            parentUUID
        };

        this.soulDust.set(uuid, particleData);
        this.particleCount++;

        // Update genealogy
        this.genealogyTree.set(uuid, { parent: parentUUID, children: [] });
        if (parentUUID && this.genealogyTree.has(parentUUID)) {
            this.genealogyTree.get(parentUUID).children.push(uuid);
        }

        // Log telemetry
        this.logTelemetry({
            event: 'birth',
            uuid,
            frequency,
            wavelength,
            energy,
            parentUUID,
            timestamp: Date.now()
        });

        return uuid;
    }

    recycleOldestParticle() {
        // Find and remove oldest particle
        let oldest = null;
        let maxAge = -1;

        for (const [uuid, data] of this.soulDust.entries()) {
            if (data.age > maxAge) {
                maxAge = data.age;
                oldest = uuid;
            }
        }

        if (oldest) {
            this.removeSoulDust(oldest, 'decay');
        }
    }

    removeSoulDust(uuid, reason = 'decay') {
        const particle = this.soulDust.get(uuid);
        if (!particle) return;

        // Log telemetry
        this.logTelemetry({
            event: reason,
            uuid,
            age: particle.age,
            energy: particle.energy,
            timestamp: Date.now()
        });

        // Clear geometry data
        const i3 = particle.index * 3;
        const positions = this.particleMesh.geometry.attributes.position.array;
        const sizes = this.particleMesh.geometry.attributes.size.array;

        positions[i3] = 0;
        positions[i3 + 1] = 0;
        positions[i3 + 2] = 0;
        sizes[particle.index] = 0;

        // Remove from registry
        this.soulDust.delete(uuid);
        this.genealogyTree.delete(uuid);
    }

    checkCoalescence() {
        // Check for proximity-based merging
        const particles = Array.from(this.soulDust.values());

        for (let i = 0; i < particles.length; i++) {
            for (let j = i + 1; j < particles.length; j++) {
                const p1 = particles[i];
                const p2 = particles[j];

                const dist = p1.position.distanceTo(p2.position);

                if (dist < this.MERGE_DISTANCE) {
                    // Calculate cluster œà
                    const psiCluster = p1.psi + p2.psi;

                    if (psiCluster > this.PSI_CRITICAL) {
                        // Merge particles
                        this.mergeParticles(p1.uuid, p2.uuid);
                        break;
                    }
                }
            }
        }
    }

    mergeParticles(uuid1, uuid2) {
        const p1 = this.soulDust.get(uuid1);
        const p2 = this.soulDust.get(uuid2);

        if (!p1 || !p2) return;

        // Create new particle at midpoint with combined properties
        const newPos = p1.position.clone().add(p2.position).multiplyScalar(0.5);
        const newFreq = (p1.frequency + p2.frequency) / 2;
        const newEnergy = Math.min(1.0, p1.energy + p2.energy);

        // Spawn child particle
        const childUUID = this.spawnSoulDust(newPos, newFreq, newEnergy, uuid1);

        // Log coalescence
        this.logTelemetry({
            event: 'coalescence',
            parent1: uuid1,
            parent2: uuid2,
            child: childUUID,
            energyCombined: newEnergy,
            timestamp: Date.now()
        });

        // Remove parent particles
        this.removeSoulDust(uuid1, 'merged');
        this.removeSoulDust(uuid2, 'merged');
    }

    update(delta) {
        this.time += delta;

        const positions = this.particleMesh.geometry.attributes.position.array;
        const colors = this.particleMesh.geometry.attributes.color.array;
        const energies = this.particleMesh.geometry.attributes.energy.array;
        const ages = this.particleMesh.geometry.attributes.age.array;

        // Update each soul dust particle
        for (const [uuid, particle] of this.soulDust.entries()) {
            const i3 = particle.index * 3;

            // Update age
            particle.age += delta;
            const ageRatio = particle.age / particle.maxAge;

            // Decay old particles
            if (ageRatio >= 1.0) {
                this.removeSoulDust(uuid, 'decay');
                continue;
            }

            // Swirl dynamics driven by CST œà potential
            const swirlStrength = STATE.params.lambda * 0.5;
            const x = positions[i3];
            const y = positions[i3 + 1];
            const z = positions[i3 + 2];

            // Circular motion with œà influence
            const radius = Math.sqrt(x * x + z * z);
            const angle = this.time * (0.1 + particle.energy * 0.2) + (x + z) * 0.001;
            const psiInfluence = Math.sin(particle.psi * 10 + this.time) * swirlStrength;

            particle.velocity.x = Math.cos(angle) * radius * 0.001 + psiInfluence;
            particle.velocity.z = Math.sin(angle) * radius * 0.001 + psiInfluence;
            particle.velocity.y += Math.sin(this.time + particle.h12[7] * 10) * 0.01;

            // Update position
            particle.position.add(particle.velocity);
            positions[i3] = particle.position.x;
            positions[i3 + 1] = particle.position.y;
            positions[i3 + 2] = particle.position.z;

            // Update 12D state
            particle.h12[0] = particle.position.x / 100;
            particle.h12[1] = particle.position.y / 100;
            particle.h12[2] = particle.position.z / 100;
            particle.h12[3] = particle.velocity.x;
            particle.h12[4] = particle.velocity.y;
            particle.h12[5] = particle.velocity.z;
            particle.h12[6] = ageRatio;

            // Fade out with age
            const fadeOut = 1.0 - ageRatio * 0.5;
            const color = freqToRgb(particle.frequency);
            colors[i3] = color.r * fadeOut;
            colors[i3 + 1] = color.g * fadeOut;
            colors[i3 + 2] = color.b * fadeOut;

            energies[particle.index] = particle.energy * fadeOut;
        }

        // Mark geometry for update
        this.particleMesh.geometry.attributes.position.needsUpdate = true;
        this.particleMesh.geometry.attributes.color.needsUpdate = true;
        this.particleMesh.geometry.attributes.energy.needsUpdate = true;

        // Check coalescence every few frames
        if (Math.random() < 0.1) {
            this.checkCoalescence();
        }
    }

    logTelemetry(data) {
        this.telemetryLog.push(data);

        // Keep last 1000 entries
        if (this.telemetryLog.length > 1000) {
            this.telemetryLog.shift();
        }

        // Publish to EventBus for UI display
        this.eventBus.publish('logger:telemetry', data);
    }

    getTelemetryLog() {
        return this.telemetryLog;
    }

    getGenealogyTree(uuid) {
        return this.genealogyTree.get(uuid);
    }

    /**
     * Get all entities for CST computation with full 12D state
     */
    getEntities() {
        // Return individual soul dust particles with their 12D state
        const entities = [];
        for (const particle of this.soulDust.values()) {
            entities.push({
                position: particle.position,
                userData: {
                    uuid: particle.uuid,
                    h12: particle.h12,
                    x12: particle.x12,
                    m12: particle.m12,
                    mass: particle.mass,
                    radius: particle.radius,
                    connectivity: particle.connectivity,
                    type: 'soul_dust'
                }
            });
        }
        return entities;
    }

    /**
     * Set visibility for mode switching
     */
    setVisible(visible) {
        if (this.particleMesh) {
            this.particleMesh.visible = visible;
        }
    }
}

// =====================================================================================
// MAIN APPLICATION CLASS
// =====================================================================================
class Application {
    constructor() {
        this.eventBus = new EventBus();
        this.dataLogger = new DataLogger(this.eventBus);
        this.uiManager = new UIManager(this.eventBus);

        // Initialize Three.js scene
        this.initThreeJS();

        // Initialize managers
        this.sensory = new SensoryInputManager(this.eventBus, this.uiManager, this.dataLogger);
        this.externalData = new ExternalDataManager(this.eventBus, this.dataLogger, this.uiManager);
        this.mlCore = new MachineLearningCore(this.eventBus, this.uiManager, this.dataLogger);

        // Initialize PRNG
        const initialSeed = cyrb128(`cosmic-${Date.now()}`);
        this.prng = sfc32(...initialSeed);

        this.cosmicAgent = new CosmicAwarenessAgent(this.eventBus, this.prng);
        this.pge = new ProceduralGenerationEngine(this.eventBus, this.scene, this.prng);
        this.qem = new QuantumEventManager(this.eventBus, this.scene);
        this.surfaceManager = new SurfaceManager(this.eventBus, this.scene, this.prng);
        this.audioReactive = new AudioReactiveSystem(this.scene, this.eventBus, this.camera);
        this.memoryEchoEngine = new MemoryEchoEngine(this.scene, this.camera, this.eventBus, this.dataLogger);
        this.cstCompute = new CSTComputeEngine(this.eventBus);
        
        // Wire surface spawn events
        this.eventBus.subscribe('surface:spawnSentinels', (data) => {
            if (this.surfaceManager) {
                this.surfaceManager.spawnSentinels(data.count || 5);
            }
        });
        this.eventBus.subscribe('surface:spawnMotes', (data) => {
            if (this.surfaceManager) {
                this.surfaceManager.spawnMotes(data.count || 20);
            }
        });
        
        // Initialize InputController after camera is created
        this.inputController = new InputController(this.camera, this.renderer.domElement, this.eventBus, STATE);
        this.inputController.init(this.orbitControls);

        // Bind event handlers
        this.initEventHandlers();

        // Animation loop
        this.clock = new THREE.Clock();
        this.animate = this.animate.bind(this);

        // Use centralized STATE object for physics parameters
        // STATE.params is defined globally above

        // Audio data
        this.audioData = { bass: 0, mid: 0, treble: 0, energy: 0 };

        // Set system ready flag
        window.systemReady = false;

        console.log("‚úì Application initialized");
    }

    initThreeJS() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);
        
        // Add fog for depth perception
        // FROM: CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 2
        this.scene.fog = new THREE.FogExp2(0x000000, 0.0001); // Exponential fog

        // Camera
        // FROM: Integration guide - PerspectiveCamera with appropriate near/far planes
        this.camera = new THREE.PerspectiveCamera(
            75, // FOV (matches integration guide)
            window.innerWidth / window.innerHeight,
            0.1, // Near plane
            50000 // Far plane (matches integration guide)
        );
        this.camera.position.set(0, 200, 500);

        // Renderer
        // FROM: Integration guide - WebGLRenderer with optimal settings
        const canvas = document.createElement('canvas');
        const container = document.getElementById('canvas-container');
        if (container) {
            container.appendChild(canvas);
        } else {
            document.body.appendChild(canvas);
        }

        this.renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true,
            alpha: true, // Allow transparency
            powerPreference: 'high-performance'
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        this.renderer.shadowMap.enabled = true; // Enable shadows for future use
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Post-processing Pipeline
        // FROM: CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 3 + INTEGRATION_PROMPT_PART2_ULTRA_DETAILED.md Section 2
        // All 12 passes with toggleable support
        this.composer = new EffectComposer(this.renderer);
        const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
        
        // Core render pass (always enabled)
        const renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);
        
        // Store all passes for toggling
        this.postProcessingPasses = {};
        
        // 1. FXAA (Anti-aliasing)
        const fxaaPass = new ShaderPass(FXAAShader);
        fxaaPass.material.uniforms['resolution'].value.x = 1 / window.innerWidth;
        fxaaPass.material.uniforms['resolution'].value.y = 1 / window.innerHeight;
        fxaaPass.enabled = true;
        this.composer.addPass(fxaaPass);
        this.postProcessingPasses.fxaa = fxaaPass;
        
        // 2. Bloom
        this.bloomPass = new UnrealBloomPass(resolution, 1.5, 0.4, 0.85);
        this.bloomPass.enabled = true;
        this.composer.addPass(this.bloomPass);
        this.postProcessingPasses.bloom = this.bloomPass;
        
        // 3. Vignette
        const vignettePass = new ShaderPass(VignetteShader);
        vignettePass.enabled = true;
        this.composer.addPass(vignettePass);
        this.postProcessingPasses.vignette = vignettePass;
        
        // 4. Film (grain + scanlines)
        const filmPass = new FilmPass(0.35, 0.025, 648, false);
        filmPass.enabled = false; // Disabled by default
        this.composer.addPass(filmPass);
        this.postProcessingPasses.film = filmPass;
        
        // 5. Afterimage (motion trails)
        const afterimagePass = new AfterimagePass(0.96);
        afterimagePass.enabled = false; // Disabled by default
        this.composer.addPass(afterimagePass);
        this.postProcessingPasses.afterimage = afterimagePass;
        
        // 6. RGB Shift
        const rgbShiftPass = new ShaderPass(RGBShiftShader);
        rgbShiftPass.enabled = false; // Disabled by default
        this.composer.addPass(rgbShiftPass);
        this.postProcessingPasses.rgbShift = rgbShiftPass;
        
        // 7. Godrays (for massive bodies)
        const godraysPass = new ShaderPass(GodraysShader);
        godraysPass.enabled = false; // Enabled when near massive bodies
        this.composer.addPass(godraysPass);
        this.postProcessingPasses.godrays = godraysPass;
        
        // 8. Pixelation (anime mode)
        const pixelPass = new ShaderPass(PixelShader);
        pixelPass.material.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
        pixelPass.material.uniforms['pixelSize'].value = 4.0;
        pixelPass.enabled = false; // Enabled in anime preset
        this.composer.addPass(pixelPass);
        this.postProcessingPasses.pixelation = pixelPass;
        
        // 9. Toon (cel shading)
        const toonPass = new ShaderPass(ToonShader);
        toonPass.enabled = false; // Enabled in anime preset
        this.composer.addPass(toonPass);
        this.postProcessingPasses.toon = toonPass;
        
        // 10. Gravitational Lensing (for black holes)
        const lensingPass = new ShaderPass(GravitationalLensingShader);
        lensingPass.enabled = false; // Enabled when near black holes
        this.composer.addPass(lensingPass);
        this.postProcessingPasses.lensing = lensingPass;
        
        // 11. Swirl (for QEM/echo mode)
        const swirlPass = new ShaderPass(SwirlShader);
        swirlPass.enabled = false; // Enabled in echo mode
        this.composer.addPass(swirlPass);
        this.postProcessingPasses.swirl = swirlPass;
        
        // Quality preset system
        this.currentQualityPreset = 'medium';
        this.applyQualityPreset('medium');

        // Controls
        this.orbitControls = new OrbitControls(this.camera, this.renderer.domElement);
        this.orbitControls.enableDamping = true;
        this.orbitControls.dampingFactor = 0.05;
        this.orbitControls.minDistance = 10;
        this.orbitControls.maxDistance = 10000;
        
        // Initialize InputController with orbit controls
        // (InputController will be created in Application constructor after initThreeJS)

        // Lighting
        // FROM: Integration guide - Ambient + Directional lighting
        const ambientLight = new THREE.AmbientLight(0x222222, 0.4); // Reduced intensity
        this.scene.add(ambientLight);
        
        // Directional light (sun)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(1000, 1000, 500);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 5000;
        directionalLight.shadow.camera.left = -2000;
        directionalLight.shadow.camera.right = 2000;
        directionalLight.shadow.camera.top = 2000;
        directionalLight.shadow.camera.bottom = -2000;
        // Configure shadow bias to prevent WebGL warnings (valid range: -16 to 15.99)
        directionalLight.shadow.bias = -0.0001; // Small negative bias to prevent shadow acne
        directionalLight.shadow.normalBias = 0.02; // Normal bias for better shadow quality
        this.scene.add(directionalLight);
        this.directionalLight = directionalLight; // Store reference for future updates

        // Handle window resize
        window.addEventListener('resize', () => this.onWindowResize());
    }

    initEventHandlers() {
        // UI events
        this.eventBus.subscribe('ui:regenerate', () => {
            this.cosmicAgent.generateSeed();
            this.pge.generateUniverse();
            this.uiManager.log('Universe regenerated', 'success');
        });

        // Physics parameter updates - update centralized STATE object
        this.eventBus.subscribe('physics:ugrav', (val) => { STATE.params.U_grav = val; });
        this.eventBus.subscribe('physics:lambda', (val) => { STATE.params.lambda = val; });
        this.eventBus.subscribe('physics:ec', (val) => { STATE.params.Ec = val; });
        this.eventBus.subscribe('physics:damping', (val) => { STATE.params.zeta = val; });
        this.eventBus.subscribe('physics:omega', (val) => { STATE.params.omega = val; });

        // Audio updates
        this.eventBus.subscribe('audio:update', (data) => {
            this.audioData = data;
        });

        // Start button
        const startButton = document.getElementById('start-button');
        const blocker = document.getElementById('blocker');

        startButton.addEventListener('click', async () => {
            blocker.style.opacity = '0';
            setTimeout(() => {
                blocker.style.display = 'none';
                document.getElementById('toggle-ui-button').classList.remove('ui-hidden');
                document.getElementById('ui-container').classList.remove('ui-hidden');
                document.getElementById('psi-overlay').classList.remove('ui-hidden');
            }, 500);

            if (STATE.flags.enableSensors && this.sensory?.initializeAll) {
                try {
                    await this.sensory.initializeAll();
                } catch (err) {
                    console.warn('[Genesis] Sensor initialization failed:', err);
                }
            }

            if (STATE.flags.enableExternalData && this.externalData?.refresh) {
                try {
                    await this.externalData.refresh(true);
                } catch (err) {
                    console.warn('[Genesis] External data refresh failed:', err);
                }
            }

            // Generate initial universe
            this.pge.generateUniverse();

            // Start animation
            window.systemReady = true;
            this.animate();

            this.uiManager.log('System initialized', 'success');
            this.uiManager.updateStatus('ACTIVE');
        });

        // Download ledger button
        document.getElementById('download-ledger-button')?.addEventListener('click', () => {
            this.dataLogger.downloadLedger();
        });

        // Download telemetry button
        document.getElementById('download-telemetry-button')?.addEventListener('click', () => {
            this.dataLogger.downloadTelemetry();
        });

        // Telemetry filter
        document.getElementById('telemetry-filter')?.addEventListener('input', () => {
            this.dataLogger.updateTelemetryUI();
        });
        
        // Quality preset selector
        const qualitySelect = document.getElementById('quality-select');
        if (qualitySelect) {
            qualitySelect.addEventListener('change', (e) => {
                this.applyQualityPreset(e.target.value);
            });
        }
        
        // Hotkey handlers for post-processing toggles
        // FROM: CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 3
        window.addEventListener('keydown', (e) => {
            // H - Toggle UI
            if (e.key === 'h' || e.key === 'H') {
                this.eventBus.publish('ui:toggle');
            }
            
            // Ctrl+Alt+D - Developer mode
            if (e.ctrlKey && e.altKey && e.key === 'd') {
                STATE.ui.devMode = !STATE.ui.devMode;
                this.eventBus.publish('devmode:toggle', { enabled: STATE.ui.devMode });
            }
            
            // M - Motion blur (afterimage) toggle
            if (e.key === 'm' || e.key === 'M') {
                this.togglePostEffect('afterimage');
            }
            
            // B - Bloom toggle
            if (e.key === 'b' || e.key === 'B') {
                this.togglePostEffect('bloom');
            }
            
            // V - Vignette toggle
            if (e.key === 'v' || e.key === 'V') {
                this.togglePostEffect('vignette');
            }
            
            // Esc - Exit pointer lock
            if (e.key === 'Escape') {
                document.exitPointerLock();
            }
        });
    }

    animate() {
        // FROM: CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 8 + INTEGRATION_PROMPT_PART2_ULTRA_DETAILED.md Section 3
        // Master animation loop with throttling and error handling

        if (!window.systemReady) {
        requestAnimationFrame(this.animate);
            return;
        }

        requestAnimationFrame(this.animate);

        try {
            const currentTime = performance.now();
        const delta = this.clock.getDelta();
        const elapsedTime = this.clock.getElapsedTime();

            // Update runtime state
            STATE.runtime.deltaTime = delta;
            STATE.runtime.totalTime += delta;
            STATE.runtime.frameCount++;
            
            // FPS calculation (every 60 frames)
            if (STATE.runtime.frameCount % 60 === 0) {
                STATE.runtime.fps = Math.round(1 / delta);
                if (this.uiManager && this.uiManager.updateFPS) {
                    try {
                        this.uiManager.updateFPS(STATE.runtime.fps);
                    } catch (err) {
                        console.warn('[Genesis] UI FPS update failed:', err);
                    }
                }
            }

            // 1. UPDATE INPUT
            try {
                if (this.inputController && this.inputController.update) {
                    this.inputController.update(delta);
                } else if (this.orbitControls) {
        this.orbitControls.update();
                }
            } catch (err) {
                console.error('[Genesis] InputController update error:', err);
            }

            // 2. UPDATE SENSORS (throttled to every 10 frames)
            if (STATE.runtime.frameCount % 10 === 0) {
                try {
                    if (this.sensory && this.sensory.update) {
        this.sensory.update();
                    }
                } catch (err) {
                    console.warn('[Genesis] Sensor polling error:', err);
                }
            }

            // 3. UPDATE EXTERNAL DATA (very low frequency - every 30 seconds at 60fps = 1800 frames)
            if (STATE.runtime.frameCount % 1800 === 0) {
                try {
                    if (this.externalData && this.externalData.refresh) {
                        this.externalData.refresh();
                    }
                } catch (err) {
                    console.warn('[Genesis] External data refresh error:', err);
                }
            }

            // 4. UPDATE AI
            try {
                if (this.cosmicAgent && this.cosmicAgent.tick) {
                    this.cosmicAgent.tick(currentTime);
                }
            } catch (err) {
                console.error('[Genesis] AI tick error:', err);
            }

            // 5. UPDATE SIMULATION ENGINES (mode-dependent)
            try {
                switch(STATE.currentMode) {
                    case 'universe':
                        if (this.pge && this.pge.updatePhysics) {
                            this.pge.updatePhysics(delta);
                        }
                        if (this.qem && this.qem.update) {
        this.qem.update(delta);
                        }
                        if (this.audioReactive && this.audioReactive.update) {
                            this.audioReactive.update(delta);
                        }
                        break;
                    case 'surface':
                        if (this.surfaceManager && this.surfaceManager.update) {
                            this.surfaceManager.update(delta, STATE, this.camera);
                        }
                        break;
                    case 'echo':
                        if (this.memoryEchoEngine && this.memoryEchoEngine.update) {
                            this.memoryEchoEngine.update(delta, STATE);
                        }
                        break;
                }
            } catch (err) {
                console.error(`[Genesis] ${STATE.currentMode} mode update error:`, err);
            }

            // 6. COMPUTE CST THEORY TERMS
            try {
                const allEntities = [
                    ...(this.pge ? this.pge.getEntities() : []),
                    ...(this.qem ? this.qem.getEntities() : []),
                    ...(this.surfaceManager ? this.surfaceManager.getEntities() : []),
                    ...(this.audioReactive ? this.audioReactive.getEntities() : []),
                    ...(this.memoryEchoEngine ? this.memoryEchoEngine.getEntities() : [])
                ];
                
                STATE.runtime.objectCount = allEntities.length;
                
                if (this.cstCompute) {
                    this.cstCompute.computePsi(STATE, allEntities);
                    
                    // Update each entity's 12D state
                    allEntities.forEach(entity => {
                        try {
                            this.cstCompute.updateEntityState(entity, delta);
                        } catch (err) {
                            // Silence per-entity errors (would spam console)
                        }
                    });
                }
            } catch (err) {
                console.error('[Genesis] CST computation error:', err);
            }

            // 7. UPDATE UI (throttled to every 5 frames)
            if (STATE.runtime.frameCount % 5 === 0) {
                try {
                    if (this.uiManager && this.uiManager.update) {
                        this.uiManager.update(STATE);
                    }
                } catch (err) {
                    console.warn('[Genesis] UI update error:', err);
                }
            }

            // 8. UPDATE POST-PROCESSING SHADER UNIFORMS
            if (this.postProcessingPasses) {
                try {
                    // Update swirl shader time
                    if (this.postProcessingPasses.swirl) {
                        this.postProcessingPasses.swirl.material.uniforms['time'].value = elapsedTime;
                    }
                } catch (err) {
                    console.warn('[Genesis] Post-processing uniform update error:', err);
                }
            }

            // 9. RENDER
            try {
                if (STATE.flags.enablePostProcessing && this.composer) {
                    this.composer.render(delta);
                } else if (this.renderer) {
                    this.renderer.render(this.scene, this.camera);
                }
            } catch (err) {
                console.error('[Genesis] Render error:', err);
                // Try fallback
                try {
                    if (this.renderer) {
                        this.renderer.render(this.scene, this.camera);
                    }
                } catch (fallbackErr) {
                    console.error('[Genesis] Fallback render also failed:', fallbackErr);
                }
            }

            // 10. LOG TELEMETRY (throttled to every 60 frames)
            if (STATE.runtime.frameCount % 60 === 0) {
                try {
                    if (this.dataLogger && this.dataLogger.logTelemetry) {
                        this.dataLogger.logTelemetry('runtime', {
                            fps: STATE.runtime.fps,
                            deltaTime: delta,
                            objectCount: STATE.runtime.objectCount,
                            mode: STATE.currentMode
                        });
                    }
                } catch (err) {
                    console.warn('[Genesis] Telemetry logging error:', err);
                }
            }

        } catch (err) {
            console.error('[Genesis] Critical error in animation loop:', err);
            if (this.eventBus) {
                this.eventBus.publish('system:error', { message: err.message, stack: err.stack });
            }
            // Don't stop loop - try to continue
        }
    }

    /**
     * Apply quality preset
     * FROM: CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 3
     */
    applyQualityPreset(preset) {
        this.currentQualityPreset = preset;
        const passes = this.postProcessingPasses;
        
        // Reset all passes
        Object.values(passes).forEach(pass => {
            if (pass !== passes.fxaa) { // Keep FXAA always on
                pass.enabled = false;
            }
        });
        
        switch(preset) {
            case 'anime':
                // Toon + pixelation + reduced particles
                passes.toon.enabled = true;
                passes.pixelation.enabled = true;
                passes.bloom.enabled = true;
                passes.vignette.enabled = true;
                break;
                
            case 'low':
                // FXAA only, 10k particles max
                passes.fxaa.enabled = true;
                break;
                
            case 'medium':
                // FXAA + bloom + vignette, 50k particles
                passes.fxaa.enabled = true;
                passes.bloom.enabled = true;
                passes.vignette.enabled = true;
                break;
                
            case 'high':
                // All effects except toon/pixel, 100k particles
                passes.fxaa.enabled = true;
                passes.bloom.enabled = true;
                passes.vignette.enabled = true;
                passes.film.enabled = true;
                passes.afterimage.enabled = true;
                passes.rgbShift.enabled = true;
                break;
                
            case 'ultra':
                // All effects, unlimited particles
                Object.values(passes).forEach(pass => {
                    pass.enabled = true;
                });
                break;
        }
        
        this.eventBus.publish('quality:changed', { preset });
    }

    /**
     * Toggle post-processing effect
     */
    togglePostEffect(effectName) {
        const pass = this.postProcessingPasses[effectName];
        if (pass) {
            pass.enabled = !pass.enabled;
            this.eventBus.publish('postfx:toggled', { effect: effectName, enabled: pass.enabled });
        }
    }

    onWindowResize() {
        // FROM: Integration guide - Proper window resize handling
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Update camera
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        
        // Update renderer
        this.renderer.setSize(width, height);
        
        // Update composer and all passes
        this.composer.setSize(width, height);
        
        // Update all passes that need resolution updates
        if (this.postProcessingPasses) {
            // Update FXAA
            if (this.postProcessingPasses.fxaa) {
                this.postProcessingPasses.fxaa.material.uniforms['resolution'].value.x = 1 / width;
                this.postProcessingPasses.fxaa.material.uniforms['resolution'].value.y = 1 / height;
            }
            
            // Update Bloom
            if (this.bloomPass) {
                this.bloomPass.setSize(width, height);
            }
            
            // Update Pixelation
            if (this.postProcessingPasses.pixelation) {
                this.postProcessingPasses.pixelation.material.uniforms['resolution'].value.set(width, height);
            }
        }
    }
}

// =====================================================================================
// CST COMPUTE ENGINE
// FROM: CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 8 + INTEGRATION_PROMPT_PART2_ULTRA_DETAILED.md Section 7
// =====================================================================================
/**
 * CSTComputeEngine - Computes global œà and updates entity 12D states
 */
class CSTComputeEngine {
    constructor(eventBus) {
        this.eventBus = eventBus;
        this.c = 299792458; // Speed of light (m/s)
        this.phi = 1.618033988749895; // Golden ratio
    }

    /**
     * Compute global œà formula: œà = c¬≤¬∑œÜ¬∑Ec + Œª¬∑audio + Œ©¬∑Ec + U_grav + Œ£œÅ_sd
     */
    computePsi(STATE, entities) {
        const { Ec, lambda, omega, U_grav } = STATE.params;
        const { avgFreq, spectralBands } = STATE.sensors.audio;
        
        // Term 1: c¬≤ ¬∑ œÜ ¬∑ Ec
        const term1 = Math.pow(this.c, 2) * this.phi * Ec;
        
        // Term 2: Œª (from audio)
        const term2 = lambda * (avgFreq || 0);
        
        // Term 3: Œ© ¬∑ Ec (spectral hue)
        const term3 = omega * Ec;
        
        // Term 4: U_grav (sum over massive bodies)
        let term4 = 0;
        entities.forEach(e => {
            if (e.userData && (e.userData.type === 'star' || e.userData.type === 'blackhole')) {
                const G = 6.674e-11;
                const r = e.position.length();
                term4 += G * (e.userData.mass || 1) / (r + 1); // Avoid divide-by-zero
            }
        });
        term4 *= U_grav;
        
        // Term 5: Œ£œÅ_sd (Soul Dust density)
        const soulDustEntities = entities.filter(e => 
            e.userData && e.userData.type === 'soul_dust'
        );
        const term5 = soulDustEntities.length * 0.01; // Proxy density
        
        // Sum
        const psi = term1 + term2 + term3 + term4 + term5;
        
        // Update STATE
        STATE.cst.psi = psi;
        STATE.cst.term1_Ec = term1;
        STATE.cst.term2_lambda = term2;
        STATE.cst.term3_omega = term3;
        STATE.cst.term4_Ugrav = term4;
        STATE.cst.term5_rho = term5;
        
        // Update history (keep last 100)
        STATE.cst.psi_history.push({ psi, timestamp: Date.now() });
        if (STATE.cst.psi_history.length > 100) {
            STATE.cst.psi_history.shift();
        }
        
        // Emit for logging
        this.eventBus.publish('cst:psi_update', {
            term1, term2, term3, term4, term5, psi,
            timestamp: Date.now()
        });
        
        return psi;
    }

    /**
     * Update entity 12D state
     */
    updateEntityState(entity, deltaTime) {
        if (!entity.userData || !entity.userData.h12) return;

        // Update x12 based on physics/interactions
        // For now, sync with position/velocity
        entity.userData.x12[0] = entity.position.x / 100;
        entity.userData.x12[1] = entity.position.y / 100;
        entity.userData.x12[2] = entity.position.z / 100;

        if (entity.userData.velocity) {
            entity.userData.x12[3] = entity.userData.velocity.x;
            entity.userData.x12[4] = entity.userData.velocity.y;
            entity.userData.x12[5] = entity.userData.velocity.z;
        }

        // Update m12 with EMA: m12(t) = Œ±¬∑x12(t) + (1-Œ±)¬∑m12(t-1)
        const alpha = entity.userData.memoryAlpha || 0.1;
        for (let i = 0; i < 12; i++) {
            entity.userData.m12[i] = alpha * entity.userData.x12[i] + (1 - alpha) * entity.userData.m12[i];
        }

        // Update h12 (state vector) - sync with x12 for now
        entity.userData.h12.set(entity.userData.x12);

        // Update connectivity Œ©·µ¢ (simplified heuristic)
        // In full implementation, this would compute graph Laplacian
        entity.userData.connectivity = Math.random() * 0.1; // Placeholder

        // Compute individual entity œà (for Soul Dust coalescence)
        if (entity.userData.type === 'soul_dust') {
            this.computeEntityPsi(entity, STATE);
        }
    }

    /**
     * Compute individual entity œà for Soul Dust particles
     * Used for coalescence threshold checking
     */
    computeEntityPsi(entity, STATE) {
        if (!entity.userData || !entity.userData.h12) return;

        const { Ec, lambda, omega, U_grav } = STATE.params;

        // Simplified per-particle œà calculation
        const energyTerm = Ec * (entity.userData.h12[10] || 0); // h12[10] = energy
        const audioTerm = lambda * (entity.userData.h12[7] || 0); // h12[7] = audio
        const spectralTerm = omega * (entity.userData.h12[9] || 0); // h12[9] = spectral
        const chaosTerm = (entity.userData.h12[8] || 0) * 0.1; // h12[8] = chaos

        // Sum for particle œà
        entity.userData.psi = energyTerm + audioTerm + spectralTerm + chaosTerm;

        return entity.userData.psi;
    }
}

// =====================================================================================
// MODE MANAGEMENT
// FROM: CLAUDE_CODE_INTEGRATION_PROMPT.md Phase 7
// =====================================================================================
/**
 * Apply mode switching (non-destructive)
 * @param {string} mode - 'universe' | 'surface' | 'echo'
 * @param {Object} systems - Object containing all engine references
 */
function _applyMode(mode, systems) {
    STATE.currentMode = mode;
    
    switch(mode) {
        case 'universe':
            // Show: PGE objects, QEM particles, AudioReactive
            if (systems.pge) systems.pge.setVisible(true);
            if (systems.qem) systems.qem.setVisible(true);
            if (systems.audioReactive) systems.audioReactive.setVisible(true);
            // Hide: Surface, MemoryEcho
            if (systems.surfaceManager) systems.surfaceManager.setVisible(false);
            if (systems.memoryEchoEngine) systems.memoryEchoEngine.setVisible(false);
            break;
            
        case 'surface':
            // Show: Surface terrain, vegetation, sentinels, motes
            if (systems.surfaceManager) systems.surfaceManager.setVisible(true);
            // Hide: Galaxy particles (far), QEM, AudioReactive
            if (systems.pge) systems.pge.setVisible(false);
            if (systems.qem) systems.qem.setVisible(false);
            if (systems.audioReactive) systems.audioReactive.setVisible(false);
            break;
            
        case 'echo':
            // Show: MemoryEcho visualization
            if (systems.memoryEchoEngine) systems.memoryEchoEngine.setVisible(true);
            // Hide: All other engines
            if (systems.pge) systems.pge.setVisible(false);
            if (systems.qem) systems.qem.setVisible(false);
            if (systems.surfaceManager) systems.surfaceManager.setVisible(false);
            if (systems.audioReactive) systems.audioReactive.setVisible(false);
            break;
    }
    
    if (systems.eventBus) {
        systems.eventBus.publish('mode:changed', { mode });
    }
    if (systems.dataLogger) {
        systems.dataLogger.logLedger('info', 'System', `Mode switched to: ${mode}`);
    }
}

// =====================================================================================
// INITIALIZE APPLICATION
// =====================================================================================
console.log("‚úì All systems loaded");
console.log("‚úì Initializing Cosmic Genesis Engine...");

const app = new Application();

console.log("üåå Cosmic Genesis 12D CST v3 Engine ‚Äî Ready!");
console.log("Click 'Initiate Genesis' to begin...");
</script>
</body>
</html>
